import{e as an,n as fi,s as bi,t as gi,b as ki,c as yi,f as wi,g as vi,h as Si,o as Ei,a as Ai}from"./main-CTRY_VYq.js";import{p as Ut,a as Gt,E as sr,b as on,n as ln}from"./index-BUReOOGB.js";function w(t,e){if(!t)throw new Error(e||"assertion failure")}function q(t){Oi.warn(`DEPRECATION: ${t}`)}function nr(t){if(t==null)throw new Error("Expected value to be present");return t}function ut(t,e){if(t==null)throw new Error(e);return t}function dt(t){throw new Error(`Exhausted ${String(t)}`)}function _(t){return t.length>0}function Ye(t,e="unexpected empty list"){if(!_(t))throw new Error(e)}function qe(t,e="unexpected empty list"){return Ye(t,e),t}function rt(t){return t.length===0?void 0:t[t.length-1]}function Yr(t){return t.length===0?void 0:t[0]}function cn(t,e){if(t===null)return null;let r=[];for(let s of t)r.push(e(s));return r}function oe(){return Object.create(null)}const Pi="http://www.w3.org/1999/xlink",Ci="http://www.w3.org/XML/1998/namespace",As="http://www.w3.org/2000/xmlns/";let qr=function(t){return t[t.MAX_SMI=1073741823]="MAX_SMI",t[t.MIN_SMI=-1073741824]="MIN_SMI",t[t.SIGN_BIT=-536870913]="SIGN_BIT",t[t.MAX_INT=536870911]="MAX_INT",t[t.MIN_INT=-536870912]="MIN_INT",t[t.FALSE_HANDLE=0]="FALSE_HANDLE",t[t.TRUE_HANDLE=1]="TRUE_HANDLE",t[t.NULL_HANDLE=2]="NULL_HANDLE",t[t.UNDEFINED_HANDLE=3]="UNDEFINED_HANDLE",t[t.ENCODED_FALSE_HANDLE=0]="ENCODED_FALSE_HANDLE",t[t.ENCODED_TRUE_HANDLE=1]="ENCODED_TRUE_HANDLE",t[t.ENCODED_NULL_HANDLE=2]="ENCODED_NULL_HANDLE",t[t.ENCODED_UNDEFINED_HANDLE=3]="ENCODED_UNDEFINED_HANDLE",t}({});function Ni(t){return t&qr.SIGN_BIT}function xi(t){return t|~qr.SIGN_BIT}function Ti(t){return~t}function Bi(t){return~t}function Li(t){return(t|=0)<0?Ni(t):Ti(t)}function $i(t){return(t|=0)>qr.SIGN_BIT?Bi(t):xi(t)}[1,-1].forEach(t=>$i(Li(t)));let ie=Object.assign;function Hi(t){return Object.values(t)}const Oi=console,Ps=console;function me(t,e="unexpected unreachable branch"){throw Ps.log("unreachable",t),Ps.log(`${e} :: ${JSON.stringify(t)} (${t})`),new Error("code reached unreachable")}const u={Append:1,TrustingAppend:2,Comment:3,Modifier:4,StrictModifier:5,Block:6,StrictBlock:7,Component:8,OpenElement:10,OpenElementWithSplat:11,FlushElement:12,CloseElement:13,StaticAttr:14,DynamicAttr:15,ComponentAttr:16,AttrSplat:17,Yield:18,DynamicArg:20,StaticArg:21,TrustingDynamicAttr:22,TrustingComponentAttr:23,StaticComponentAttr:24,Debugger:26,Undefined:27,Call:28,Concat:29,GetSymbol:30,GetLexicalSymbol:32,GetStrictKeyword:31,GetFreeAsComponentOrHelperHead:35,GetFreeAsHelperHead:37,GetFreeAsModifierHead:38,GetFreeAsComponentHead:39,InElement:40,If:41,Each:42,Let:44,WithDynamicVars:45,InvokeComponent:46,HasBlock:48,HasBlockParams:49,Curry:50,Not:51,IfInline:52,GetDynamicVar:53,Log:54},te={Strict:0,ResolveAsComponentOrHelperHead:1,ResolveAsHelperHead:5,ResolveAsModifierHead:6,ResolveAsComponentHead:7},Be={class:0,id:1,value:2,name:3,type:4,style:5,href:6},Ht={div:0,span:1,p:2,a:3};var ye=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(ye||{});const un=/["&\xA0]/u,Ii=new RegExp(un.source,"gu"),hn=/[&<>\xA0]/u,Mi=new RegExp(hn.source,"gu");function Fi(t){switch(t.charCodeAt(0)){case ye.NBSP:return"&nbsp;";case ye.QUOT:return"&quot;";case ye.AMP:return"&amp;";default:return t}}function Di(t){switch(t.charCodeAt(0)){case ye.NBSP:return"&nbsp;";case ye.AMP:return"&amp;";case ye.LT:return"&lt;";case ye.GT:return"&gt;";default:return t}}function _i(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const Br=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]),Vi=/^\S/u;function pn(t){return Br.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}let Xr=class{buffer="";options;constructor(e){this.options=e}handledByOverride(e,r=!1){if(this.options.override!==void 0){let s=this.options.override(e,this.options);if(typeof s=="string")return r&&Vi.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(e){switch(e.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(e);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(e);case"ConcatStatement":return this.ConcatStatement(e);case"Hash":return this.Hash(e);case"HashPair":return this.HashPair(e);case"ElementModifierStatement":return this.ElementModifierStatement(e)}}Expression(e){switch(e.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(e);case"PathExpression":return this.PathExpression(e);case"SubExpression":return this.SubExpression(e)}}Literal(e){switch(e.type){case"StringLiteral":return this.StringLiteral(e);case"BooleanLiteral":return this.BooleanLiteral(e);case"NumberLiteral":return this.NumberLiteral(e);case"UndefinedLiteral":return this.UndefinedLiteral(e);case"NullLiteral":return this.NullLiteral(e)}}TopLevelStatement(e){switch(e.type){case"MustacheStatement":return this.MustacheStatement(e);case"BlockStatement":return this.BlockStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":return this.CommentStatement(e);case"TextNode":return this.TextNode(e);case"ElementNode":return this.ElementNode(e);case"Block":return this.Block(e);case"Template":return this.Template(e);case"AttrNode":return this.AttrNode(e)}}Template(e){this.TopLevelStatements(e.body)}Block(e){e.chained&&(e.body[0].chained=!0),this.handledByOverride(e)||this.TopLevelStatements(e.body)}TopLevelStatements(e){e.forEach(r=>this.TopLevelStatement(r))}ElementNode(e){this.handledByOverride(e)||(this.OpenElementNode(e),this.TopLevelStatements(e.children),this.CloseElementNode(e))}OpenElementNode(e){this.buffer+=`<${e.tag}`;const r=[...e.attributes,...e.modifiers,...e.comments].sort(_i);for(const s of r)switch(this.buffer+=" ",s.type){case"AttrNode":this.AttrNode(s);break;case"ElementModifierStatement":this.ElementModifierStatement(s);break;case"MustacheCommentStatement":this.MustacheCommentStatement(s)}e.blockParams.length&&this.BlockParams(e.blockParams),e.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(e){e.selfClosing||pn(e.tag)||(this.buffer+=`</${e.tag}>`)}AttrNode(e){if(this.handledByOverride(e))return;let{name:r,value:s}=e;this.buffer+=r,(s.type!=="TextNode"||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(e){e.type==="TextNode"?(this.buffer+='"',this.TextNode(e,!0),this.buffer+='"'):this.Node(e)}TextNode(e,r){var s;this.handledByOverride(e)||(this.options.entityEncoding==="raw"?this.buffer+=e.chars:this.buffer+=r?(s=e.chars,un.test(s)?s.replace(Ii,Fi):s):function(n){return hn.test(n)?n.replace(Mi,Di):n}(e.chars))}MustacheStatement(e){this.handledByOverride(e)||(this.buffer+=e.trusting?"{{{":"{{",e.strip.open&&(this.buffer+="~"),this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.strip.close&&(this.buffer+="~"),this.buffer+=e.trusting?"}}}":"}}")}BlockStatement(e){this.handledByOverride(e)||(e.chained?(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=e.openStrip.open?"{{~#":"{{#",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.program.blockParams.length&&this.BlockParams(e.program.blockParams),e.chained?this.buffer+=e.inverseStrip.close?"~}}":"}}":this.buffer+=e.openStrip.close?"~}}":"}}",this.Block(e.program),e.inverse&&(e.inverse.chained||(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=e.inverseStrip.close?"~}}":"}}"),this.Block(e.inverse)),e.chained||(this.buffer+=e.closeStrip.open?"{{~/":"{{/",this.Expression(e.path),this.buffer+=e.closeStrip.close?"~}}":"}}"))}BlockParams(e){this.buffer+=` as |${e.join(" ")}|`}ConcatStatement(e){this.handledByOverride(e)||(this.buffer+='"',e.parts.forEach(r=>{r.type==="TextNode"?this.TextNode(r,!0):this.Node(r)}),this.buffer+='"')}MustacheCommentStatement(e){this.handledByOverride(e)||(this.buffer+=`{{!--${e.value}--}}`)}ElementModifierStatement(e){this.handledByOverride(e)||(this.buffer+="{{",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}CommentStatement(e){this.handledByOverride(e)||(this.buffer+=`<!--${e.value}-->`)}PathExpression(e){this.handledByOverride(e)||(this.buffer+=e.original)}SubExpression(e){this.handledByOverride(e)||(this.buffer+="(",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+=")")}Params(e){e.length&&e.forEach(r=>{this.buffer+=" ",this.Expression(r)})}Hash(e){this.handledByOverride(e,!0)||e.pairs.forEach(r=>{this.buffer+=" ",this.HashPair(r)})}HashPair(e){this.handledByOverride(e)||(this.buffer+=e.key,this.buffer+="=",this.Node(e.value))}StringLiteral(e){this.handledByOverride(e)||(this.buffer+=JSON.stringify(e.value))}BooleanLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}NumberLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}UndefinedLiteral(e){this.handledByOverride(e)||(this.buffer+="undefined")}NullLiteral(e){this.handledByOverride(e)||(this.buffer+="null")}print(e){let{options:r}=this;if(r.override){let s=r.override(e,r);if(s!==void 0)return s}return this.buffer="",this.Node(e),this.buffer}};function zi(t,e={entityEncoding:"transformed"}){return t?new Xr(e).print(t):""}function Ui(t,e){return t in Qr&&e===void 0}const Qr={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]},fe=Object.freeze({line:1,column:0}),dn=Object.freeze({source:"(synthetic)",start:fe,end:fe}),Ge=Object.freeze({source:"(nonexistent)",start:fe,end:fe}),we=Object.freeze({source:"(broken)",start:fe,end:fe});let E=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const mt="MATCH_ANY",Lr="IS_INVISIBLE";let Gi=class{_whens;constructor(e){this._whens=e}first(e){for(const r of this._whens){const s=r.match(e);if(_(s))return s[0]}return null}},Cs=class{_map=new Map;get(e,r){let s=this._map.get(e);return s||(s=r(),this._map.set(e,s),s)}add(e,r){this._map.set(e,r)}match(e){const r=function(i){switch(i){case E.Broken:case E.InternalsSynthetic:case E.NonExistent:return Lr;default:return i}}(e),s=[],n=this._map.get(r),a=this._map.get(mt);return n&&s.push(n),a&&s.push(a),s}};function mn(t){return t(new Ri).check()}let Ri=class{_whens=new Cs;check(){return(e,r)=>this.matchFor(e.kind,r.kind)(e,r)}matchFor(e,r){const s=this._whens.match(e);w(_(s),`no match defined for (${e}, ${r}) and no AnyMatch defined either`);const n=new Gi(s).first(r);return w(n!==null,`no match defined for (${e}, ${r}) and no AnyMatch defined either`),n}when(e,r,s){return this._whens.get(e,()=>new Cs).add(r,s),this}},Z=class $r{static synthetic(e){let r=z.synthetic(e);return new $r({loc:r,chars:e})}static load(e,r){return new $r({loc:z.load(e,r[1]),chars:r[0]})}chars;loc;constructor(e){this.loc=e.loc,this.chars=e.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}},z=class ze{static get NON_EXISTENT(){return new $e(E.NonExistent,Ge).wrap()}static load(e,r){return typeof r=="number"?ze.forCharPositions(e,r,r):typeof r=="string"?ze.synthetic(r):Array.isArray(r)?ze.forCharPositions(e,r[0],r[1]):r===E.NonExistent?ze.NON_EXISTENT:r===E.Broken?ze.broken(we):void me(r)}static forHbsLoc(e,r){const s=new Xe(e,r.start),n=new Xe(e,r.end);return new es(e,{start:s,end:n},r).wrap()}static forCharPositions(e,r,s){const n=new ft(e,r),a=new ft(e,s);return new Zr(e,{start:n,end:a}).wrap()}static synthetic(e){return new $e(E.InternalsSynthetic,Ge,e).wrap()}static broken(e=we){return new $e(E.Broken,e).wrap()}isInvisible;constructor(e){this.data=e,this.isInvisible=e.kind!==E.CharPosition&&e.kind!==E.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const e=this.data.toHbsSpan();return e===null?we:e.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(e){return se(e.data,this.data.getEnd())}withEnd(e){return se(this.data.getStart(),e.data)}asString(){return this.data.asString()}toSlice(e){const r=this.data.asString();return new Z({loc:this,chars:e||r})}get start(){return this.loc.start}set start(e){this.data.locDidUpdate({start:e})}get end(){return this.loc.end}set end(e){this.data.locDidUpdate({end:e})}get source(){return this.module}collapse(e){switch(e){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(e){return se(this.data.getStart(),e.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:e=0,skipEnd:r=0}){return se(this.getStart().move(e).data,this.getEnd().move(-r).data)}sliceStartChars({skipStart:e=0,chars:r}){return se(this.getStart().move(e).data,this.getStart().move(e+r).data)}sliceEndChars({skipEnd:e=0,chars:r}){return se(this.getEnd().move(e-r).data,this.getStart().move(-e).data)}},Zr=class{kind=E.CharPosition;_locPosSpan=null;constructor(e,r){this.source=e,this.charPositions=r}wrap(){return new z(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let e=this._locPosSpan;if(e===null){const r=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();e=this._locPosSpan=r===null||s===null?Ae:new es(this.source,{start:r,end:s})}return e===Ae?null:e}serialize(){const{start:{charPos:e},end:{charPos:r}}=this.charPositions;return e===r?e:[e,r]}toCharPosSpan(){return this}},es=class{kind=E.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(e,r,s=null){this.source=e,this.hbsPositions=r,this._providedHbsLoc=s}serialize(){const e=this.toCharPosSpan();return e===null?E.Broken:e.wrap().serialize()}wrap(){return new z(this)}updateProvided(e,r){this._providedHbsLoc&&(this._providedHbsLoc[r]=e),this._charPosSpan=null,this._providedHbsLoc={start:e,end:e}}locDidUpdate({start:e,end:r}){e!==void 0&&(this.updateProvided(e,"start"),this.hbsPositions.start=new Xe(this.source,e,null)),r!==void 0&&(this.updateProvided(r,"end"),this.hbsPositions.end=new Xe(this.source,r,null))}asString(){const e=this.toCharPosSpan();return e===null?"":e.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let e=this._charPosSpan;if(e===null){const r=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!r||!s)return e=this._charPosSpan=Ae,null;e=this._charPosSpan=new Zr(this.source,{start:r,end:s})}return e===Ae?null:e}},$e=class{constructor(e,r,s=null){this.kind=e,this.loc=r,this.string=s}serialize(){switch(this.kind){case E.Broken:case E.NonExistent:return this.kind;case E.InternalsSynthetic:return this.string||""}}wrap(){return new z(this)}asString(){return this.string||""}locDidUpdate({start:e,end:r}){e!==void 0&&(this.loc.start=e),r!==void 0&&(this.loc.end=r)}getModule(){return"an unknown module"}getStart(){return new Or(this.kind,this.loc.start)}getEnd(){return new Or(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return we}};const se=mn(t=>t.when(E.HbsPosition,E.HbsPosition,(e,r)=>new es(e.source,{start:e,end:r}).wrap()).when(E.CharPosition,E.CharPosition,(e,r)=>new Zr(e.source,{start:e,end:r}).wrap()).when(E.CharPosition,E.HbsPosition,(e,r)=>{const s=r.toCharPos();return s===null?new $e(E.Broken,we).wrap():se(e,s)}).when(E.HbsPosition,E.CharPosition,(e,r)=>{const s=e.toCharPos();return s===null?new $e(E.Broken,we).wrap():se(s,r)}).when(Lr,mt,e=>new $e(e.kind,we).wrap()).when(mt,Lr,(e,r)=>new $e(r.kind,we).wrap())),Ae="BROKEN";let Ct=class Hr{static forHbsPos(e,r){return new Xe(e,r,null).wrap()}static broken(e=fe){return new Or(E.Broken,e).wrap()}constructor(e){this.data=e}get offset(){const e=this.data.toCharPos();return e===null?null:e.offset}eql(e){return ji(this.data,e.data)}until(e){return se(this.data,e.data)}move(e){const r=this.data.toCharPos();if(r===null)return Hr.broken();{const s=r.offset+e;return r.source.check(s)?new ft(r.source,s).wrap():Hr.broken()}}collapsed(){return se(this.data,this.data)}toJSON(){return this.data.toJSON()}},ft=class{kind=E.CharPosition;_locPos=null;constructor(e,r){this.source=e,this.charPos=r}toCharPos(){return this}toJSON(){const e=this.toHbsPos();return e===null?fe:e.toJSON()}wrap(){return new Ct(this)}get offset(){return this.charPos}toHbsPos(){let e=this._locPos;if(e===null){const r=this.source.hbsPosFor(this.charPos);this._locPos=e=r===null?Ae:new Xe(this.source,r,this.charPos)}return e===Ae?null:e}},Xe=class{kind=E.HbsPosition;_charPos;constructor(e,r,s=null){this.source=e,this.hbsPos=r,this._charPos=s===null?null:new ft(e,s)}toCharPos(){let e=this._charPos;if(e===null){const r=this.source.charPosFor(this.hbsPos);this._charPos=e=r===null?Ae:new ft(this.source,r)}return e===Ae?null:e}toJSON(){return this.hbsPos}wrap(){return new Ct(this)}toHbsPos(){return this}},Or=class{constructor(e,r){this.kind=e,this.pos=r}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new Ct(this)}get offset(){return null}};const ji=mn(t=>t.when(E.HbsPosition,E.HbsPosition,({hbsPos:e},{hbsPos:r})=>e.column===r.column&&e.line===r.line).when(E.CharPosition,E.CharPosition,({charPos:e},{charPos:r})=>e===r).when(E.CharPosition,E.HbsPosition,({offset:e},r)=>e===r.toCharPos()?.offset).when(E.HbsPosition,E.CharPosition,(e,{offset:r})=>e.toCharPos()?.offset===r).when(mt,mt,()=>!1));let Re=class fn{static from(e,r={}){return new fn(e,r.meta?.moduleName)}constructor(e,r="an unknown module"){this.source=e,this.module=r}check(e){return e>=0&&e<=this.source.length}slice(e,r){return this.source.slice(e,r)}offsetFor(e,r){return Ct.forHbsPos(this,{line:e,column:r})}spanFor({start:e,end:r}){return z.forHbsLoc(this,{start:{line:e.line,column:e.column},end:{line:r.line,column:r.column}})}hbsPosFor(e){let r=0,s=0;if(e>this.source.length)return null;for(;;){let n=this.source.indexOf(`
`,s);if(e<=n||n===-1)return{line:r+1,column:e-s};r+=1,s=n+1}}charPosFor(e){let{line:r,column:s}=e,n=this.source.length,a=0,i=0;for(;i<n;){let o=this.source.indexOf(`
`,i);if(o===-1&&(o=this.source.length),a===r-1)return i+s>o?o:i+s;if(o===-1)return 0;a+=1,i=o+1}return n}},Pe=class bn{static range(e,r=z.NON_EXISTENT){return new bn(e.map(Qe)).getRangeOffset(r)}_span;constructor(e=[]){this._span=e}add(e){this._span.push(e)}getRangeOffset(e){if(_(this._span)){let r=Yr(this._span),s=rt(this._span);return r.extend(s)}return e}};function Qe(t){if(Array.isArray(t)){let e=Yr(t),r=rt(t);return Qe(e).extend(Qe(r))}return t instanceof z?t:t.loc}function gn(t){return!Array.isArray(t)||t.length!==0}function Ir(t,e){return gn(t)?Qe(t):e}var Rt=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:Ge,SYNTHETIC_LOCATION:dn,Source:Re,SourceOffset:Ct,SourceSlice:Z,SourceSpan:z,SpanList:Pe,UNKNOWN_POSITION:fe,hasSpan:gn,loc:Qe,maybeLoc:Ir});function p(t,e){let{module:r,loc:s}=e,{line:n,column:a}=s.start,i=e.asString(),o=i?`

|
|  ${i.split(`
`).join(`
|  `)}
|

`:"",l=new Error(`${t}: ${o}(error occurred in '${r}' @ line ${n} : column ${a})`);return l.name="SyntaxError",l.location=e,l.code=i,l}const Ji={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},ts=function(){function t(e,r,s,n){let a=Error.call(this,e);this.key=n,this.message=e,this.node=r,this.parent=s,a.stack&&(this.stack=a.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function Ns(t,e,r){return new ts("Cannot remove a node unless it is part of an array",t,e,r)}function Ki(t,e,r){return new ts("Cannot replace a node with multiple nodes unless it is part of an array",t,e,r)}function xs(t,e){return new ts("Replacing and removing in key handlers is not yet supported.",t,null,e)}let ar=class{node;parent;parentKey;constructor(e,r=null,s=null){this.node=e,this.parent=r,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new Wi(this)}}},Wi=class{path;constructor(e){this.path=e}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}};function kn(t){return typeof t=="function"?t:t.enter}function yn(t){return typeof t=="function"?void 0:t.exit}function ir(t,e){let r,s,n,{node:a,parent:i,parentKey:o}=e,l=function(c,h){if(c.Program&&(h==="Template"&&!c.Template||h==="Block"&&!c.Block))return q(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${h}') `),c.Program;let d=c[h];return d!==void 0?d:c.All}(t,a.type);if(l!==void 0&&(r=kn(l),s=yn(l)),r!==void 0&&(n=r(a,e)),n!=null){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(wn(t,n,i,o),n):ir(t,new ar(n,i,o))||n;n=void 0}if(n===void 0){let c=Ji[a.type];for(let h=0;h<c.length;h++)Yi(t,l,e,c[h]);s!==void 0&&(n=s(a,e))}return n}function Ts(t,e,r){t[e]=r}function Yi(t,e,r,s){let n,a,{node:i}=r,o=function(l,c){return l[c]}(i,s);if(o){if(e!==void 0){let l=function(c,h){let d=typeof c!="function"?c.keys:void 0;if(d===void 0)return;let m=d[h];return m!==void 0?m:d.All}(e,s);l!==void 0&&(n=kn(l),a=yn(l))}if(n!==void 0&&n(i,s)!==void 0)throw xs(i,s);if(Array.isArray(o))wn(t,o,r,s);else{let l=ir(t,new ar(o,r,s));l!==void 0&&function(c,h,d,m){if(m===null)throw Ns(d,c,h);if(Array.isArray(m)){if(m.length!==1)throw m.length===0?Ns(d,c,h):Ki(d,c,h);Ts(c,h,m[0])}else Ts(c,h,m)}(i,s,o,l)}if(a!==void 0&&a(i,s)!==void 0)throw xs(i,s)}}function wn(t,e,r,s){for(let n=0;n<e.length;n++){let a=nr(e[n]),i=ir(t,new ar(a,r,s));i!==void 0&&(n+=qi(e,n,i)-1)}}function qi(t,e,r){return r===null?(t.splice(e,1),0):Array.isArray(r)?(t.splice(e,1,...r),r.length):(t.splice(e,1,r),1)}function vn(t,e){ir(e,new ar(t))}let Xi=class{stack=[];constructor(e){this.order=e}visit(e,r){e&&(this.stack.push(e),this.order==="post"?(this.children(e,r),r(e,this)):(r(e,this),this.children(e,r)),this.stack.pop())}children(e,r){switch(e.type){case"Block":case"Template":return void Bs(this,e.body,r);case"ElementNode":return void Bs(this,e.children,r);case"BlockStatement":return this.visit(e.program,r),void this.visit(e.inverse||null,r);default:return}}};function Bs(t,e,r){for(const s of e)t.visit(s,r)}function je(t,e){(function(r){switch(r.type){case"Block":case"Template":return r.body;case"ElementNode":return r.children}})(t).push(e)}function Sn(t){return t.type==="StringLiteral"||t.type==="BooleanLiteral"||t.type==="NumberLiteral"||t.type==="NullLiteral"||t.type==="UndefinedLiteral"}let mr;function fr(){return mr||(mr=new Re("","(synthetic)")),mr}function Ls(t,e){return f.var({name:t,loc:$(e||null)})}function ke(t,e){let r=$(e||null);if(typeof t!="string"){if("type"in t)return t;{w(t.head.indexOf(".")===-1,"builder.path({ head, tail }) should not be called with a head with dots in it");let{head:a,tail:i}=t;return f.path({head:f.head({original:a,loc:r.sliceStartChars({chars:a.length})}),tail:i,loc:$(e||null)})}}let{head:s,tail:n}=function(a,i){let[o,...l]=qe(a.split(".")),c=f.head({original:o,loc:$(i||null)});return f.path({head:c,tail:l,loc:$(i||null)})}(t,r);return f.path({head:s,tail:n,loc:r})}function Ft(t,e,r){return f.literal({type:t,value:e,loc:$(r||null)})}function ot(t=[],e){return f.hash({pairs:t,loc:$(e||null)})}function En(t){return t.map(e=>typeof e=="string"?f.var({name:e,loc:z.synthetic(e)}):e)}function $s(t=[],e=[],r=!1,s){return f.blockItself({body:t,params:En(e),chained:r,loc:$(s||null)})}function Hs(t=[],e=[],r){return f.template({body:t,blockParams:e,loc:$(r||null)})}function $(...t){if(t.length===1){let e=t[0];return e&&typeof e=="object"?z.forHbsLoc(fr(),e):z.forHbsLoc(fr(),dn)}{let[e,r,s,n,a]=t,i=a?new Re("",a):fr();return z.forHbsLoc(i,{start:{line:e,column:r},end:{line:s||e,column:n||r}})}}var An={mustache:function(t,e=[],r=ot([]),s=!1,n,a){return f.mustache({path:ke(t),params:e,hash:r,trusting:s,strip:a,loc:$(n||null)})},block:function(t,e,r,s,n=null,a,i,o,l){let c,h=null;return s.type==="Template"?(q("b.program is deprecated. Use b.blockItself instead."),c=f.blockItself({params:En(s.blockParams),body:s.body,loc:s.loc})):c=s,n?.type==="Template"?(q("b.program is deprecated. Use b.blockItself instead."),w(n.blockParams.length===0,"{{else}} block cannot have block params"),h=f.blockItself({params:[],body:n.body,loc:n.loc})):h=n,f.block({path:ke(t),params:e||[],hash:r||ot([]),defaultBlock:c,elseBlock:h,loc:$(a||null),openStrip:i,inverseStrip:o,closeStrip:l})},comment:function(t,e){return f.comment({value:t,loc:$(e||null)})},mustacheComment:function(t,e){return f.mustacheComment({value:t,loc:$(e||null)})},element:function(t,e={}){let r,s,{attrs:n,blockParams:a,modifiers:i,comments:o,children:l,openTag:c,closeTag:h,loc:d}=e;typeof t=="string"?t.endsWith("/")?(r=ke(t.slice(0,-1)),s=!0):r=ke(t):"type"in t?(w(t.type==="PathExpression",`Invalid tag type ${t.type}`),r=t):"path"in t?(w(t.path.type==="PathExpression",`Invalid tag type ${t.path.type}`),r=t.path,s=t.selfClosing):(r=ke(t.name),s=t.selfClosing),s&&w(h==null,"Cannot build a self-closing tag with a closeTag source location");let m=a?.map(v=>typeof v=="string"?Ls(v):v),g=null;return h?g=$(h||null):h===void 0&&(g=s||pn(r.original)?null:$(null)),f.element({path:r,selfClosing:s||!1,attributes:n||[],params:m||[],modifiers:i||[],comments:o||[],children:l||[],openTag:$(c||null),closeTag:g,loc:$(d||null)})},elementModifier:function(t,e,r,s){return f.elementModifier({path:ke(t),params:e||[],hash:r||ot([]),loc:$(s||null)})},attr:function(t,e,r){return f.attr({name:t,value:e,loc:$(r||null)})},text:function(t="",e){return f.text({chars:t,loc:$(e||null)})},sexpr:function(t,e=[],r=ot([]),s){return f.sexpr({path:ke(t),params:e,hash:r,loc:$(s||null)})},concat:function(t,e){if(!_(t))throw new Error("b.concat requires at least one part");return f.concat({parts:t,loc:$(e||null)})},hash:ot,pair:function(t,e,r){return f.pair({key:t,value:e,loc:$(r||null)})},literal:Ft,program:function(t,e,r){return q("b.program is deprecated. Use b.template or b.blockItself instead."),e&&e.length?$s(t,e,!1,r):Hs(t,[],r)},blockItself:$s,template:Hs,loc:$,pos:function(t,e){return f.pos({line:t,column:e})},path:ke,fullPath:function(t,e=[],r){return f.path({head:t,tail:e,loc:$(r||null)})},head:function(t,e){return f.head({original:t,loc:$(e||null)})},at:function(t,e){return f.atName({name:t,loc:$(e||null)})},var:Ls,this:function(t){return f.this({loc:$(t||null)})},string:br("StringLiteral"),boolean:br("BooleanLiteral"),number:br("NumberLiteral"),undefined:()=>Ft("UndefinedLiteral",void 0),null:()=>Ft("NullLiteral",null)};function br(t){return function(e,r){return Ft(t,e,r)}}const Ot={close:!1,open:!1},f=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:r=!1,loc:s}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map(n=>n.name)},set blockParams(n){this.params=n.map(a=>f.var({name:a,loc:z.synthetic(a)}))},chained:r,loc:s}}template({body:t,blockParams:e,loc:r}){return{type:"Template",body:t,blockParams:e,loc:r}}mustache({path:t,params:e,hash:r,trusting:s,loc:n,strip:a=Ot}){return function({path:i,params:o,hash:l,trusting:c,strip:h,loc:d}){const m={type:"MustacheStatement",path:i,params:o,hash:l,trusting:c,strip:h,loc:d};return Object.defineProperty(m,"escaped",{enumerable:!1,get(){return q("The escaped property on mustache nodes is deprecated, use trusting instead"),!this.trusting},set(g){q("The escaped property on mustache nodes is deprecated, use trusting instead"),this.trusting=!g}}),m}({path:t,params:e,hash:r,trusting:s,strip:a,loc:n})}block({path:t,params:e,hash:r,defaultBlock:s,elseBlock:n=null,loc:a,openStrip:i=Ot,inverseStrip:o=Ot,closeStrip:l=Ot}){return{type:"BlockStatement",path:t,params:e,hash:r,program:s,inverse:n,loc:a,openStrip:i,inverseStrip:o,closeStrip:l}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:o,closeTag:l,loc:c,get tag(){return this.path.original},set tag(d){this.path.original=d},get blockParams(){return this.params.map(d=>d.name)},set blockParams(d){this.params=d.map(m=>f.var({name:m,loc:z.synthetic(m)}))},get selfClosing(){return h},set selfClosing(d){h=d,this.closeTag=d?null:z.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:r,loc:s}){return{type:"ElementModifierStatement",path:t,params:e,hash:r,loc:s}}attr({name:t,value:e,loc:r}){return{type:"AttrNode",name:t,value:e,loc:r}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:r,loc:s}){return{type:"SubExpression",path:t,params:e,hash:r,loc:s}}path({head:t,tail:e,loc:r}){return function({head:s,tail:n,loc:a}){const i={type:"PathExpression",head:s,tail:n,get original(){return[this.head.original,...this.tail].join(".")},set original(o){let[l,...c]=qe(o.split("."));this.head=An.head(l,this.head.loc),this.tail=c},loc:a};return Object.defineProperty(i,"parts",{enumerable:!1,get(){q("The parts property on path nodes is deprecated, use head and tail instead");let o=qe(this.original.split("."));return o[0]==="this"?o.shift():o[0].startsWith("@")&&(o[0]=o[0].slice(1)),Object.freeze(o)},set(o){q("The parts property on mustache nodes is deprecated, use head and tail instead");let l=[...o];l[0]==="this"||l[0]?.startsWith("@")||(this.head.type==="ThisHead"?l.unshift("this"):this.head.type==="AtHead"&&(l[0]=`@${l[0]}`)),this.original=l.join(".")}}),Object.defineProperty(i,"this",{enumerable:!1,get(){return q("The this property on path nodes is deprecated, use head.type instead"),this.head.type==="ThisHead"}}),Object.defineProperty(i,"data",{enumerable:!1,get(){return q("The data property on path nodes is deprecated, use head.type instead"),this.head.type==="AtHead"}}),i}({head:t,tail:e,loc:r})}head({original:t,loc:e}){return t==="this"?this.this({loc:e}):t[0]==="@"?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:t,loc:e}){let r="";const s={type:"AtHead",get name(){return r},set name(n){w(n[0]==="@","call builders.at() with a string that starts with '@'"),w(n.indexOf(".")===-1,"builder.at() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}var({name:t,loc:e}){let r="";const s={type:"VarHead",get name(){return r},set name(n){w(n!=="this","You called builders.var() with 'this'. Call builders.this instead"),w(n[0]!=="@",`You called builders.var() with '${t}'. Call builders.at('${t}') instead`),w(n.indexOf(".")===-1,"builder.var() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:r}){return{type:"HashPair",key:t,value:e,loc:r}}literal({type:t,value:e,loc:r}){return function({type:s,value:n,loc:a}){const i={type:s,value:n,loc:a};return Object.defineProperty(i,"original",{enumerable:!1,get(){return q("The original property on literal nodes is deprecated, use value instead"),this.value},set(o){q("The original property on literal nodes is deprecated, use value instead"),this.value=o}}),i}({type:t,value:e,loc:r})}};let Qi=class{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(e,r=new sr(ln),s="precompile"){this.source=e,this.lines=e.source.split(/\r\n?|\n/u),this.tokenizer=new on(this,r,s)}offset(){let{line:e,column:r}=this.tokenizer;return this.source.offsetFor(e,r)}pos({line:e,column:r}){return this.source.offsetFor(e,r)}finish(e){return ie({},e,{loc:e.start.until(this.offset())})}get currentAttr(){return ut(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return w(e&&(e.type==="StartTag"||e.type==="EndTag"),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return w(e&&e.type==="StartTag","expected start tag"),e}get currentEndTag(){let e=this.currentNode;return w(e&&e.type==="EndTag","expected end tag"),e}get currentComment(){let e=this.currentNode;return w(e&&e.type==="CommentStatement","expected a comment"),e}get currentData(){let e=this.currentNode;return w(e&&e.type==="TextNode","expected a text node"),e}acceptNode(e){return this[e.type](e)}currentElement(){return rt(qe(this.elementStack))}sourceForNode(e,r){let s,n,a,i=e.loc.start.line-1,o=i-1,l=e.loc.start.column,c=[];for(r?(n=r.loc.end.line-1,a=r.loc.end.column):(n=e.loc.end.line-1,a=e.loc.end.column);o<n;)o++,s=nr(this.lines[o]),o===i?i===n?c.push(s.slice(l,a)):c.push(s.slice(l)):o===n?c.push(s.slice(0,a)):c.push(s);return c.join(`
`)}};const Os="beforeAttributeName";let Zi=class extends Qi{pendingError=null;parse(e,r){let s=f.template({body:[],blockParams:r,loc:this.source.spanFor(e.loc)}),n=this.parseProgram(s,e);return this.pendingError?.eof(n.loc.getEnd()),n}Program(e,r){w(Array.isArray(r),"[BUG] Program in parser unexpectedly called without block params");let s=f.blockItself({body:[],params:r,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(s,e)}parseProgram(e,r){if(r.body.length===0)return e;let s;try{this.elementStack.push(e);for(let n of r.body)this.acceptNode(n)}finally{s=this.elementStack.pop()}if(e!==s){if(s?.type==="ElementNode")throw p(`Unclosed element \`${s.tag}\``,s.loc);w(s!==void 0,"[BUG] empty parser elementStack"),w(!1,`[BUG] mismatched parser elementStack node: ${e.type}`)}return e}BlockStatement(e){if(this.tokenizer.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));if(this.tokenizer.state!=="data"&&this.tokenizer.state!=="beforeData")throw p("A block may only be used inside an HTML element or another block.",this.source.spanFor(e.loc));const{path:r,params:s,hash:n}=gr(this,e),a=this.source.spanFor(e.loc);let i=[];if(e.program.blockParams?.length){let h=n.loc.collapse("end");h=e.program.loc?h.withEnd(this.source.spanFor(e.program.loc).getStart()):e.program.body[0]?h.withEnd(this.source.spanFor(e.program.body[0].loc).getStart()):h.withEnd(a.getEnd());const d=h.asString();let m=d.indexOf("|")+1;const g=d.indexOf("|",m);for(const v of e.program.blockParams){let F,ee;F=m>=g?-1:d.indexOf(v,m),F===-1||F+v.length>g?(m=g,ee=this.source.spanFor(Ge)):(m=F,ee=h.sliceStartChars({skipStart:m,chars:v.length}),m+=v.length),i.push(f.var({name:v,loc:ee}))}}e.program.loc||(e.program.loc=Ge),e.inverse&&!e.inverse.loc&&(e.inverse.loc=Ge);const o=this.Program(e.program,i),l=e.inverse?this.Program(e.inverse,[]):null,c=f.block({path:r,params:s,hash:n,defaultBlock:o,elseBlock:l,loc:this.source.spanFor(e.loc),openStrip:e.openStrip,inverseStrip:e.inverseStrip,closeStrip:e.closeStrip});je(this.currentElement(),c)}MustacheStatement(e){this.pendingError?.mustache(this.source.spanFor(e.loc));const{tokenizer:r}=this;if(r.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));let s;const{escaped:n,loc:a,strip:i}=e;if("original"in e.path&&e.path.original==="...attributes")throw p("Illegal use of ...attributes",this.source.spanFor(e.loc));if(Sn(e.path))s=f.mustache({path:this.acceptNode(e.path),params:[],hash:f.hash({pairs:[],loc:this.source.spanFor(e.path.loc).collapse("end")}),trusting:!n,loc:this.source.spanFor(a),strip:i});else{const{path:o,params:l,hash:c}=gr(this,e);s=f.mustache({path:o,params:l,hash:c,trusting:!n,loc:this.source.spanFor(a),strip:i})}switch(r.state){case"tagOpen":case"tagName":throw p("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":kr(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),kr(this.currentStartTag,s),r.transitionTo(Os);break;case"afterAttributeValueQuoted":kr(this.currentStartTag,s),r.transitionTo(Os);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),r.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:je(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(e){this.finalizeTextPart();const r=this.currentAttr;r.isDynamic=!0,r.parts.push(e)}finalizeTextPart(){const e=this.currentAttr.currentPart;e!==null&&(this.currentAttr.parts.push(e),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(e){(function(r,s){let n=s.loc.start.line,a=s.loc.start.column;const i=function(o,l){if(l==="")return{lines:o.split(`
`).length-1,columns:0};const[c]=o.split(l),h=c.split(/\n/u),d=h.length-1;return{lines:d,columns:nr(h[d]).length}}(s.original,s.value);n+=i.lines,i.lines?a=i.columns:a+=i.columns,r.line=n,r.column=a})(this.tokenizer,e),this.tokenizer.tokenizePart(e.value),this.tokenizer.flushData()}CommentStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return this.appendToCommentData(this.sourceForNode(e)),null;const{value:s,loc:n}=e,a=f.mustacheComment({value:s,loc:this.source.spanFor(n)});switch(r.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(a);break;case"beforeData":case"data":je(this.currentElement(),a);break;default:throw p(`Using a Handlebars comment when in the \`${r.state}\` state is not supported`,this.source.spanFor(e.loc))}return a}PartialStatement(e){throw p("Handlebars partials are not supported",this.source.spanFor(e.loc))}PartialBlockStatement(e){throw p("Handlebars partial blocks are not supported",this.source.spanFor(e.loc))}Decorator(e){throw p("Handlebars decorators are not supported",this.source.spanFor(e.loc))}DecoratorBlock(e){throw p("Handlebars decorator blocks are not supported",this.source.spanFor(e.loc))}SubExpression(e){const{path:r,params:s,hash:n}=gr(this,e);return f.sexpr({path:r,params:s,hash:n,loc:this.source.spanFor(e.loc)})}PathExpression(e){const{original:r}=e;let s;if(r.indexOf("/")!==-1){if(r.slice(0,2)==="./")throw p('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(e.loc));if(r.slice(0,3)==="../")throw p('Changing context using "../" is not supported in Glimmer',this.source.spanFor(e.loc));if(r.indexOf(".")!==-1)throw p("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(e.loc));s=[e.parts.join("/")]}else{if(r===".")throw p("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(e.loc));s=e.parts}let n,a=!1;if(/^this(?:\..+)?$/u.test(r)&&(a=!0),a)n=f.this({loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+4}})});else if(e.data){const i=s.shift();if(i===void 0)throw p("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(e.loc));n=f.atName({name:`@${i}`,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length+1}})})}else{const i=s.shift();if(i===void 0)throw p("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(e.loc));n=f.var({name:i,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length}})})}return f.path({head:n,tail:s,loc:this.source.spanFor(e.loc)})}Hash(e){const r=e.pairs.map(s=>f.pair({key:s.key,value:this.acceptNode(s.value),loc:this.source.spanFor(s.loc)}));return f.hash({pairs:r,loc:this.source.spanFor(e.loc)})}StringLiteral(e){return f.literal({type:"StringLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}BooleanLiteral(e){return f.literal({type:"BooleanLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}NumberLiteral(e){return f.literal({type:"NumberLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}UndefinedLiteral(e){return f.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(e.loc)})}NullLiteral(e){return f.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(e.loc)})}};function gr(t,e){let r;switch(e.path.type){case"PathExpression":r=t.PathExpression(e.path);break;case"SubExpression":r=t.SubExpression(e.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let a;throw a=e.path.type==="BooleanLiteral"?e.path.original.toString():e.path.type==="StringLiteral"?`"${e.path.original}"`:e.path.type==="NullLiteral"?"null":e.path.type==="NumberLiteral"?e.path.value.toString():"undefined",p(`${e.path.type} "${e.path.type==="StringLiteral"?e.path.original:a}" cannot be called as a sub-expression, replace (${a}) with ${a}`,t.source.spanFor(e.path.loc))}}const s=e.params?e.params.map(a=>t.acceptNode(a)):[],n=_(s)?rt(s).loc:r.loc;return{path:r,params:s,hash:e.hash?t.Hash(e.hash):f.hash({pairs:[],loc:t.source.spanFor(n).collapse("end")})}}function kr(t,e){const{path:r,params:s,hash:n,loc:a}=e;if(Sn(r)){const o=`{{${function(l){return l.type==="UndefinedLiteral"?"undefined":JSON.stringify(l.value)}(r)}}}`;throw p(`In <${t.name} ... ${o} ..., ${o} is not a valid modifier`,e.loc)}const i=f.elementModifier({path:r,params:s,hash:n,loc:a});t.modifiers.push(i)}function Fe(t){return/[\t\n\f ]/u.test(t)}let eo=class extends Zi{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(e){this.currentComment.value+=e}finishComment(){je(this.currentElement(),f.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(e){this.currentData.chars+=e}finishData(){je(this.currentElement(),f.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let e=this.finish(this.currentTag);if(e.type==="StartTag"){if(this.finishStartTag(),e.name===":")throw p("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(Br.has(e.name)||e.selfClosing)&&this.finishEndTag(!0)}else e.type==="EndTag"&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:r,nameEnd:s}=this.currentStartTag;w(e!=="","tag name cannot be empty"),w(r!==null,"nameStart unexpectedly null"),w(s!==null,"nameEnd unexpectedly null");let n=r.until(s),[a,...i]=qe(e.split(".")),o=f.path({head:f.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:l,modifiers:c,comments:h,params:d,selfClosing:m,loc:g}=this.finish(this.currentStartTag),v=f.element({path:o,selfClosing:m,attributes:l,modifiers:c,comments:h,params:d,children:[],openTag:g,closeTag:m?null:z.broken(),loc:g});this.elementStack.push(v)}finishEndTag(e){let{start:r}=this.currentTag,s=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(s,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?w(n.closeTag===null,"element.closeTag unexpectedly present"):n.closeTag=r.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),je(a,f.element(n))}markTagAsSelfClosing(){let e=this.currentTag;if(e.type!=="StartTag")throw p("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:e.start.toJSON(),end:this.offset().toJSON()}));e.selfClosing=!0}appendToTagName(e){let r=this.currentTag;if(r.name+=e,r.type==="StartTag"){let s=this.offset();r.nameStart===null&&(w(r.nameEnd===null,"nameStart and nameEnd must both be null"),r.nameStart=s.move(-1)),r.nameEnd=s}}beginAttribute(){let e=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:e,valueSpan:e.collapsed()}}appendToAttributeName(e){this.currentAttr.name+=e,this.currentAttr.name==="as"&&this.parsePossibleBlockParams()}beginAttributeValue(e){this.currentAttr.isQuoted=e,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(e){let r=this.currentAttr.parts,s=r[r.length-1],n=this.currentAttr.currentPart;if(n)n.chars+=e,n.loc=n.loc.withEnd(this.offset());else{let a=this.offset();a=e===`
`?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():a.move(-1),this.currentAttr.currentPart=f.text({chars:e,loc:a.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let e=this.currentTag,r=this.offset();if(e.type==="EndTag")throw p("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:e.start.toJSON(),end:r.toJSON()}));let{name:s,parts:n,start:a,isQuoted:i,isDynamic:o,valueSpan:l}=this.currentAttr;if(s.startsWith("|")&&n.length===0&&!i&&!o)throw p("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",a.until(a.move(s.length)));let c=this.assembleAttributeValue(n,i,o,a.until(r));c.loc=l.withEnd(r);let h=f.attr({name:s,value:c,loc:a.until(r)});this.currentStartTag.attributes.push(h)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;w(this.tokenizer.state==="attributeName","must be in TokenizerState.attributeName");const r=this.currentStartTag,s=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:o=>{if(w(n.state==="PossibleAs","bug in block params parser"),Fe(o))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if(o==="|")throw p('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',s.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:o=>{w(n.state==="BeforeStartPipe","bug in block params parser"),Fe(o)?this.tokenizer.consume():o==="|"?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:o=>{if(w(n.state==="BeforeBlockParamName","bug in block params parser"),Fe(o))this.tokenizer.consume();else if(o==="")n={state:"Done"},this.pendingError={mustache(l){throw p("Invalid block parameters syntax: mustaches cannot be used inside parameters list",l)},eof(l){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(l))}};else if(o==="|"){if(r.params.length===0)throw p("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",s.start.until(this.offset().move(1)));n={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(o===">"||o==="/")throw p('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n={state:"BlockParamName",name:o,start:this.offset()},this.tokenizer.consume()}},BlockParamName:o=>{if(w(n.state==="BlockParamName","bug in block params parser"),o==="")n={state:"Done"},this.pendingError={mustache(l){throw p("Invalid block parameters syntax: mustaches cannot be used inside parameters list",l)},eof(l){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(l))}};else if(o==="|"||Fe(o)){let l=n.start.until(this.offset());if(n.name==="this"||e.test(n.name))throw p(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,l);r.params.push(f.var({name:n.name,loc:l})),n=o==="|"?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(o===">"||o==="/")throw p('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n.name+=o,this.tokenizer.consume()}},AfterEndPipe:o=>{w(n.state==="AfterEndPipe","bug in block params parser"),Fe(o)?this.tokenizer.consume():o===""?(n={state:"Done"},this.pendingError={mustache(l){throw p("Invalid block parameters syntax: modifiers cannot follow parameters list",l)},eof(l){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(l))}}):o===">"||o==="/"?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:o=>{if(w(n.state==="Error","bug in block params parser"),o===""||o==="/"||o===">"||Fe(o))throw p(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{w(!1,"This should never be called")}};let i;do i=this.tokenizer.peek(),a[n.state](i);while(n.state!=="Done"&&i!=="");w(n.state==="Done","bug in block params parser")}reportSyntaxError(e){throw p(e,this.offset().collapsed())}assembleConcatenatedValue(e){for(const n of e)if(n.type!=="MustacheStatement"&&n.type!=="TextNode")throw p(`Unsupported node in quoted attribute value: ${n.type}`,n.loc);Ye(e,"the concatenation parts of an element should not be empty");let r=Yr(e),s=rt(e);return f.concat({parts:e,loc:this.source.spanFor(r.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(e,r,s){if(Br.has(e.name)&&!s)throw p(`<${e.name}> elements do not need end tags. You should remove it`,e.loc);if(r.tag===void 0)throw p(`Closing tag </${e.name}> without an open tag`,e.loc);if(r.tag!==e.name)throw p(`Closing tag </${e.name}> did not match last open tag <${r.tag}> (on line ${r.loc.startPosition.line})`,e.loc)}assembleAttributeValue(e,r,s,n){if(s){if(r)return this.assembleConcatenatedValue(e);{Ye(e);const[a,i]=e;if(i===void 0||i.type==="TextNode"&&i.chars==="/")return a;throw p("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return _(e)?e[0]:f.text({chars:"",loc:n})}};const to={parse:Pn,builders:An,print:zi,traverse:vn,Walker:Xi};let ro=class extends sr{constructor(){super({})}parse(){}};function Pn(t,e={}){let r,s,n,a=e.mode||"precompile";typeof t=="string"?(r=new Re(t,e.meta?.moduleName),s=a==="codemod"?Ut(t,e.parseOptions):Gt(t,e.parseOptions)):t instanceof Re?(r=t,s=a==="codemod"?Ut(t.source,e.parseOptions):Gt(t.source,e.parseOptions)):(r=new Re("",e.meta?.moduleName),s=t),a==="codemod"&&(n=new ro);let i=z.forCharPositions(r,0,r.source.length);s.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let o=new eo(r,n,a).parse(s,e.locals??[]);if(e?.plugins?.ast)for(const l of e.plugins.ast)vn(o,l(ie({},e,{syntax:to},{plugins:void 0})).visitor);return o}function b(t){if(t!==void 0){const e=t;return{fields:()=>class{type;constructor(r){this.type=e,ie(this,r)}}}}return{fields:()=>class{constructor(e){ie(this,e)}}}}let st=class Mr extends b().fields(){static empty(e){return new Mr({loc:e,positional:jt.empty(e),named:nt.empty(e)})}static named(e){return new Mr({loc:e.loc,positional:jt.empty(e.loc.collapse("end")),named:e})}nth(e){return this.positional.nth(e)}get(e){return this.named.get(e)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}},jt=class Cn extends b().fields(){static empty(e){return new Cn({loc:e,exprs:[]})}get size(){return this.exprs.length}nth(e){return this.exprs[e]||null}isEmpty(){return this.exprs.length===0}},nt=class Nn extends b().fields(){static empty(e){return new Nn({loc:e,entries:[]})}get size(){return this.entries.length}get(e){let r=this.entries.filter(s=>s.name.chars===e)[0];return r?r.value:null}isEmpty(){return this.entries.length===0}},rs=class{loc;name;value;constructor(e){this.loc=e.name.loc.extend(e.value.loc),this.name=e.name,this.value=e.value}},xn=class extends b("HtmlAttr").fields(){},Tn=class extends b("SplatAttr").fields(){},Bn=class extends b().fields(){toNamedArgument(){return new rs({name:this.name,value:this.value})}},Ln=class extends b("ElementModifier").fields(){},$n=class extends b("GlimmerComment").fields(){},Hn=class extends b("HtmlText").fields(){},On=class extends b("HtmlComment").fields(){},In=class extends b("AppendContent").fields(){get callee(){return this.value.type==="Call"?this.value.callee:this.value}get args(){return this.value.type==="Call"?this.value.args:st.empty(this.value.loc.collapse("end"))}},Mn=class extends b("InvokeBlock").fields(){},Dt=class extends b("InvokeComponent").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return st.named(new nt({loc:Pe.range(e,this.callee.loc.collapse("end")),entries:e}))}},Fn=class extends b("SimpleElement").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return st.named(new nt({loc:Pe.range(e,this.tag.loc.collapse("end")),entries:e}))}},Dn=class extends b("Literal").fields(){toSlice(){return new Z({loc:this.loc,chars:this.value})}},_n=class extends b("Path").fields(){},Vn=class extends b("Keyword").fields(){},zn=class extends b("Call").fields(){},Un=class extends b("Interpolate").fields(){},Gn=class extends b().fields(){},Rn=class extends b().fields(){},ss=class extends b().fields(){get(e){return this.blocks.filter(r=>r.name.chars===e)[0]||null}},Je=class extends b().fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return st.named(new nt({loc:Pe.range(e,this.name.loc.collapse("end")),entries:e}))}},jn=class extends b("This").fields(){},Jn=class extends b("Arg").fields(){},Kn=class extends b("Local").fields(){},Wn=class extends b("Free").fields(){};const W={resolution:()=>u.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},so={...W,isAngleBracket:!0};let le=class Fr{static namespaced(e,r=!1){return new Fr([e],r)}static append(){return new Fr([ne.Component,ne.Helper])}static trustingAppend(){return this.namespaced(ne.Helper)}constructor(e,r=!1){this.namespaces=e,this.isAngleBracket=r}resolution(){if(this.namespaces.length!==1)return u.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case ne.Helper:return u.GetFreeAsHelperHead;case ne.Modifier:return u.GetFreeAsModifierHead;case ne.Component:return u.GetFreeAsComponentHead}}serialize(){return this.namespaces.length===1?this.namespaces[0]:"ComponentOrHelper"}},ne=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const ns=ne.Helper,Yn=ne.Modifier,as=ne.Component;var Ce=Object.freeze({__proto__:null,AppendContent:In,ArgReference:Jn,Args:st,Block:Rn,COMPONENT_NAMESPACE:as,CallExpression:zn,ComponentArg:Bn,ElementModifier:Ln,FreeVarNamespace:ne,FreeVarReference:Wn,GlimmerComment:$n,HELPER_NAMESPACE:ns,HTML_RESOLUTION:so,HtmlAttr:xn,HtmlComment:On,HtmlText:Hn,InterpolateExpression:Un,InvokeBlock:Mn,InvokeComponent:Dt,KeywordExpression:Vn,LiteralExpression:Dn,LocalVarReference:Kn,LooseModeResolution:le,MODIFIER_NAMESPACE:Yn,NamedArgument:rs,NamedArguments:nt,NamedBlock:Je,NamedBlocks:ss,PathExpression:_n,PositionalArguments:jt,STRICT_RESOLUTION:W,SimpleElement:Fn,SplatAttr:Tn,Template:Gn,ThisReference:jn,isLiteral:function(t,e){return t.type==="Literal"&&(e===void 0||(e==="null"?t.value===null:typeof t.value===e))},isStrictResolution:function(t){return t===W},loadResolution:function(t){return t==="Strict"?W:t==="ComponentOrHelper"?le.append():le.namespaced(t)},node:b});let is=class{static top(e,r,s){return new no(e,r,s)}child(e){let r=e.map(s=>this.allocate(s));return new ao(this,e,r)}},no=class extends is{constructor(e,r,s){super(),this.templateLocals=e,this.keywords=r,this.options=s}symbols=[];upvars=[];size=1;named=oe();blocks=oe();usedTemplateLocals=[];#e=!1;hasLexical(e){return this.options.lexicalScope(e)}hasKeyword(e){return this.keywords.includes(e)}getKeyword(e){return this.allocateFree(e,W)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#e=!0}get hasEval(){return this.#e}has(e){return this.templateLocals.includes(e)}get(e){let r=this.usedTemplateLocals.indexOf(e);return r!==-1||(r=this.usedTemplateLocals.length,this.usedTemplateLocals.push(e)),[r,!0]}getLocalsMap(){return oe()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(e,r){r.resolution()===u.GetFreeAsComponentHead&&r.isAngleBracket&&(e=this.options.customizeComponentName(e));let s=this.upvars.indexOf(e);return s!==-1||(s=this.upvars.length,this.upvars.push(e)),s}allocateNamed(e){let r=this.named[e];return r||(r=this.named[e]=this.allocate(e)),r}allocateBlock(e){e==="inverse"&&(e="else");let r=this.blocks[e];return r||(r=this.blocks[e]=this.allocate(`&${e}`)),r}allocate(e){return this.symbols.push(e),this.size++}},ao=class extends is{constructor(e,r,s){super(),this.parent=e,this.symbols=r,this.slots=s}get locals(){return this.symbols}hasLexical(e){return this.parent.hasLexical(e)}getKeyword(e){return this.parent.getKeyword(e)}hasKeyword(e){return this.parent.hasKeyword(e)}has(e){return this.symbols.indexOf(e)!==-1||this.parent.has(e)}get(e){let r=this.#e(e);return r?[r,!1]:this.parent.get(e)}#e(e){let r=this.symbols.indexOf(e);return r===-1?null:nr(this.slots[r])}getLocalsMap(){let e=this.parent.getLocalsMap();return this.symbols.forEach(r=>e[r]=this.get(r)[0]),e}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(e,r){return this.parent.allocateFree(e,r)}allocateNamed(e){return this.parent.allocateNamed(e)}allocateBlock(e){return this.parent.allocateBlock(e)}allocate(e){return this.parent.allocate(e)}},qn=class{template(e,r,s){return new Gn({table:e,body:r,loc:s})}block(e,r,s){return new Rn({scope:e,body:r,loc:s})}namedBlock(e,r,s){return new Je({name:e,block:r,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(e,r,s){return new Is({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(e,r,s)}slice(e,r){return new Z({loc:r,chars:e})}args(e,r,s){return new st({loc:s,positional:e,named:r})}positional(e,r){return new jt({loc:r,exprs:e})}namedArgument(e,r){return new rs({name:e,value:r})}named(e,r){return new nt({loc:r,entries:e})}attr({name:e,value:r,trusting:s},n){return new xn({loc:n,name:e,value:r,trusting:s})}splatAttr(e,r){return new Tn({symbol:e,loc:r})}arg({name:e,value:r,trusting:s},n){return new Bn({name:e,value:r,trusting:s,loc:n})}path(e,r,s){return new _n({loc:s,ref:e,tail:r})}keyword(e,r,s){return new Vn({loc:s,name:e,symbol:r})}self(e){return new jn({loc:e})}at(e,r,s){return w(e[0]==="@","call builders.at() with a string that starts with '@'"),new Jn({loc:s,name:new Z({loc:s,chars:e}),symbol:r})}freeVar({name:e,context:r,symbol:s,loc:n}){return w(e!=="this","You called builders.freeVar() with 'this'. Call builders.this instead"),w(e[0]!=="@",`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new Wn({name:e,resolution:r,symbol:s,loc:n})}localVar(e,r,s,n){return w(e!=="this","You called builders.var() with 'this'. Call builders.this instead"),w(e[0]!=="@",`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new Kn({loc:n,name:e,isTemplateLocal:s,symbol:r})}sexp(e,r){return new zn({loc:r,callee:e.callee,args:e.args})}interpolate(e,r){return Ye(e),new Un({loc:r,parts:e})}literal(e,r){return new Dn({loc:r,value:e})}append({table:e,trusting:r,value:s},n){return new In({table:e,trusting:r,value:s,loc:n})}modifier({callee:e,args:r},s){return new Ln({loc:s,callee:e,args:r})}namedBlocks(e,r){return new ss({loc:r,blocks:e})}blockStatement({program:e,inverse:r=null,...s},n){let a=e.loc,i=[this.namedBlock(Z.synthetic("default"),e,e.loc)];return r&&(a=a.extend(r.loc),i.push(this.namedBlock(Z.synthetic("else"),r,r.loc))),new Mn({loc:n,blocks:this.namedBlocks(i,a),callee:s.callee,args:s.args})}element(e){return new Is(e)}},Is=class{builder;constructor(e){this.base=e,this.builder=new qn}simple(e,r,s){return new Fn(ie({tag:e,body:r,componentArgs:[],loc:s},this.base))}named(e,r,s){return new Je(ie({name:e,block:r,componentArgs:[],loc:s},this.base))}selfClosingComponent(e,r){return new Dt(ie({loc:r,callee:e,blocks:new ss({blocks:[],loc:r.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(e,r,s,n){let a=this.builder.block(s,r,n),i=this.builder.namedBlock(Z.synthetic("default"),a,n);return new Dt(ie({loc:n,callee:e,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(e,r,s){return new Dt(ie({loc:s,callee:e,blocks:this.builder.namedBlocks(r,Pe.range(r))},this.base))}};function io(t){return Nt(t)?le.namespaced(ns):null}function oo(t){return Nt(t)?le.namespaced(Yn):null}function lo(t){return Nt(t)?le.namespaced(as):null}function co(t){return Xn(t)?le.namespaced(as,!0):null}function uo(t){return Nt(t)?le.namespaced(ns):null}function ho(t){let e=Nt(t),r=t.trusting;return e?r?le.trustingAppend():le.append():null}function Nt(t){return Xn(t.path)}function Xn(t){return t.type==="PathExpression"&&t.head.type==="VarHead"&&t.tail.length===0}function po(t,e={lexicalScope:()=>!1}){let r=Pn(t,e),s={strictMode:!1,...e,locals:r.blockParams,keywords:e.keywords??[]},n=is.top(s.locals,s.keywords,{customizeComponentName:e.customizeComponentName??(l=>l),lexicalScope:e.lexicalScope}),a=new mo(t,s,n),i=new _r(a);return[new bo(a.loc(r.loc),r.body.map(l=>i.normalize(l)),a).assertTemplate(n),n.getUsedTemplateLocals()]}let mo=class Qn{builder;constructor(e,r,s){this.source=e,this.options=r,this.table=s,this.builder=new qn}get strict(){return this.options.strictMode||!1}loc(e){return this.source.spanFor(e)}resolutionFor(e,r){if(this.strict)return{result:W};if(this.isFreeVar(e)){let s=r(e);return s===null?{result:"error",path:ea(e),head:ta(e)}:{result:s}}return{result:W}}isLexicalVar(e){return this.table.hasLexical(e)}isKeyword(e){return this.strict&&!this.table.hasLexical(e)&&this.table.hasKeyword(e)}isFreeVar(e){return e.type==="PathExpression"?e.head.type==="VarHead"&&!this.table.has(e.head.name):e.path.type==="PathExpression"&&this.isFreeVar(e.path)}hasBinding(e){return this.table.has(e)||this.table.hasLexical(e)}child(e){return new Qn(this.source,this.options,this.table.child(e))}customizeComponentName(e){return this.options.customizeComponentName?this.options.customizeComponentName(e):e}},Dr=class{constructor(e){this.block=e}normalize(e,r){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return w(r,"[BUG] resolution is required"),this.path(e,r);case"SubExpression":{bt(e.path)&&gt(e.path,e.loc);let s=this.block.resolutionFor(e,io);if(s.result==="error")throw p(`You attempted to invoke a path (\`${s.path}\`) but ${s.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,s.result),this.block.loc(e.loc))}}}path(e,r){let s=this.block.loc(e.loc);if(e.head.type==="VarHead"&&e.tail.length===0&&this.block.isKeyword(e.head.name))return this.block.builder.keyword(e.head.name,this.block.table.getKeyword(e.head.name),s);let n=[],a=this.block.loc(e.head.loc);for(let i of e.tail)a=a.sliceStartChars({chars:i.length,skipStart:1}),n.push(new Z({loc:a,chars:i}));return this.block.builder.path(this.ref(e.head,r),n,s)}callParts(e,r){let{path:s,params:n,hash:a,loc:i}=e,o=this.normalize(s,r),l=n.map(v=>this.normalize(v,W)),c=Pe.range(l,o.loc.collapse("end")),h=this.block.loc(a.loc),d=Pe.range([c,h]),m=this.block.builder.positional(n.map(v=>this.normalize(v,W)),c),g=this.block.builder.named(a.pairs.map(v=>this.namedArgument(v)),this.block.loc(a.loc));switch(o.type){case"Literal":throw p(`Invalid invocation of a literal value (\`${o.value}\`)`,i);case"Interpolate":throw p("Invalid invocation of a interpolated string",i)}return{callee:o,args:this.block.builder.args(m,g,d)}}namedArgument(e){let r=this.block.loc(e.loc).sliceStartChars({chars:e.key.length});return this.block.builder.namedArgument(new Z({chars:e.key,loc:r}),this.normalize(e.value,W))}ref(e,r){let{block:s}=this,{builder:n,table:a}=s,i=s.loc(e.loc);switch(e.type){case"ThisHead":return n.self(i);case"AtHead":{let o=a.allocateNamed(e.name);return n.at(e.name,o,i)}case"VarHead":if(s.hasBinding(e.name)){let[o,l]=a.get(e.name);return s.builder.localVar(e.name,o,l,i)}{let o=s.strict?W:r,l=s.table.allocateFree(e.name,o);return s.builder.freeVar({name:e.name,context:o,symbol:l,loc:i})}}}},_r=class Zn{constructor(e){this.block=e}normalize(e){switch(e.type){case"BlockStatement":return this.BlockStatement(e);case"ElementNode":return new fo(this.block).ElementNode(e);case"MustacheStatement":return this.MustacheStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":{let r=this.block.loc(e.loc);return new On({loc:r,text:r.slice({skipStart:4,skipEnd:3}).toSlice(e.value)})}case"TextNode":return new Hn({loc:this.block.loc(e.loc),chars:e.chars})}}MustacheCommentStatement(e){let r,s=this.block.loc(e.loc);return r=s.asString().slice(0,5)==="{{!--"?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new $n({loc:s,text:r.toSlice(e.value)})}MustacheStatement(e){let r,{path:s,params:n,hash:a,trusting:i}=e,o=this.block.loc(e.loc);if(bt(s))n.length===0&&a.pairs.length===0?r=this.expr.normalize(s):gt(s,o);else{let l=this.block.resolutionFor(e,ho);if(l.result==="error")throw p(`You attempted to render a path (\`{{${l.path}}}\`), but ${l.head} was not in scope`,o);let c=this.expr.callParts({path:s,params:n,hash:a,loc:o},l.result);r=c.args.isEmpty()?c.callee:this.block.builder.sexp(c,o)}return this.block.builder.append({table:this.block.table,trusting:i,value:r},o)}BlockStatement(e){let{program:r,inverse:s}=e,n=this.block.loc(e.loc);bt(e.path)&&gt(e.path,n);let a=this.block.resolutionFor(e,lo);if(a.result==="error")throw p(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(e,a.result);return this.block.builder.blockStatement(ie({symbols:this.block.table,program:this.Block(r),inverse:s?this.Block(s):null},i),n)}Block({body:e,loc:r,blockParams:s}){let n=this.block.child(s),a=new Zn(n);return new go(this.block.loc(r),e.map(i=>a.normalize(i)),this.block).assertBlock(n.table)}get expr(){return new Dr(this.block)}},fo=class{constructor(e){this.ctx=e}ElementNode(e){let{tag:r,selfClosing:s,comments:n}=e,a=this.ctx.loc(e.loc),[i,...o]=qe(r.split(".")),l=this.classifyTag(i,o,e.loc),c=e.attributes.filter(N=>N.name[0]!=="@").map(N=>this.attr(N)),h=e.attributes.filter(N=>N.name[0]==="@").map(N=>this.arg(N)),d=e.modifiers.map(N=>this.modifier(N)),m=this.ctx.child(e.blockParams),g=new _r(m),v=e.children.map(N=>g.normalize(N)),F=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:d,comments:n.map(N=>new _r(this.ctx).MustacheCommentStatement(N))}),ee=new ko(F,a,v,this.ctx),it=this.ctx.loc(e.loc).sliceStartChars({chars:r.length,skipStart:1});if(l==="ElementHead")return r[0]===":"?ee.assertNamedBlock(it.slice({skipStart:1}).toSlice(r.slice(1)),m.table):ee.assertElement(it.toSlice(r),e.blockParams.length>0);if(e.selfClosing)return F.selfClosingComponent(l,a);{let N=ee.assertComponent(r,m.table,e.blockParams.length>0);return F.componentWithNamedBlocks(l,N,a)}}modifier(e){bt(e.path)&&gt(e.path,e.loc);let r=this.ctx.resolutionFor(e,oo);if(r.result==="error")throw p(`You attempted to invoke a path (\`{{${r.path}}}\`) as a modifier, but ${r.head} was not in scope`,e.loc);let s=this.expr.callParts(e,r.result);return this.ctx.builder.modifier(s,this.ctx.loc(e.loc))}mustacheAttr(e){let{path:r,params:s,hash:n,loc:a}=e;if(bt(r)){if(s.length===0&&n.pairs.length===0)return this.expr.normalize(r);gt(r,a)}let i=this.ctx.resolutionFor(e,uo);if(i.result==="error")throw p(`You attempted to render a path (\`{{${i.path}}}\`), but ${i.head} was not in scope`,e.loc);let o=this.ctx.builder.sexp(this.expr.callParts(e,i.result),this.ctx.loc(e.loc));return o.args.isEmpty()?o.callee:o}attrPart(e){switch(e.type){case"MustacheStatement":return{expr:this.mustacheAttr(e),trusting:e.trusting};case"TextNode":return{expr:this.ctx.builder.literal(e.chars,this.ctx.loc(e.loc)),trusting:!0}}}attrValue(e){if(e.type==="ConcatStatement"){let r=e.parts.map(s=>this.attrPart(s).expr);return{expr:this.ctx.builder.interpolate(r,this.ctx.loc(e.loc)),trusting:!1}}return this.attrPart(e)}attr(e){if(w(e.name[0]!=="@","An attr name must not start with `@`"),e.name==="...attributes")return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:s,value:n.expr,trusting:n.trusting},r)}checkArgCall(e){let{value:r}=e;if(r.type!=="MustacheStatement"||r.params.length!==0||r.hash.pairs.length!==0)return;let{path:s}=r;if(s.type!=="PathExpression"||s.tail.length>0)return;let n=this.ctx.resolutionFor(s,()=>null);if(n.result==="error"&&n.path!=="has-block")throw p(`You attempted to pass a path as argument (\`${e.name}={{${n.path}}}\`) but ${n.head} was not in scope. Try:
* \`${e.name}={{this.${n.path}}}\` if this is meant to be a property lookup, or
* \`${e.name}={{(${n.path})}}\` if this is meant to invoke the resolved helper, or
* \`${e.name}={{helper "${n.path}"}}\` if this is meant to pass the resolved helper by value`,e.loc)}arg(e){w(e.name[0]==="@","An arg name must start with `@`"),this.checkArgCall(e);let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.arg({name:s,value:n.expr,trusting:n.trusting},r)}classifyTag(e,r,s){let n=(a=e)[0]===a[0]?.toUpperCase()&&a[0]!==a[0]?.toLowerCase();var a;let i=e[0]==="@"||e==="this"||this.ctx.hasBinding(e);if(this.ctx.strict&&!i){if(n)throw p(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${e}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${e.toLowerCase()}>\``,s);return"ElementHead"}let o=i||n,l=s.sliceStartChars({skipStart:1,chars:e.length}),c=r.reduce((m,g)=>m+1+g.length,0),h=l.getEnd().move(c),d=l.withEnd(h);if(o){let m=f.path({head:f.head({original:e,loc:l}),tail:r,loc:d}),g=this.ctx.isLexicalVar(e)?{result:W}:this.ctx.resolutionFor(m,co);if(g.result==="error")throw p(`You attempted to invoke a path (\`<${g.path}>\`) but ${g.head} was not in scope`,s);return new Dr(this.ctx).normalize(m,g.result)}if(this.ctx.table.allocateFree(e,W),r.length>0)throw p(`You used ${e}.${r.join(".")} as a tag name, but ${e} is not in scope`,s);return"ElementHead"}get expr(){return new Dr(this.ctx)}},os=class{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(e,r,s){this.loc=e,this.children=r,this.block=s,this.namedBlocks=r.filter(n=>n instanceof Je),this.hasSemanticContent=!!r.filter(n=>{if(n instanceof Je)return!1;switch(n.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(n.chars);default:return!0}}).length,this.nonBlockChildren=r.filter(n=>!(n instanceof Je))}},bo=class extends os{assertTemplate(e){if(_(this.namedBlocks))throw p("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(e,this.nonBlockChildren,this.block.loc(this.loc))}},go=class extends os{assertBlock(e){if(_(this.namedBlocks))throw p("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(e,this.nonBlockChildren,this.loc)}},ko=class extends os{constructor(e,r,s,n){super(r,s,n),this.el=e}assertNamedBlock(e,r){if(this.el.base.selfClosing)throw p(`<:${e.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(_(this.namedBlocks))throw p(`Unexpected named block inside <:${e.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=e.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw p(`<:${e.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw p(`named block <:${e.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=Pe.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(e,this.block.builder.block(r,this.nonBlockChildren,n),this.loc)}assertElement(e,r){if(r)throw p(`Unexpected block params in <${e.chars}>: simple elements cannot have block params`,this.loc);if(_(this.namedBlocks)){let s=this.namedBlocks.map(n=>n.name);if(s.length===1)throw p(`Unexpected named block <:foo> inside <${e.chars}> HTML element`,this.loc);{let n=s.map(a=>`<:${a.chars}>`).join(", ");throw p(`Unexpected named blocks inside <${e.chars}> HTML element (${n})`,this.loc)}}return this.el.simple(e,this.nonBlockChildren,this.loc)}assertComponent(e,r,s){if(_(this.namedBlocks)&&this.hasSemanticContent)throw p(`Unexpected content inside <${e}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(_(this.namedBlocks)){if(s)throw p(`Unexpected block params list on <${e}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let n=new Set;for(let a of this.namedBlocks){let i=a.name.chars;if(n.has(i))throw p(`Component had two named blocks with the same name, \`<:${i}>\`. Only one block with a given name may be passed`,this.loc);if(i==="inverse"&&n.has("else")||i==="else"&&n.has("inverse"))throw p("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);n.add(i)}return this.namedBlocks}return[this.block.builder.namedBlock(Z.synthetic("default"),this.block.builder.block(r,this.nonBlockChildren,this.loc),this.loc)]}};function bt(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function gt(t,e){throw p(`Unexpected literal \`${t.type==="StringLiteral"?JSON.stringify(t.value):String(t.value)}\``,e)}function ea(t){return t.type!=="PathExpression"&&t.path.type==="PathExpression"?ea(t.path):new Xr({entityEncoding:"raw"}).print(t)}function ta(t){return t.type==="PathExpression"?t.head.original:t.path.type==="PathExpression"?ta(t.path):new Xr({entityEncoding:"raw"}).print(t)}const j={Component:0,Helper:1,Modifier:2};(function(t){return t[t.pc=0]="pc",t[t.ra=1]="ra",t[t.fp=2]="fp",t[t.sp=3]="sp",t})({});(function(t){return t[t.s0=4]="s0",t[t.s1=5]="s1",t})({});(function(t){return t[t.t0=6]="t0",t[t.t1=7]="t1",t})({});let x=function(t){return t.Block="Block",t.Call="Call",t.Element="Element",t.AppendPath="AppendPath",t.AppendExpr="AppendExpr",t.Literal="Literal",t.Modifier="Modifier",t.DynamicComponent="DynamicComponent",t.Comment="Comment",t.Splat="Splat",t.Keyword="Keyword",t}({}),X=function(t){return t.Local="Local",t.Free="Free",t.Arg="Arg",t.Block="Block",t.This="This",t}({});function ra(t){if(Array.isArray(t))return function(e){if(!Array.isArray(e))return!1;const r=e[0];if(typeof r=="number")switch(r){case M.Literal:case M.Get:case M.Concat:case M.HasBlock:case M.HasBlockParams:return!0;default:return!1}return r[0]==="("}(t)?_s(t):function(e){if(Array.isArray(e)&&typeof e[0]=="string")switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(t)?function(e){const r=e[0];switch(r[0]){case"(":{let s=null,n=null;return e.length===3?(s=de(e[1]),n=Ue(e[2])):e.length===2&&(Array.isArray(e[1])?s=de(e[1]):n=Ue(e[1])),{kind:x.Call,head:ct(r),params:s,hash:n,trusted:!1}}case"#":{const{head:s,params:n,hash:a,blocks:i,blockParams:o}=Ms(e);return{kind:x.Block,head:s,params:n,hash:a,blocks:i,blockParams:o}}case"!":{const s=e[0].slice(1),{params:n,hash:a,blocks:i,blockParams:o}=Ms(e);return{kind:x.Keyword,name:s,params:n,hash:a,blocks:i,blockParams:o}}case"<":{let s=oe(),n=[];return e.length===3?(s=Ds(e[1]),n=ht(e[2])):e.length===2&&(Array.isArray(e[1])?n=ht(e[1]):s=Ds(e[1])),{kind:x.Element,name:ut(wo(r),`BUG: expected ${r} to look like a tag name`),attrs:s,block:n}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(t):function(e){switch(e[0]){case M.Literal:return{kind:x.Literal,value:e[1]};case M.Append:return _s(e[1],e[2]);case M.Modifier:return{kind:x.Modifier,params:de(e[1]),hash:Ue(e[2])};case M.DynamicComponent:return{kind:x.DynamicComponent,expr:Tt(e[1]),hash:Ue(e[2]),block:ht(e[3])};case M.Comment:return{kind:x.Comment,value:e[1]}}}(t);if(typeof t=="string")return Vr(xt(t),!1);throw me(t)}function Vr(t,e){return t.type===T.GetPath?{kind:x.AppendPath,path:t,trusted:e}:{kind:x.AppendExpr,expr:t,trusted:e}}function yo(t){const e=/^(#|!)(.*)$/u.exec(t);if(e===null)throw new Error("Unexpected missing # in block head");return xt(e[2])}function ct(t){const e=/^\((.*)\)$/u.exec(t);if(e===null)throw new Error("Unexpected missing () in call head");return xt(e[1])}function sa(t,e=[]){const r=na(t);return _(e)?{type:T.GetPath,path:{head:r,tail:e}}:{type:T.GetVar,variable:r}}function xt(t){const{kind:e,name:r}=na(t),[s,...n]=r.split("."),a={kind:e,name:s,mode:"loose"};return _(n)?{type:T.GetPath,path:{head:a,tail:n}}:{type:T.GetVar,variable:a}}function na(t){let e,r;if(/^this(?:\.|$)/u.test(t))return{kind:X.This,name:t,mode:"loose"};switch(t[0]){case"^":e=X.Free,r=t.slice(1);break;case"@":e=X.Arg,r=t.slice(1);break;case"&":e=X.Block,r=t.slice(1);break;default:e=X.Local,r=t}return{kind:e,name:r,mode:"loose"}}function Ms(t){const e=t[0];let r=oe(),s=null,n=null,a=null;return t.length===2?r=yr(t[1]):t.length===3?(Array.isArray(t[1])?s=de(t[1]):{hash:n,blockParams:a}=Fs(t[1]),r=yr(t[2])):t.length===4&&(s=de(t[1]),{hash:n,blockParams:a}=Fs(t[2]),r=yr(t[3])),{head:yo(e),params:s,hash:n,blockParams:a,blocks:r}}function Fs(t){if(t===null)return{hash:null,blockParams:null};let e=null,r=null;return function(s,n){Object.keys(s).forEach(a=>{const i=s[a];n(a,i)})}(t,(s,n)=>{s==="as"?r=Array.isArray(n)?n:[n]:(e=e||oe(),e[s]=Tt(n))}),{hash:e,blockParams:r}}function yr(t){return Array.isArray(t)?{default:ht(t)}:ls(t,ht)}function ht(t){return t.map(e=>ra(e))}function Ds(t){return ls(t,e=>{return(r=e,r==="splat"?{expr:x.Splat,trusted:!1}:{expr:Tt(r),trusted:!1}).expr;var r})}function ls(t,e){const r=oe();return Object.keys(t).forEach(s=>{r[s]=e(t[s],s)}),r}function wo(t){return/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(t)?.[1]??null}let M=function(t){return t[t.Literal=0]="Literal",t[t.Comment=1]="Comment",t[t.Append=2]="Append",t[t.Modifier=3]="Modifier",t[t.DynamicComponent=4]="DynamicComponent",t[t.Get=5]="Get",t[t.Concat=6]="Concat",t[t.HasBlock=7]="HasBlock",t[t.HasBlockParams=8]="HasBlockParams",t}({}),T=function(t){return t.Literal="Literal",t.Call="Call",t.GetPath="GetPath",t.GetVar="GetVar",t.Concat="Concat",t.HasBlock="HasBlock",t.HasBlockParams="HasBlockParams",t}({});function _s(t,e=!1){if(t==null)return{expr:{type:T.Literal,value:t},kind:x.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case M.Literal:return{expr:{type:T.Literal,value:t[1]},kind:x.AppendExpr,trusted:!1};case M.Get:return Vr(sa(t[1],t[2]),e);case M.Concat:return{expr:{type:T.Concat,params:de(t.slice(1))},kind:x.AppendExpr,trusted:e};case M.HasBlock:return{expr:{type:T.HasBlock,name:t[1]},kind:x.AppendExpr,trusted:e};case M.HasBlockParams:return{expr:{type:T.HasBlockParams,name:t[1]},kind:x.AppendExpr,trusted:e};default:if(aa(t))return{expr:ia(t),kind:x.AppendExpr,trusted:e};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw me(t);switch(typeof t){case"string":return Vr(xt(t),e);case"boolean":case"number":return{expr:{type:T.Literal,value:t},kind:x.AppendExpr,trusted:!0};default:throw me(t)}}}function Tt(t){if(t==null)return{type:T.Literal,value:t};if(Array.isArray(t))switch(t[0]){case M.Literal:return{type:T.Literal,value:t[1]};case M.Get:return sa(t[1],t[2]);case M.Concat:return{type:T.Concat,params:de(t.slice(1))};case M.HasBlock:return{type:T.HasBlock,name:t[1]};case M.HasBlockParams:return{type:T.HasBlockParams,name:t[1]};default:if(aa(t))return ia(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw me(t);switch(typeof t){case"string":return xt(t);case"boolean":case"number":return{type:T.Literal,value:t};default:throw me(t)}}}function aa(t){return typeof t[0]=="string"&&t[0][0]==="("}function de(t){return t.map(Tt)}function Ue(t){return t===null?null:ls(t,Tt)}function ia(t){switch(t.length){case 1:return{type:T.Call,head:ct(t[0]),params:null,hash:null};case 2:return Array.isArray(t[1])?{type:T.Call,head:ct(t[0]),params:de(t[1]),hash:null}:{type:T.Call,head:ct(t[0]),params:null,hash:Ue(t[1])};case 3:return{type:T.Call,head:ct(t[0]),params:de(t[1]),hash:Ue(t[2])}}}class oa{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return wr(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return wr(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return wr(this._symbols,e)}child(e){return new cs(this,e)}}class cs{locals=oe();constructor(e,r){this.parent=e;for(let s of r)this.locals[s]=e.top.symbol(s)}get paramSymbols(){return Hi(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new cs(this,e)}}function wr(t,e){let r=t.indexOf(e);return r===-1&&(r=t.length,t.push(e)),r}function Vs(t){return new Error(`unimplemented ${t}`)}function vo(t,e){let r=[];return t.forEach(s=>r.push(...or(ra(s),e))),r}function So(t,e){let r=[];return t.forEach(s=>r.push(...or(s,e))),r}function or(t,e=new oa){switch(t.kind){case x.AppendPath:return[[t.trusted?u.TrustingAppend:u.Append,us(t.path,e)]];case x.AppendExpr:return[[t.trusted?u.TrustingAppend:u.Append,Me(t.expr,t.trusted?"TrustedAppend":"Append",e)]];case x.Call:{let{head:r,params:s,hash:n,trusted:a}=t,i=s?Jt(s,e):null,o=n?Ur(n,e):null,l=zr(r,a?te.ResolveAsHelperHead:te.ResolveAsComponentOrHelperHead,e);return[[a?u.TrustingAppend:u.Append,[u.Call,l,i,o]]]}case x.Literal:return[[u.Append,t.value]];case x.Comment:return[[u.Comment,t.value]];case x.Block:{let r=function(i,o,l){let c=[],h=[];for(const[d,m]of Object.entries(i))if(c.push(d),d==="default"){let g=l.child(o||[]);h.push(Kt(m,g,g.paramSymbols))}else h.push(Kt(m,l,[]));return[c,h]}(t.blocks,t.blockParams,e),s=Ur(t.hash,e),n=Jt(t.params,e),a=zr(t.head,te.ResolveAsComponentHead,e);return[[u.Block,a,n,s,r]]}case x.Keyword:return[No(t,e)];case x.Element:return function({name:r,attrs:s,block:n},a){let i=[xo(s)?[u.OpenElementWithSplat,r]:[u.OpenElement,r]];if(s){let{params:o,args:l}=function(c,h){let d=[],m=[],g=[];for(const[v,F]of Object.entries(c))F===x.Splat?d.push([u.AttrSplat,h.block("&attrs")]):v[0]==="@"?(m.push(v),g.push(Me(F,"Strict",h))):d.push(...Bo(v,F,To(v),h));return{params:d,args:_(m)&&_(g)?[m,g]:null}}(s,a);i.push(...o),w(l===null,"Can't pass args to a simple element")}if(i.push([u.FlushElement]),Array.isArray(n))n.forEach(o=>i.push(...or(o,a)));else if(n!==null)throw me(n);return i.push([u.CloseElement]),i}(t,e);case x.Modifier:throw Vs("modifier");case x.DynamicComponent:throw Vs("dynamic component");default:throw me(t)}}function Eo(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[M.Literal,r]}function Ao(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[M.Comment,r]}function Po(t){return String.fromCharCode(parseInt(t,16))}const Co=`
`;function No(t,e){let{name:r}=t,s=Jt(t.params,e),n=e.child(t.blockParams||[]),a=Kt(t.blocks.default,n,n.paramSymbols),i=t.blocks.else?Kt(t.blocks.else,e,[]):null;switch(r){case"let":return[u.Let,ut(s,"let requires params"),a];case"if":return[u.If,ut(s,"if requires params")[0],a,i];case"each":{let o=t.hash?t.hash.key:null,l=o?Me(o,"Strict",e):null;return[u.Each,ut(s,"if requires params")[0],l,a,i]}default:throw new Error("unimplemented keyword")}}function xo(t){return t!==null&&Object.keys(t).some(e=>t[e]===x.Splat)}function To(t){if(t==="xmlns")return As;let e=/^([^:]*):([^:]*)$/u.exec(t);if(e===null)return null;switch(e[1]){case"xlink":return Pi;case"xml":return Ci;case"xmlns":return As}return null}function Bo(t,e,r,s){if(e.type===T.Literal){let n=e.value;if(n===!1)return[];if(n===!0)return[[u.StaticAttr,t,"",r??void 0]];if(typeof n=="string")return[[u.StaticAttr,t,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[u.DynamicAttr,t,Me(e,"AttrValue",s),r??void 0]]}function zs(t,e){switch(t){case"Append":return e?"AppendBare":"AppendInvoke";case"TrustedAppend":return e?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return e?"AttrValueBare":"AttrValueInvoke";default:return t}}function Me(t,e,r){switch(t.type){case T.GetPath:return us(t,r);case T.GetVar:return pt(t.variable,zs(e,!0),r);case T.Concat:return[u.Concat,Lo(t.params,r)];case T.Call:{let s=Jt(t.params,r),n=Ur(t.hash,r),a=zr(t.head,e==="Strict"?"SubExpression":zs(e,!1),r);return[u.Call,a,s,n]}case T.HasBlock:return[u.HasBlock,pt({kind:X.Block,name:t.name,mode:"loose"},te.Strict,r)];case T.HasBlockParams:return[u.HasBlockParams,pt({kind:X.Block,name:t.name,mode:"loose"},te.Strict,r)];case T.Literal:return t.value===void 0?[u.Undefined]:t.value;default:me(t)}}function zr(t,e,r){return t.type===T.GetVar?pt(t.variable,e,r):us(t,r)}function us(t,e){return pt(t.path.head,te.Strict,e,t.path.tail)}function pt(t,e,r,s){let n,a=u.GetSymbol;return t.kind===X.Free?(a=e==="Strict"?u.GetStrictKeyword:e==="AppendBare"||e==="AppendInvoke"?u.GetFreeAsComponentOrHelperHead:e==="TrustedAppendBare"||e==="TrustedAppendInvoke"||e==="AttrValueBare"||e==="AttrValueInvoke"||e==="SubExpression"?u.GetFreeAsHelperHead:function(i){switch(i){case te.Strict:return u.GetStrictKeyword;case te.ResolveAsComponentOrHelperHead:return u.GetFreeAsComponentOrHelperHead;case te.ResolveAsHelperHead:return u.GetFreeAsHelperHead;case te.ResolveAsModifierHead:return u.GetFreeAsModifierHead;case te.ResolveAsComponentHead:return u.GetFreeAsComponentHead;default:return dt(i)}}(e),n=r.freeVar(t.name)):(a=u.GetSymbol,n=function(i,o,l){switch(i){case X.Arg:return o.arg(l);case X.Block:return o.block(l);case X.Local:return o.local(l);case X.This:return o.this();default:return dt(i)}}(t.kind,r,t.name)),s===void 0||s.length===0?[a,n]:(w(a!==u.GetStrictKeyword,"[BUG] keyword with a path"),[a,n,s])}function Jt(t,e){return t!==null&&_(t)?t.map(r=>Me(r,"Strict",e)):null}function Lo(t,e){return t.map(r=>Me(r,"AttrValue",e))}function Ur(t,e){if(t===null)return null;let r=[[],[]];for(const[s,n]of Object.entries(t))r[0].push(s),r[1].push(Me(n,"Strict",e));return r}function Kt(t,e,r=[]){return[So(t,e),r]}class $o extends b("Template").fields(){}class Ho extends b("InElement").fields(){}class la extends b("Not").fields(){}class Us extends b("If").fields(){}class Oo extends b("IfInline").fields(){}class Io extends b("Each").fields(){}class Mo extends b("Let").fields(){}class Fo extends b("WithDynamicVars").fields(){}class Do extends b("GetDynamicVar").fields(){}class _o extends b("Log").fields(){}class ca extends b("InvokeComponent").fields(){}class Vo extends b("NamedBlocks").fields(){}class zo extends b("NamedBlock").fields(){}class Uo extends b("AppendTrustedHTML").fields(){}class Wt extends b("AppendTextNode").fields(){}class Go extends b("AppendComment").fields(){}class Ro extends b("Component").fields(){}class jo extends b("StaticAttr").fields(){}class Jo extends b("DynamicAttr").fields(){}class Ko extends b("SimpleElement").fields(){}class Wo extends b("ElementParameters").fields(){}class Yo extends b("Yield").fields(){}class qo extends b("Debugger").fields(){}class ua extends b("CallExpression").fields(){}class Xo extends b("Modifier").fields(){}class Qo extends b("InvokeBlock").fields(){}class Zo extends b("SplatAttr").fields(){}class el extends b("PathExpression").fields(){}class tl extends b("Missing").fields(){}class rl extends b("InterpolateExpression").fields(){}class sl extends b("HasBlock").fields(){}class nl extends b("HasBlockParams").fields(){}class al extends b("Curry").fields(){}class il extends b("Positional").fields(){}class ha extends b("NamedArguments").fields(){}class pa extends b("NamedArgument").fields(){}class ol extends b("Args").fields(){}class ll extends b("Tail").fields(){}class hs{constructor(e){this.list=e}toArray(){return this.list}map(e){let r=cn(this.list,e);return new hs(r)}filter(e){let r=[];for(let s of this.list)e(s)&&r.push(s);return kt(r)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class Yt{list=[];map(e){return new Yt}filter(e){return new Yt}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function kt(t){return _(t)?new hs(t):new Yt}class ps{static all(...e){let r=[];for(let s of e){if(s.isErr)return s.cast();r.push(s.value)}return k(r)}}const U=ps;class cl extends ps{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return k(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class da extends ps{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return S(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function k(t){return new cl(t)}function S(t){return new da(t)}class Oe{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter(r=>r instanceof da)[0];return e!==void 0?e.cast():k(this.items.map(r=>r.value))}toOptionalList(){return this.toArray().mapOk(e=>kt(e))}}function qt(t){return t.type==="Path"&&t.ref.type==="Free"&&t.ref.name in Qr?new Ce.CallExpression({callee:t,args:Ce.Args.empty(t.loc),loc:t.loc}):t}const C=new class{visit(t,e){switch(t.type){case"Literal":return k(this.Literal(t));case"Keyword":return k(this.Keyword(t));case"Interpolate":return this.Interpolate(t,e);case"Path":return this.PathExpression(t);case"Call":{let r=Sl.translate(t,e);return r!==null?r:this.CallExpression(t,e)}}}visitList(t,e){return new Oe(t.map(r=>C.visit(r,e))).toOptionalList()}PathExpression(t){let e=this.VariableReference(t.ref),{tail:r}=t;if(_(r)){let s=r[0].loc.extend(rt(r).loc);return k(new el({loc:t.loc,head:e,tail:new ll({loc:s,members:r})}))}return k(e)}VariableReference(t){return t}Literal(t){return t}Keyword(t){return t}Interpolate(t,e){let r=t.parts.map(qt);return C.visitList(r,e).mapOk(s=>new rl({loc:t.loc,parts:s}))}CallExpression(t,e){if(t.callee.type==="Call")throw new Error("unimplemented: subexpression at the head of a subexpression");return U.all(C.visit(t.callee,e),C.Args(t.args,e)).mapOk(([r,s])=>new ua({loc:t.loc,callee:r,args:s}))}Args({positional:t,named:e,loc:r},s){return U.all(this.Positional(t,s),this.NamedArguments(e,s)).mapOk(([n,a])=>new ol({loc:r,positional:n,named:a}))}Positional(t,e){return C.visitList(t.exprs,e).mapOk(r=>new il({loc:t.loc,list:r}))}NamedArguments(t,e){let r=t.entries.map(s=>{let n=qt(s.value);return C.visit(n,e).mapOk(a=>new pa({loc:s.loc,key:s.name,value:a}))});return new Oe(r).toOptionalList().mapOk(s=>new ha({loc:t.loc,entries:s}))}};class ul{types;constructor(e,r,s){this.keyword=e,this.delegate=s;let n=new Set;for(let a of hl[r])n.add(a);this.types=n}match(e){if(!this.types.has(e.type))return!1;let r=Xt(e);return r!==null&&r.type==="Path"&&r.ref.type==="Free"&&r.ref.name===this.keyword}translate(e,r){if(this.match(e)){let s=Xt(e);return s!==null&&s.type==="Path"&&s.tail.length>0?S(p(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${s.loc.asString()}\`, but it cannot be used with additional path segments. 

Error caused by`,e.loc)):this.delegate.assert(e,r).andThen(n=>this.delegate.translate({node:e,state:r},n))}return null}}const hl={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function Xt(t){switch(t.type){case"Path":return t;case"AppendContent":return Xt(t.value);case"Call":case"InvokeBlock":case"ElementModifier":return t.callee;default:return null}}class pl{_keywords=[];_type;constructor(e){this._type=e}kw(e,r){return this._keywords.push(function(s,n,a){return new ul(s,n,a)}(e,this._type,r)),this}translate(e,r){for(let n of this._keywords){let a=n.translate(e,r);if(a!==null)return a}let s=Xt(e);if(s&&s.type==="Path"&&s.ref.type==="Free"&&Ui(s.ref.name)){let{name:n}=s.ref,a=this._type,i=Qr[n];if(!i.includes(a))return S(p(`The \`${n}\` keyword was used incorrectly. It was used as ${dl[a]}, but its valid usages are:

${function(o,l){return l.map(c=>{switch(c){case"Append":return`- As an append statement, as in: {{${o}}}`;case"Block":return`- As a block statement, as in: {{#${o}}}{{/${o}}}`;case"Call":return`- As an expression, as in: (${o})`;case"Modifier":return`- As a modifier, as in: <div {{${o}}}></div>`;default:return dt(c)}}).join(`

`)}(n,i)}

Error caused by`,e.loc))}return null}}const dl={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function lr(t){return new pl(t)}function De({assert:t,translate:e}){return{assert:t,translate:({node:r,state:s},n)=>e({node:r,state:s},n).mapOk(a=>new Wt({text:a,loc:r.loc}))}}const ml={[j.Component]:"component",[j.Helper]:"helper",[j.Modifier]:"modifier"};function Qt(t){return(e,r)=>{let s=ml[t],n=t===j.Component,{args:a}=e,i=a.nth(0);if(i===null)return S(p(`(${s}) requires a ${s} definition or identifier as its first positional parameter, did not receive any parameters.`,a.loc));if(i.type==="Literal"){if(n&&r.isStrict)return S(p(`(${s}) cannot resolve string values in strict mode templates`,e.loc));if(!n)return S(p(`(${s}) cannot resolve string values, you must pass a ${s} definition directly`,e.loc))}return a=new Ce.Args({positional:new Ce.PositionalArguments({exprs:a.positional.exprs.slice(1),loc:a.positional.loc}),named:a.named,loc:a.loc}),k({definition:i,args:a})}}function fl(t){return({node:e,state:r},{definition:s,args:n})=>{let a=C.visit(s,r),i=C.Args(n,r);return U.all(a,i).mapOk(([o,l])=>new al({loc:e.loc,curriedType:t,definition:o,args:l}))}}function vr(t){return{assert:Qt(t),translate:fl(t)}}const ma={assert:function(t){let e=t.type==="AppendContent"?t.value:t,r=e.type==="Call"?e.args.named:null,s=e.type==="Call"?e.args.positional:null;if(r&&!r.isEmpty())return S(p("(-get-dynamic-vars) does not take any named arguments",t.loc));let n=s?.nth(0);return n?s&&s.size>1?S(p("(-get-dynamic-vars) only receives one positional arg",t.loc)):k(n):S(p("(-get-dynamic-vars) requires a var name to get",t.loc))},translate:function({node:t,state:e},r){return C.visit(r,e).mapOk(s=>new Do({name:s,loc:t.loc}))}};function bl(t){return e=>{let r=e.type==="AppendContent"?e.value:e,s=r.type==="Call"?r.args.named:null,n=r.type==="Call"?r.args.positional:null;if(s&&!s.isEmpty())return S(p(`(${t}) does not take any named arguments`,r.loc));if(!n||n.isEmpty())return k(Z.synthetic("default"));if(n.exprs.length===1){let a=n.exprs[0];return Ce.isLiteral(a,"string")?k(a.toSlice()):S(p(`(${t}) can only receive a string literal as its first argument`,r.loc))}return S(p(`(${t}) only takes a single positional argument`,r.loc))}}function gl(t){return({node:e,state:{scope:r}},s)=>k(t==="has-block"?new sl({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}):new nl({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}))}function Zt(t){return{assert:bl(t),translate:gl(t)}}function kl(t){return e=>{let r=t==="unless",s=e.type==="AppendContent"?e.value:e,n=s.type==="Call"?s.args.named:null,a=s.type==="Call"?s.args.positional:null;if(n&&!n.isEmpty())return S(p(`(${t}) cannot receive named parameters, received ${n.entries.map(c=>c.name.chars).join(", ")}`,e.loc));let i=a?.nth(0);if(!a||!i)return S(p(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,e.loc));let o=a.nth(1),l=a.nth(2);return o===null?S(p(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,e.loc)):a.size>3?S(p(`When used inline, (${t}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${t}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${a?.size??0} parameters`,e.loc)):k({condition:i,truthy:o,falsy:l})}}function yl(t){let e=t==="unless";return({node:r,state:s},{condition:n,truthy:a,falsy:i})=>{let o=C.visit(n,s),l=C.visit(a,s),c=i?C.visit(i,s):k(null);return U.all(o,l,c).mapOk(([h,d,m])=>(e&&(h=new la({value:h,loc:r.loc})),new Oo({loc:r.loc,condition:h,truthy:d,falsy:m})))}}function er(t){return{assert:kl(t),translate:yl(t)}}const fa={assert:function(t){let{args:{named:e,positional:r}}=t;return e&&!e.isEmpty()?S(p("(log) does not take any named arguments",t.loc)):k(r)},translate:function({node:t,state:e},r){return C.Positional(r,e).mapOk(s=>new _o({positional:s,loc:t.loc}))}},wl=lr("Append").kw("has-block",De(Zt("has-block"))).kw("has-block-params",De(Zt("has-block-params"))).kw("-get-dynamic-var",De(ma)).kw("log",De(fa)).kw("if",De(er("if"))).kw("unless",De(er("unless"))).kw("yield",{assert(t){let{args:e}=t;if(e.named.isEmpty())return k({target:Rt.SourceSpan.synthetic("default").toSlice(),positional:e.positional});{let r=e.named.get("to");return e.named.size>1||r===null?S(p("yield only takes a single named argument: 'to'",e.named.loc)):Ce.isLiteral(r,"string")?k({target:r.toSlice(),positional:e.positional}):S(p("you can only yield to a literal string value",r.loc))}},translate:({node:t,state:e},{target:r,positional:s})=>C.Positional(s,e).mapOk(n=>new Yo({loc:t.loc,target:r,to:e.scope.allocateBlock(r.chars),positional:n}))}).kw("debugger",{assert(t){let{args:e}=t,{positional:r}=e;return e.isEmpty()?k(void 0):r.isEmpty()?S(p("debugger does not take any named arguments",t.loc)):S(p("debugger does not take any positional arguments",t.loc))},translate:({node:t,state:{scope:e}})=>(e.setHasDebugger(),k(new qo({loc:t.loc,scope:e})))}).kw("component",{assert:Qt(j.Component),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e);return U.all(n,a).mapOk(([i,o])=>new ca({loc:t.loc,definition:i,args:o,blocks:null}))}}).kw("helper",{assert:Qt(j.Helper),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e);return U.all(n,a).mapOk(([i,o])=>{let l=new ua({callee:i,args:o,loc:t.loc});return new Wt({loc:t.loc,text:l})})}}),vl=lr("Block").kw("in-element",{assert(t){let{args:e}=t,r=e.get("guid");if(r)return S(p("Cannot pass `guid` to `{{#in-element}}`",r.loc));let s=e.get("insertBefore"),n=e.nth(0);return n===null?S(p("{{#in-element}} requires a target element as its first positional parameter",e.loc)):k({insertBefore:s,destination:n})},translate({node:t,state:e},{insertBefore:r,destination:s}){let n=t.blocks.get("default"),a=G.NamedBlock(n,e),i=C.visit(s,e);return U.all(a,i).andThen(([o,l])=>r?C.visit(r,e).mapOk(c=>({body:o,destination:l,insertBefore:c})):k({body:o,destination:l,insertBefore:new tl({loc:t.callee.loc.collapse("end")})})).mapOk(({body:o,destination:l,insertBefore:c})=>new Ho({loc:t.loc,block:o,insertBefore:c,guid:e.generateUniqueCursor(),destination:l}))}}).kw("if",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return S(p(`{{#if}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return S(p(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?S(p("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):k({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=C.visit(r,e),i=G.NamedBlock(s,e),o=n?G.NamedBlock(n,e):k(null);return U.all(a,i,o).mapOk(([l,c,h])=>new Us({loc:t.loc,condition:l,block:c,inverse:h}))}}).kw("unless",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return S(p(`{{#unless}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return S(p(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?S(p("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):k({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=C.visit(r,e),i=G.NamedBlock(s,e),o=n?G.NamedBlock(n,e):k(null);return U.all(a,i,o).mapOk(([l,c,h])=>new Us({loc:t.loc,condition:new la({value:l,loc:t.loc}),block:c,inverse:h}))}}).kw("each",{assert(t){let{args:e}=t;if(!e.named.entries.every(n=>n.name.chars==="key"))return S(p(`{{#each}} can only receive the 'key' named parameter, received ${e.named.entries.filter(n=>n.name.chars!=="key").map(n=>n.name.chars).join(", ")}`,e.named.loc));if(e.positional.size>1)return S(p(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${e.positional.size} parameters`,e.positional.loc));let r=e.nth(0),s=e.get("key");return r===null?S(p("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",e.loc)):k({value:r,key:s})},translate({node:t,state:e},{value:r,key:s}){let n=t.blocks.get("default"),a=t.blocks.get("else"),i=C.visit(r,e),o=s?C.visit(s,e):k(null),l=G.NamedBlock(n,e),c=a?G.NamedBlock(a,e):k(null);return U.all(i,o,l,c).mapOk(([h,d,m,g])=>new Io({loc:t.loc,value:h,key:d,block:m,inverse:g}))}}).kw("let",{assert(t){let{args:e}=t;return e.named.isEmpty()?e.positional.size===0?S(p("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",e.positional.loc)):t.blocks.get("else")?S(p("{{#let}} cannot receive an {{else}} block",e.positional.loc)):k({positional:e.positional}):S(p(`{{#let}} cannot receive named parameters, received ${e.named.entries.map(r=>r.name.chars).join(", ")}`,e.named.loc))},translate({node:t,state:e},{positional:r}){let s=t.blocks.get("default"),n=C.Positional(r,e),a=G.NamedBlock(s,e);return U.all(n,a).mapOk(([i,o])=>new Mo({loc:t.loc,positional:i,block:o}))}}).kw("-with-dynamic-vars",{assert:t=>k({named:t.args.named}),translate({node:t,state:e},{named:r}){let s=t.blocks.get("default"),n=C.NamedArguments(r,e),a=G.NamedBlock(s,e);return U.all(n,a).mapOk(([i,o])=>new Fo({loc:t.loc,named:i,block:o}))}}).kw("component",{assert:Qt(j.Component),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e),i=G.NamedBlocks(t.blocks,e);return U.all(n,a,i).mapOk(([o,l,c])=>new ca({loc:t.loc,definition:o,args:l,blocks:c}))}}),Sl=lr("Call").kw("has-block",Zt("has-block")).kw("has-block-params",Zt("has-block-params")).kw("-get-dynamic-var",ma).kw("log",fa).kw("if",er("if")).kw("unless",er("unless")).kw("component",vr(j.Component)).kw("helper",vr(j.Helper)).kw("modifier",vr(j.Modifier)),El=lr("Modifier"),Le="http://www.w3.org/1999/xlink",Sr="http://www.w3.org/XML/1998/namespace",Gs="http://www.w3.org/2000/xmlns/",Al={"xlink:actuate":Le,"xlink:arcrole":Le,"xlink:href":Le,"xlink:role":Le,"xlink:show":Le,"xlink:title":Le,"xlink:type":Le,"xml:base":Sr,"xml:lang":Sr,"xml:space":Sr,xmlns:Gs,"xmlns:xlink":Gs},Pl={div:Ht.div,span:Ht.span,p:Ht.p,a:Ht.a},Cl=["div","span","p","a"];function Rs(t){return typeof t=="string"?t:Cl[t]}const Nl={class:Be.class,id:Be.id,value:Be.value,name:Be.name,type:Be.type,style:Be.style,href:Be.href},xl=["class","id","value","name","type","style","href"];function ba(t){return Nl[t]??t}function _e(t){return typeof t=="string"?t:xl[t]}class js{delegate;constructor(e,r,s){this.element=e,this.state=s,this.delegate=r}toStatement(){return this.prepare().andThen(e=>this.delegate.toStatement(this,e))}attr(e){let r=e.name,s=e.value,n=(a=r.chars,Al[a]||void 0);var a;return Ce.isLiteral(s,"string")?k(new jo({loc:e.loc,name:r,value:s.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):C.visit(qt(s),this.state).mapOk(i=>{let o=e.trusting;return new Jo({loc:e.loc,name:r,value:i,namespace:n,kind:{trusting:o,component:this.delegate.dynamicFeatures}})})}modifier(e){let r=El.translate(e,this.state);if(r!==null)return r;let s=C.visit(e.callee,this.state),n=C.Args(e.args,this.state);return U.all(s,n).mapOk(([a,i])=>new Xo({loc:e.loc,callee:a,args:i}))}attrs(){let e=new Oe,r=new Oe,s=null,n=this.element.attrs.filter(a=>a.type==="SplatAttr").length===0;for(let a of this.element.attrs)a.type==="SplatAttr"?e.add(k(new Zo({loc:a.loc,symbol:this.state.scope.allocateBlock("attrs")}))):a.name.chars==="type"&&n?s=a:e.add(this.attr(a));for(let a of this.element.componentArgs)r.add(this.delegate.arg(a,this));return s&&e.add(this.attr(s)),U.all(r.toArray(),e.toArray()).mapOk(([a,i])=>({attrs:i,args:new ha({loc:Ir(a,Rt.SourceSpan.NON_EXISTENT),entries:kt(a)})}))}prepare(){let e=this.attrs(),r=new Oe(this.element.modifiers.map(s=>this.modifier(s))).toArray();return U.all(e,r).mapOk(([s,n])=>{let{attrs:a,args:i}=s,o=[...a,...n];return{args:i,params:new Wo({loc:Ir(o,Rt.SourceSpan.NON_EXISTENT),body:kt(o)})}})}}class Tl{dynamicFeatures=!0;constructor(e,r){this.tag=e,this.element=r}arg(e,{state:r}){let s=e.name;return C.visit(qt(e.value),r).mapOk(n=>new pa({loc:e.loc,key:s,value:n}))}toStatement(e,{args:r,params:s}){let{element:n,state:a}=e;return this.blocks(a).mapOk(i=>new Ro({loc:n.loc,tag:this.tag,params:s,args:r,blocks:i}))}blocks(e){return G.NamedBlocks(this.element.blocks,e)}}class Bl{constructor(e,r,s){this.tag=e,this.element=r,this.dynamicFeatures=s}isComponent=!1;arg(e){return S(p(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:r}){let{state:s,element:n}=e;return G.visitList(this.element.body,s).mapOk(a=>new Ko({loc:n.loc,tag:this.tag,params:r,body:a.toArray(),dynamicFeatures:this.dynamicFeatures}))}}const G=new class{visitList(t,e){return new Oe(t.map(r=>G.visit(r,e))).toOptionalList().mapOk(r=>r.filter(s=>s!==null))}visit(t,e){switch(t.type){case"GlimmerComment":return k(null);case"AppendContent":return this.AppendContent(t,e);case"HtmlText":return k(this.TextNode(t));case"HtmlComment":return k(this.HtmlComment(t));case"InvokeBlock":return this.InvokeBlock(t,e);case"InvokeComponent":return this.Component(t,e);case"SimpleElement":return this.SimpleElement(t,e)}}InvokeBlock(t,e){let r=vl.translate(t,e);if(r!==null)return r;let s=C.visit(t.callee,e),n=C.Args(t.args,e);return U.all(s,n).andThen(([a,i])=>this.NamedBlocks(t.blocks,e).mapOk(o=>new Qo({loc:t.loc,head:a,args:i,blocks:o})))}NamedBlocks(t,e){return new Oe(t.blocks.map(r=>this.NamedBlock(r,e))).toArray().mapOk(r=>new Vo({loc:t.loc,blocks:kt(r)}))}NamedBlock(t,e){return e.visitBlock(t.block).mapOk(r=>new zo({loc:t.loc,name:t.name,body:r.toArray(),scope:t.block.scope}))}SimpleElement(t,e){return new js(t,new Bl(t.tag,t,function({attrs:r,modifiers:s}){return s.length>0||!!r.filter(n=>n.type==="SplatAttr")[0]}(t)),e).toStatement()}Component(t,e){return C.visit(t.callee,e).andThen(r=>new js(t,new Tl(r,t),e).toStatement())}AppendContent(t,e){let r=wl.translate(t,e);return r!==null?r:C.visit(t.value,e).mapOk(s=>t.trusting?new Uo({loc:t.loc,html:s}):new Wt({loc:t.loc,text:s}))}TextNode(t){return new Wt({loc:t.loc,text:new Ce.LiteralExpression({loc:t.loc,value:t.chars})})}HtmlComment(t){return new Go({loc:t.loc,value:t.text})}};class Ll{_currentScope;_cursorCount=0;constructor(e,r){this.isStrict=r,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let r=this._currentScope;this._currentScope=e.scope;try{return G.visitList(e.body,this)}finally{this._currentScope=r}}}var J=function(t){return t.Value="value",t.Component="component",t.Helper="helper",t.Modifier="modifier",t.ComponentOrHelper="component or helper",t}(J||{});class $l{static validate(e){return new this(e).validate()}constructor(e){this.template=e}validate(){return this.Statements(this.template.body).mapOk(()=>this.template)}Statements(e){let r=k(null);for(let s of e)r=r.andThen(()=>this.Statement(s));return r}NamedBlocks({blocks:e}){let r=k(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedBlock(s));return r}NamedBlock(e){return this.Statements(e.body)}Statement(e){switch(e.type){case"InElement":return this.InElement(e);case"Debugger":case"AppendComment":return k(null);case"Yield":return this.Yield(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"AppendTextNode":return this.AppendTextNode(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e)}}Expressions(e){let r=k(null);for(let s of e)r=r.andThen(()=>this.Expression(s));return r}Expression(e,r=e,s){switch(e.type){case"Literal":case"Keyword":case"Missing":case"This":case"Arg":case"Local":case"HasBlock":case"HasBlockParams":case"GetDynamicVar":return k(null);case"PathExpression":return this.Expression(e.head,r,s);case"Free":return this.errorFor(e.name,r,s);case"InterpolateExpression":return this.InterpolateExpression(e,r,s);case"CallExpression":return this.CallExpression(e,r,s??J.Helper);case"Not":return this.Expression(e.value,r,s);case"IfInline":return this.IfInline(e);case"Curry":return this.Curry(e);case"Log":return this.Log(e)}}Args(e){return this.Positional(e.positional).andThen(()=>this.NamedArguments(e.named))}Positional(e,r){let s=k(null),n=e.list.toArray();return s=n.length===1?this.Expression(n[0],r):this.Expressions(n),s}NamedArguments({entries:e}){let r=k(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedArgument(s));return r}NamedArgument(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,J.Helper):this.Expression(e.value,e)}ElementParameters({body:e}){let r=k(null);for(let s of e.toArray())r=r.andThen(()=>this.ElementParameter(s));return r}ElementParameter(e){switch(e.type){case"StaticAttr":case"SplatAttr":return k(null);case"DynamicAttr":return this.DynamicAttr(e);case"Modifier":return this.Modifier(e)}}DynamicAttr(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,J.Helper):this.Expression(e.value,e)}Modifier(e){return this.Expression(e.callee,e,J.Modifier).andThen(()=>this.Args(e.args))}InElement(e){return this.Expression(e.destination).andThen(()=>this.Expression(e.insertBefore)).andThen(()=>this.NamedBlock(e.block))}Yield(e){return this.Positional(e.positional,e)}AppendTrustedHTML(e){return this.Expression(e.html,e)}AppendTextNode(e){return e.text.type==="CallExpression"?this.Expression(e.text,e,J.ComponentOrHelper):this.Expression(e.text,e)}Component(e){return this.Expression(e.tag,e,J.Component).andThen(()=>this.ElementParameters(e.params)).andThen(()=>this.NamedArguments(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}SimpleElement(e){return this.ElementParameters(e.params).andThen(()=>this.Statements(e.body))}InvokeBlock(e){return this.Expression(e.head,e.head,J.Component).andThen(()=>this.Args(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}If(e){return this.Expression(e.condition,e).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):k(null))}Each(e){return this.Expression(e.value,e).andThen(()=>e.key?this.Expression(e.key,e):k(null)).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):k(null))}Let(e){return this.Positional(e.positional).andThen(()=>this.NamedBlock(e.block))}WithDynamicVars(e){return this.NamedArguments(e.named).andThen(()=>this.NamedBlock(e.block))}InvokeComponent(e){return this.Expression(e.definition,e,J.Component).andThen(()=>this.Args(e.args)).andThen(()=>e.blocks?this.NamedBlocks(e.blocks):k(null))}InterpolateExpression(e,r,s){let n=e.parts.toArray();return n.length===1?this.Expression(n[0],r,s):this.Expressions(n)}CallExpression(e,r,s){return this.Expression(e.callee,r,s).andThen(()=>this.Args(e.args))}IfInline(e){return this.Expression(e.condition).andThen(()=>this.Expression(e.truthy)).andThen(()=>e.falsy?this.Expression(e.falsy):k(null))}Curry(e){let r;return r=e.curriedType===j.Component?J.Component:e.curriedType===j.Helper?J.Helper:J.Modifier,this.Expression(e.definition,e,r).andThen(()=>this.Args(e.args))}Log(e){return this.Positional(e.positional,e)}errorFor(e,r,s=J.Value){return S(p(`Attempted to resolve a ${s} in a strict mode template, but that value was not in scope: ${e}`,Qe(r)))}}class Hl{upvars;symbols;constructor([e,r,s,n]){this.upvars=n,this.symbols=r}format(e){let r=[];for(let s of e[0])r.push(this.formatOpcode(s));return r}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case u.Append:return["append",this.formatOpcode(e[1])];case u.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case u.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case u.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case u.OpenElement:return["open-element",Rs(e[1])];case u.OpenElementWithSplat:return["open-element-with-splat",Rs(e[1])];case u.CloseElement:return["close-element"];case u.FlushElement:return["flush-element"];case u.StaticAttr:return["static-attr",_e(e[1]),e[2],e[3]];case u.StaticComponentAttr:return["static-component-attr",_e(e[1]),e[2],e[3]];case u.DynamicAttr:return["dynamic-attr",_e(e[1]),this.formatOpcode(e[2]),e[3]];case u.ComponentAttr:return["component-attr",_e(e[1]),this.formatOpcode(e[2]),e[3]];case u.AttrSplat:return["attr-splat"];case u.Yield:return["yield",e[1],this.formatParams(e[2])];case u.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case u.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case u.TrustingDynamicAttr:return["trusting-dynamic-attr",_e(e[1]),this.formatOpcode(e[2]),e[3]];case u.TrustingComponentAttr:return["trusting-component-attr",_e(e[1]),this.formatOpcode(e[2]),e[3]];case u.Debugger:return["debugger",e[1]];case u.Comment:return["comment",e[1]];case u.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case u.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case u.HasBlock:return["has-block",this.formatOpcode(e[1])];case u.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case u.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case u.Undefined:return["undefined"];case u.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case u.Concat:return["concat",this.formatParams(e[1])];case u.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]]];case u.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case u.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case u.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case u.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case u.GetSymbol:return e[1]===0?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case u.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case u.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case u.IfInline:return["if-inline"];case u.Not:return["not"];case u.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case u.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case u.Log:return["log",this.formatParams(e[1])];case u.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case u.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case u.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case j.Component:return"component";case j.Helper:return"helper";case j.Modifier:return"modifier";default:throw dt(e)}}formatElementParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatHash(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatOpcode(e[1][n]),r),oe())}formatBlocks(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatBlock(e[1][n]),r),oe())}formatBlock(e){return{statements:e[0].map(r=>this.formatOpcode(r)),parameters:e[1]}}}const P=new class{expr(t){switch(t.type){case"Missing":return;case"Literal":return this.Literal(t);case"Keyword":return this.Keyword(t);case"CallExpression":return this.CallExpression(t);case"PathExpression":return this.PathExpression(t);case"Arg":return[u.GetSymbol,t.symbol];case"Local":return this.Local(t);case"This":return[u.GetSymbol,0];case"Free":return[t.resolution.resolution(),t.symbol];case"HasBlock":return this.HasBlock(t);case"HasBlockParams":return this.HasBlockParams(t);case"Curry":return this.Curry(t);case"Not":return this.Not(t);case"IfInline":return this.IfInline(t);case"InterpolateExpression":return this.InterpolateExpression(t);case"GetDynamicVar":return this.GetDynamicVar(t);case"Log":return this.Log(t)}}Literal({value:t}){return t===void 0?[u.Undefined]:t}Missing(){}HasBlock({symbol:t}){return[u.HasBlock,[u.GetSymbol,t]]}HasBlockParams({symbol:t}){return[u.HasBlockParams,[u.GetSymbol,t]]}Curry({definition:t,curriedType:e,args:r}){return[u.Curry,P.expr(t),e,P.Positional(r.positional),P.NamedArguments(r.named)]}Local({isTemplateLocal:t,symbol:e}){return[t?u.GetLexicalSymbol:u.GetSymbol,e]}Keyword({symbol:t}){return[u.GetStrictKeyword,t]}PathExpression({head:t,tail:e}){let r=P.expr(t);return w(r[0]!==u.GetStrictKeyword,"[BUG] keyword in a PathExpression"),[...r,P.Tail(e)]}InterpolateExpression({parts:t}){return[u.Concat,t.map(e=>P.expr(e)).toArray()]}CallExpression({callee:t,args:e}){return[u.Call,P.expr(t),...P.Args(e)]}Tail({members:t}){return cn(t,e=>e.chars)}Args({positional:t,named:e}){return[this.Positional(t),this.NamedArguments(e)]}Positional({list:t}){return t.map(e=>P.expr(e)).toPresentArray()}NamedArgument({key:t,value:e}){return[t.chars,P.expr(e)]}NamedArguments({entries:t}){let e=t.toArray();if(_(e)){let r=[],s=[];for(let n of e){let[a,i]=P.NamedArgument(n);r.push(a),s.push(i)}return Ye(r),Ye(s),[r,s]}return null}Not({value:t}){return[u.Not,P.expr(t)]}IfInline({condition:t,truthy:e,falsy:r}){let s=[u.IfInline,P.expr(t),P.expr(e)];return r&&s.push(P.expr(r)),s}GetDynamicVar({name:t}){return[u.GetDynamicVar,P.expr(t)]}Log({positional:t}){return[u.Log,this.Positional(t)]}};class Js{constructor(e){this.statements=e}toArray(){return this.statements}}const V=new class{list(t){let e=[];for(let r of t){let s=V.content(r);s&&s instanceof Js?e.push(...s.toArray()):e.push(s)}return e}content(t){return this.visitContent(t)}visitContent(t){switch(t.type){case"Debugger":return[u.Debugger,t.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(t);case"AppendTextNode":return this.AppendTextNode(t);case"AppendTrustedHTML":return this.AppendTrustedHTML(t);case"Yield":return this.Yield(t);case"Component":return this.Component(t);case"SimpleElement":return this.SimpleElement(t);case"InElement":return this.InElement(t);case"InvokeBlock":return this.InvokeBlock(t);case"If":return this.If(t);case"Each":return this.Each(t);case"Let":return this.Let(t);case"WithDynamicVars":return this.WithDynamicVars(t);case"InvokeComponent":return this.InvokeComponent(t);default:return dt(t)}}Yield({to:t,positional:e}){return[u.Yield,t,P.Positional(e)]}InElement({guid:t,insertBefore:e,destination:r,block:s}){let n=V.NamedBlock(s)[1],a=P.expr(r),i=P.expr(e);return i===void 0?[u.InElement,n,t,a]:[u.InElement,n,t,a,i]}InvokeBlock({head:t,args:e,blocks:r}){return[u.Block,P.expr(t),...P.Args(e),V.NamedBlocks(r)]}AppendTrustedHTML({html:t}){return[u.TrustingAppend,P.expr(t)]}AppendTextNode({text:t}){return[u.Append,P.expr(t)]}AppendComment({value:t}){return[u.Comment,t.chars]}SimpleElement({tag:t,params:e,body:r,dynamicFeatures:s}){let n=s?u.OpenElementWithSplat:u.OpenElement;return new Js([[n,(a=t.chars,Pl[a]??a)],...V.ElementParameters(e).toArray(),[u.FlushElement],...V.list(r),[u.CloseElement]]);var a}Component({tag:t,params:e,args:r,blocks:s}){let n=P.expr(t),a=V.ElementParameters(e),i=P.NamedArguments(r),o=V.NamedBlocks(s);return[u.Component,n,a.toPresentArray(),i,o]}ElementParameters({body:t}){return t.map(e=>V.ElementParameter(e))}ElementParameter(t){switch(t.type){case"SplatAttr":return[u.AttrSplat,t.symbol];case"DynamicAttr":return[(e=t.kind,e.component?e.trusting?u.TrustingComponentAttr:u.ComponentAttr:e.trusting?u.TrustingDynamicAttr:u.DynamicAttr),...Il(t)];case"StaticAttr":return[Ml(t.kind),...Ol(t)];case"Modifier":return[u.Modifier,P.expr(t.callee),...P.Args(t.args)]}var e}NamedBlocks({blocks:t}){let e=[],r=[];for(let s of t.toArray()){let[n,a]=V.NamedBlock(s);e.push(n),r.push(a)}return e.length>0?[e,r]:null}NamedBlock({name:t,body:e,scope:r}){let s=t.chars;return s==="inverse"&&(s="else"),[s,[V.list(e),r.slots]]}If({condition:t,block:e,inverse:r}){return[u.If,P.expr(t),V.NamedBlock(e)[1],r?V.NamedBlock(r)[1]:null]}Each({value:t,key:e,block:r,inverse:s}){return[u.Each,P.expr(t),e?P.expr(e):null,V.NamedBlock(r)[1],s?V.NamedBlock(s)[1]:null]}Let({positional:t,block:e}){return[u.Let,P.Positional(t),V.NamedBlock(e)[1]]}WithDynamicVars({named:t,block:e}){return[u.WithDynamicVars,P.NamedArguments(t),V.NamedBlock(e)[1]]}InvokeComponent({definition:t,args:e,blocks:r}){return[u.InvokeComponent,P.expr(t),P.Positional(e.positional),P.NamedArguments(e.named),r?V.NamedBlocks(r):null]}};function Ol({name:t,value:e,namespace:r}){let s=[ba(t.chars),e.chars];return r&&s.push(r),s}function Il({name:t,value:e,namespace:r}){let s=[ba(t.chars),P.expr(e)];return r&&s.push(r),s}function Ml(t){return t.component?u.StaticComponentAttr:u.StaticAttr}const ds=(()=>{const t=typeof module=="object"&&typeof module.require=="function"?module.require:globalThis.require;if(t)try{const e=t("crypto"),r=s=>{const n=e.createHash("sha1");return n.update(s,"utf8"),n.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),ga={id:ds};function ka(t,e=ga){const r=new Rt.Source(t??"",e.meta?.moduleName),[s,n]=po(r,{lexicalScope:()=>!1,...e}),a=function(i,o,l){let c=new Ll(o.table,l),h=G.visitList(o.body,c).mapOk(d=>new $o({loc:o.loc,scope:o.table,body:d.toArray()}));return l&&(h=h.andThen(d=>$l.validate(d))),h}(0,s,e.strictMode??!1).mapOk(i=>function(o){let l=V.list(o.body),c=o.scope;return[l,c.symbols,c.hasEval,c.upvars]}(i));if(a.isOk)return[a.value,n];throw a.reason}function Fl(t,e=ga){const[r,s]=ka(t,e),n=e.meta?.moduleName,a=e.id||ds,i=JSON.stringify(r),o={id:a(JSON.stringify(e.meta)+i),block:i,moduleName:n??"(unknown template module)",scope:"796d24e6-2450-4fb0-8cdf-b65638b5ef70",isStrictMode:e.strictMode??!1};s.length===0&&delete o.scope;let l=JSON.stringify(o);if(s.length>0){const c=`()=>[${s.join(",")}]`;l=l.replace('"796d24e6-2450-4fb0-8cdf-b65638b5ef70"',c)}return l}const Dl=Object.freeze(Object.defineProperty({__proto__:null,Builder:M,NEWLINE:Co,ProgramSymbols:oa,WireFormatDebugger:Hl,buildStatement:or,buildStatements:vo,c:Ao,defaultId:ds,precompile:Fl,precompileJSON:ka,s:Eo,unicode:Po},Symbol.toStringTag,{value:"Module"}));function B(t,e){if(!t)throw new Error(e||"assertion failure")}function Gr(t){Kl.warn(`DEPRECATION: ${t}`)}function pe(t){if(t==null)throw new Error("Expected value to be present");return t}function ya(t,e){if(t==null)throw new Error(e);return t}function Y(t){return t.length>0}function yt(t,e="unexpected empty list"){if(!Y(t))throw new Error(e)}function cr(t,e="unexpected empty list"){return yt(t,e),t}function Bt(t){return t.length===0?void 0:t[t.length-1]}function wt(t){return t.length===0?void 0:t[0]}function Er(){return Object.create(null)}const at=!(typeof window<"u"&&window.location&&/[&?]disable_local_debug/u.test(window.location.search));let ce=function(t){return t[t.MAX_SMI=1073741823]="MAX_SMI",t[t.MIN_SMI=-1073741824]="MIN_SMI",t[t.SIGN_BIT=-536870913]="SIGN_BIT",t[t.MAX_INT=536870911]="MAX_INT",t[t.MIN_INT=-536870912]="MIN_INT",t[t.FALSE_HANDLE=0]="FALSE_HANDLE",t[t.TRUE_HANDLE=1]="TRUE_HANDLE",t[t.NULL_HANDLE=2]="NULL_HANDLE",t[t.UNDEFINED_HANDLE=3]="UNDEFINED_HANDLE",t[t.ENCODED_FALSE_HANDLE=0]="ENCODED_FALSE_HANDLE",t[t.ENCODED_TRUE_HANDLE=1]="ENCODED_TRUE_HANDLE",t[t.ENCODED_NULL_HANDLE=2]="ENCODED_NULL_HANDLE",t[t.ENCODED_UNDEFINED_HANDLE=3]="ENCODED_UNDEFINED_HANDLE",t}({});function _l(t){return at&&B(t%1==0&&t>=ce.MIN_INT&&t<0,`Could not encode negative: ${t}`),t&ce.SIGN_BIT}function Vl(t){return at&&B(t%1==0&&t<~ce.MAX_INT&&t>=ce.MIN_SMI,`Could not decode negative: ${t}`),t|~ce.SIGN_BIT}function zl(t){return at&&B(t%1==0&&t>=0&&t<=ce.MAX_INT,`Could not encode positive: ${t}`),~t}function Ul(t){return at&&B(t%1==0&&t<=0&&t>=~ce.MAX_INT,`Could not decode positive: ${t}`),~t}function Gl(t){return at&&B(t%1==0&&t>=0&&t<=ce.MAX_SMI,`Could not encode handle: ${t}`),t}function Rl(t){return at&&B(t%1==0&&t<=ce.MAX_SMI&&t>=0,`Could not decode handle: ${t}`),t}function jl(t){return(t|=0)<0?_l(t):zl(t)}function Jl(t){return(t|=0)>ce.SIGN_BIT?Ul(t):Vl(t)}[1,2,3].forEach(t=>Rl(Gl(t))),[1,-1].forEach(t=>Jl(jl(t)));let Q=Object.assign;const Kl=console,Ks=console;function Wl(t,e="unexpected unreachable branch"){throw Ks.log("unreachable",t),Ks.log(`${e} :: ${JSON.stringify(t)} (${t})`),new Error("code reached unreachable")}const he={Append:1,TrustingAppend:2,Comment:3,Modifier:4,StrictModifier:5,Block:6,StrictBlock:7,Component:8,OpenElement:10,OpenElementWithSplat:11,FlushElement:12,CloseElement:13,StaticAttr:14,DynamicAttr:15,ComponentAttr:16,AttrSplat:17,Yield:18,DynamicArg:20,StaticArg:21,TrustingDynamicAttr:22,TrustingComponentAttr:23,StaticComponentAttr:24,Debugger:26,Undefined:27,Call:28,Concat:29,GetSymbol:30,GetLexicalSymbol:32,GetStrictKeyword:31,GetFreeAsComponentOrHelperHeadOrThisFallback:34,GetFreeAsComponentOrHelperHead:35,GetFreeAsHelperHeadOrThisFallback:36,GetFreeAsDeprecatedHelperHeadOrThisFallback:99,GetFreeAsHelperHead:37,GetFreeAsModifierHead:38,GetFreeAsComponentHead:39,InElement:40,If:41,Each:42,With:43,Let:44,WithDynamicVars:45,InvokeComponent:46,HasBlock:48,HasBlockParams:49,Curry:50,Not:51,IfInline:52,GetDynamicVar:53,Log:54};var ve=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(ve||{});const wa=/["&\xA0]/u,Yl=new RegExp(wa.source,"gu"),va=/[&<>\xA0]/u,ql=new RegExp(va.source,"gu");function Xl(t){switch(t.charCodeAt(0)){case ve.NBSP:return"&nbsp;";case ve.QUOT:return"&quot;";case ve.AMP:return"&amp;";default:return t}}function Ql(t){switch(t.charCodeAt(0)){case ve.NBSP:return"&nbsp;";case ve.AMP:return"&amp;";case ve.LT:return"&lt;";case ve.GT:return"&gt;";default:return t}}function Sa(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const tr=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);function Zl(){return[...tr]}const ec=/^\S/u;function Ea(t){return tr.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class ms{buffer="";options;constructor(e){this.options=e}handledByOverride(e,r=!1){if(this.options.override!==void 0){let s=this.options.override(e,this.options);if(typeof s=="string")return r&&ec.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(e){switch(e.type){case"MustacheStatement":case"BlockStatement":case"PartialStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(e);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(e);case"Program":return this.Block(e);case"ConcatStatement":return this.ConcatStatement(e);case"Hash":return this.Hash(e);case"HashPair":return this.HashPair(e);case"ElementModifierStatement":return this.ElementModifierStatement(e)}}Expression(e){switch(e.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(e);case"PathExpression":return this.PathExpression(e);case"SubExpression":return this.SubExpression(e)}}Literal(e){switch(e.type){case"StringLiteral":return this.StringLiteral(e);case"BooleanLiteral":return this.BooleanLiteral(e);case"NumberLiteral":return this.NumberLiteral(e);case"UndefinedLiteral":return this.UndefinedLiteral(e);case"NullLiteral":return this.NullLiteral(e)}}TopLevelStatement(e){switch(e.type){case"MustacheStatement":return this.MustacheStatement(e);case"BlockStatement":return this.BlockStatement(e);case"PartialStatement":return this.PartialStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":return this.CommentStatement(e);case"TextNode":return this.TextNode(e);case"ElementNode":return this.ElementNode(e);case"Block":case"Template":return this.Block(e);case"AttrNode":return this.AttrNode(e)}}Block(e){e.chained&&(e.body[0].chained=!0),this.handledByOverride(e)||this.TopLevelStatements(e.body)}TopLevelStatements(e){e.forEach(r=>this.TopLevelStatement(r))}ElementNode(e){this.handledByOverride(e)||(this.OpenElementNode(e),this.TopLevelStatements(e.children),this.CloseElementNode(e))}OpenElementNode(e){this.buffer+=`<${e.tag}`;const r=[...e.attributes,...e.modifiers,...e.comments].sort(Sa);for(const s of r)switch(this.buffer+=" ",s.type){case"AttrNode":this.AttrNode(s);break;case"ElementModifierStatement":this.ElementModifierStatement(s);break;case"MustacheCommentStatement":this.MustacheCommentStatement(s)}e.blockParams.length&&this.BlockParams(e.blockParams),e.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(e){e.selfClosing||Ea(e.tag)||(this.buffer+=`</${e.tag}>`)}AttrNode(e){if(this.handledByOverride(e))return;let{name:r,value:s}=e;this.buffer+=r,(s.type!=="TextNode"||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(e){e.type==="TextNode"?(this.buffer+='"',this.TextNode(e,!0),this.buffer+='"'):this.Node(e)}TextNode(e,r){var s;this.handledByOverride(e)||(this.options.entityEncoding==="raw"?this.buffer+=e.chars:this.buffer+=r?(s=e.chars,wa.test(s)?s.replace(Yl,Xl):s):function(n){return va.test(n)?n.replace(ql,Ql):n}(e.chars))}MustacheStatement(e){this.handledByOverride(e)||(this.buffer+=e.escaped?"{{":"{{{",e.strip.open&&(this.buffer+="~"),this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.strip.close&&(this.buffer+="~"),this.buffer+=e.escaped?"}}":"}}}")}BlockStatement(e){this.handledByOverride(e)||(e.chained?(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=e.openStrip.open?"{{~#":"{{#",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.program.blockParams.length&&this.BlockParams(e.program.blockParams),e.chained?this.buffer+=e.inverseStrip.close?"~}}":"}}":this.buffer+=e.openStrip.close?"~}}":"}}",this.Block(e.program),e.inverse&&(e.inverse.chained||(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=e.inverseStrip.close?"~}}":"}}"),this.Block(e.inverse)),e.chained||(this.buffer+=e.closeStrip.open?"{{~/":"{{/",this.Expression(e.path),this.buffer+=e.closeStrip.close?"~}}":"}}"))}BlockParams(e){this.buffer+=` as |${e.join(" ")}|`}PartialStatement(e){this.handledByOverride(e)||(this.buffer+="{{>",this.Expression(e.name),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}ConcatStatement(e){this.handledByOverride(e)||(this.buffer+='"',e.parts.forEach(r=>{r.type==="TextNode"?this.TextNode(r,!0):this.Node(r)}),this.buffer+='"')}MustacheCommentStatement(e){this.handledByOverride(e)||(this.buffer+=`{{!--${e.value}--}}`)}ElementModifierStatement(e){this.handledByOverride(e)||(this.buffer+="{{",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}CommentStatement(e){this.handledByOverride(e)||(this.buffer+=`<!--${e.value}-->`)}PathExpression(e){this.handledByOverride(e)||(this.buffer+=e.original)}SubExpression(e){this.handledByOverride(e)||(this.buffer+="(",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+=")")}Params(e){e.length&&e.forEach(r=>{this.buffer+=" ",this.Expression(r)})}Hash(e){this.handledByOverride(e,!0)||e.pairs.forEach(r=>{this.buffer+=" ",this.HashPair(r)})}HashPair(e){this.handledByOverride(e)||(this.buffer+=e.key,this.buffer+="=",this.Node(e.value))}StringLiteral(e){this.handledByOverride(e)||(this.buffer+=JSON.stringify(e.value))}BooleanLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}NumberLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}UndefinedLiteral(e){this.handledByOverride(e)||(this.buffer+="undefined")}NullLiteral(e){this.handledByOverride(e)||(this.buffer+="null")}print(e){let{options:r}=this;if(r.override){let s=r.override(e,r);if(s!==void 0)return s}return this.buffer="",this.Node(e),this.buffer}}function Aa(t,e={entityEncoding:"transformed"}){return t?new ms(e).print(t):""}function Pa(t){return t in Ca}const Ca={component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],"link-to":["Append","Block"],log:["Call","Append"],modifier:["Call"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],"query-params":["Call"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],with:["Block"],yield:["Append"]},be=Object.freeze({line:1,column:0}),Na=Object.freeze({source:"(synthetic)",start:be,end:be}),vt=Object.freeze({source:"(nonexistent)",start:be,end:be}),Se=Object.freeze({source:"(broken)",start:be,end:be});let A=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const St="MATCH_ANY",Rr="IS_INVISIBLE";class tc{_whens;constructor(e){this._whens=e}first(e){for(const r of this._whens){const s=r.match(e);if(Y(s))return s[0]}return null}}class Ws{_map=new Map;get(e,r){let s=this._map.get(e);return s||(s=r(),this._map.set(e,s),s)}add(e,r){this._map.set(e,r)}match(e){const r=function(i){switch(i){case A.Broken:case A.InternalsSynthetic:case A.NonExistent:return Rr;default:return i}}(e),s=[],n=this._map.get(r),a=this._map.get(St);return n&&s.push(n),a&&s.push(a),s}}function xa(t){return t(new rc).check()}class rc{_whens=new Ws;check(){return(e,r)=>this.matchFor(e.kind,r.kind)(e,r)}matchFor(e,r){const s=this._whens.match(e);B(Y(s),`no match defined for (${e}, ${r}) and no AnyMatch defined either`);const n=new tc(s).first(r);return B(n!==null,`no match defined for (${e}, ${r}) and no AnyMatch defined either`),n}when(e,r,s){return this._whens.get(e,()=>new Ws).add(r,s),this}}const rr=!(typeof window<"u"&&window.location&&/[&?]disable_local_debug/u.test(window.location.search));class R{static synthetic(e){let r=D.synthetic(e);return new R({loc:r,chars:e})}static load(e,r){return new R({loc:D.load(e,r[1]),chars:r[0]})}chars;loc;constructor(e){this.loc=e.loc,this.chars=e.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class D{static get NON_EXISTENT(){return new He(A.NonExistent,vt).wrap()}static load(e,r){return typeof r=="number"?D.forCharPositions(e,r,r):typeof r=="string"?D.synthetic(r):Array.isArray(r)?D.forCharPositions(e,r[0],r[1]):r===A.NonExistent?D.NON_EXISTENT:r===A.Broken?D.broken(Se):void Wl(r)}static forHbsLoc(e,r){const s=new Ze(e,r.start),n=new Ze(e,r.end);return new bs(e,{start:s,end:n},r).wrap()}static forCharPositions(e,r,s){const n=new Et(e,r),a=new Et(e,s);return new fs(e,{start:n,end:a}).wrap()}static synthetic(e){return new He(A.InternalsSynthetic,vt,e).wrap()}static broken(e=Se){return new He(A.Broken,e).wrap()}isInvisible;constructor(e){this.data=e,this.isInvisible=e.kind!==A.CharPosition&&e.kind!==A.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const e=this.data.toHbsSpan();return e===null?Se:e.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(e){return ae(e.data,this.data.getEnd())}withEnd(e){return ae(this.data.getStart(),e.data)}asString(){return this.data.asString()}toSlice(e){const r=this.data.asString();return e!==void 0&&r!==e&&console.warn(`unexpectedly found ${JSON.stringify(r)} when slicing source, but expected ${JSON.stringify(e)}`),new R({loc:this,chars:e||r})}get start(){return this.loc.start}set start(e){this.data.locDidUpdate({start:e})}get end(){return this.loc.end}set end(e){this.data.locDidUpdate({end:e})}get source(){return this.module}collapse(e){switch(e){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(e){return ae(this.data.getStart(),e.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:e=0,skipEnd:r=0}){return ae(this.getStart().move(e).data,this.getEnd().move(-r).data)}sliceStartChars({skipStart:e=0,chars:r}){return ae(this.getStart().move(e).data,this.getStart().move(e+r).data)}sliceEndChars({skipEnd:e=0,chars:r}){return ae(this.getEnd().move(e-r).data,this.getStart().move(-e).data)}}class fs{kind=A.CharPosition;_locPosSpan=null;constructor(e,r){this.source=e,this.charPositions=r}wrap(){return new D(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){rr&&console.warn("updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase")}toHbsSpan(){let e=this._locPosSpan;if(e===null){const r=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();e=this._locPosSpan=r===null||s===null?Ne:new bs(this.source,{start:r,end:s})}return e===Ne?null:e}serialize(){const{start:{charPos:e},end:{charPos:r}}=this.charPositions;return e===r?e:[e,r]}toCharPosSpan(){return this}}class bs{kind=A.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(e,r,s=null){this.source=e,this.hbsPositions=r,this._providedHbsLoc=s}serialize(){const e=this.toCharPosSpan();return e===null?A.Broken:e.wrap().serialize()}wrap(){return new D(this)}updateProvided(e,r){this._providedHbsLoc&&(this._providedHbsLoc[r]=e),this._charPosSpan=null,this._providedHbsLoc={start:e,end:e}}locDidUpdate({start:e,end:r}){e!==void 0&&(this.updateProvided(e,"start"),this.hbsPositions.start=new Ze(this.source,e,null)),r!==void 0&&(this.updateProvided(r,"end"),this.hbsPositions.end=new Ze(this.source,r,null))}asString(){const e=this.toCharPosSpan();return e===null?"":e.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let e=this._charPosSpan;if(e===null){const r=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!r||!s)return e=this._charPosSpan=Ne,null;e=this._charPosSpan=new fs(this.source,{start:r,end:s})}return e===Ne?null:e}}class He{constructor(e,r,s=null){this.kind=e,this.loc=r,this.string=s}serialize(){switch(this.kind){case A.Broken:case A.NonExistent:return this.kind;case A.InternalsSynthetic:return this.string||""}}wrap(){return new D(this)}asString(){return this.string||""}locDidUpdate({start:e,end:r}){e!==void 0&&(this.loc.start=e),r!==void 0&&(this.loc.end=r)}getModule(){return"an unknown module"}getStart(){return new jr(this.kind,this.loc.start)}getEnd(){return new jr(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return Se}}const ae=xa(t=>t.when(A.HbsPosition,A.HbsPosition,(e,r)=>new bs(e.source,{start:e,end:r}).wrap()).when(A.CharPosition,A.CharPosition,(e,r)=>new fs(e.source,{start:e,end:r}).wrap()).when(A.CharPosition,A.HbsPosition,(e,r)=>{const s=r.toCharPos();return s===null?new He(A.Broken,Se).wrap():ae(e,s)}).when(A.HbsPosition,A.CharPosition,(e,r)=>{const s=e.toCharPos();return s===null?new He(A.Broken,Se).wrap():ae(s,r)}).when(Rr,St,e=>new He(e.kind,Se).wrap()).when(St,Rr,(e,r)=>new He(r.kind,Se).wrap())),Ne="BROKEN";class xe{static forHbsPos(e,r){return new Ze(e,r,null).wrap()}static broken(e=be){return new jr(A.Broken,e).wrap()}constructor(e){this.data=e}get offset(){const e=this.data.toCharPos();return e===null?null:e.offset}eql(e){return sc(this.data,e.data)}until(e){return ae(this.data,e.data)}move(e){const r=this.data.toCharPos();if(r===null)return xe.broken();{const s=r.offset+e;return r.source.check(s)?new Et(r.source,s).wrap():xe.broken()}}collapsed(){return ae(this.data,this.data)}toJSON(){return this.data.toJSON()}}class Et{kind=A.CharPosition;_locPos=null;constructor(e,r){this.source=e,this.charPos=r}toCharPos(){return this}toJSON(){const e=this.toHbsPos();return e===null?be:e.toJSON()}wrap(){return new xe(this)}get offset(){return this.charPos}toHbsPos(){let e=this._locPos;if(e===null){const r=this.source.hbsPosFor(this.charPos);this._locPos=e=r===null?Ne:new Ze(this.source,r,this.charPos)}return e===Ne?null:e}}class Ze{kind=A.HbsPosition;_charPos;constructor(e,r,s=null){this.source=e,this.hbsPos=r,this._charPos=s===null?null:new Et(e,s)}toCharPos(){let e=this._charPos;if(e===null){const r=this.source.charPosFor(this.hbsPos);this._charPos=e=r===null?Ne:new Et(this.source,r)}return e===Ne?null:e}toJSON(){return this.hbsPos}wrap(){return new xe(this)}toHbsPos(){return this}}class jr{constructor(e,r){this.kind=e,this.pos=r}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new xe(this)}get offset(){return null}}const sc=xa(t=>t.when(A.HbsPosition,A.HbsPosition,({hbsPos:e},{hbsPos:r})=>e.column===r.column&&e.line===r.line).when(A.CharPosition,A.CharPosition,({charPos:e},{charPos:r})=>e===r).when(A.CharPosition,A.HbsPosition,({offset:e},r)=>e===r.toCharPos()?.offset).when(A.HbsPosition,A.CharPosition,(e,{offset:r})=>e.toCharPos()?.offset===r).when(St,St,()=>!1));class Ee{static from(e,r={}){return new Ee(e,r.meta?.moduleName)}constructor(e,r="an unknown module"){this.source=e,this.module=r}check(e){return e>=0&&e<=this.source.length}slice(e,r){return this.source.slice(e,r)}offsetFor(e,r){return xe.forHbsPos(this,{line:e,column:r})}spanFor({start:e,end:r}){return D.forHbsLoc(this,{start:{line:e.line,column:e.column},end:{line:r.line,column:r.column}})}hbsPosFor(e){let r=0,s=0;if(e>this.source.length)return null;for(;;){let n=this.source.indexOf(`
`,s);if(e<=n||n===-1)return{line:r+1,column:e-s};r+=1,s=n+1}}charPosFor(e){let{line:r,column:s}=e,n=this.source.length,a=0,i=0;for(;i<n;){let o=this.source.indexOf(`
`,i);if(o===-1&&(o=this.source.length),a===r-1){if(i+s>o)return o;{let l=this.hbsPosFor(i+s);B(l!==null,"the returned offset failed to round-trip"),B(l.line===r,"the round-tripped line didn't match the original line"),B(l.column===s,"the round-tripped column didn't match the original column")}return i+s}if(o===-1)return 0;a+=1,i=o+1}return n}}class re{static range(e,r=D.NON_EXISTENT){return new re(e.map(et)).getRangeOffset(r)}_span;constructor(e=[]){this._span=e}add(e){this._span.push(e)}getRangeOffset(e){if(Y(this._span)){let r=wt(this._span),s=Bt(this._span);return r.extend(s)}return e}}function et(t){if(Array.isArray(t)){let e=wt(t),r=Bt(t);return et(e).extend(et(r))}return t instanceof D?t:t.loc}function gs(t){return!Array.isArray(t)||t.length!==0}function Ta(t,e){return gs(t)?et(t):e}var nc=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:vt,SYNTHETIC_LOCATION:Na,Source:Ee,SourceOffset:xe,SourceSlice:R,SourceSpan:D,SpanList:re,UNKNOWN_POSITION:be,hasSpan:gs,loc:et,maybeLoc:Ta});function y(t,e){let{module:r,loc:s}=e,{line:n,column:a}=s.start,i=e.asString(),o=i?`

|
|  ${i.split(`
`).join(`
|  `)}
|

`:"",l=new Error(`${t}: ${o}(error occurred in '${r}' @ line ${n} : column ${a})`);return l.name="SyntaxError",l.location=e,l.code=i,l}const Ba={Program:["body"],Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],PartialStatement:["name","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],ElementStartNode:[],ElementPartNode:[],ElementEndNode:[],ElementNameNode:[],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],PathHead:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"],BlockParam:[],NamedBlock:["attributes","modifiers","children","comments"],SimpleElement:["attributes","modifiers","children","comments"],Component:["head","attributes","modifiers","children","comments"]},ks=function(){function t(e,r,s,n){let a=Error.call(this,e);this.key=n,this.message=e,this.node=r,this.parent=s,a.stack&&(this.stack=a.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function Jr(t,e,r){return new ks("Cannot remove a node unless it is part of an array",t,e,r)}function La(t,e,r){return new ks("Cannot replace a node with multiple nodes unless it is part of an array",t,e,r)}function Ys(t,e){return new ks("Replacing and removing in key handlers is not yet supported.",t,null,e)}class Lt{node;parent;parentKey;constructor(e,r=null,s=null){this.node=e,this.parent=r,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new ac(this)}}}class ac{path;constructor(e){this.path=e}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function $a(t){return typeof t=="function"?t:t.enter}function Ha(t){return typeof t=="function"?void 0:t.exit}function ur(t,e){let r,s,n,{node:a,parent:i,parentKey:o}=e,l=function(c,h){if((h==="Template"||h==="Block")&&c.Program)return rr&&Gr(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${h}') `),c.Program;let d=c[h];return d!==void 0?d:c.All}(t,a.type);if(l!==void 0&&(r=$a(l),s=Ha(l)),r!==void 0&&(n=r(a,e)),n!=null){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(Oa(t,n,i,o),n):ur(t,new Lt(n,i,o))||n;n=void 0}if(n===void 0){let c=Ba[a.type];for(let h=0;h<c.length;h++)ic(t,l,e,c[h]);s!==void 0&&(n=s(a,e))}return n}function qs(t,e,r){t[e]=r}function ic(t,e,r,s){let n,a,{node:i}=r,o=function(l,c){return l[c]}(i,s);if(o){if(e!==void 0){let l=function(c,h){let d=typeof c!="function"?c.keys:void 0;if(d===void 0)return;let m=d[h];return m!==void 0?m:d.All}(e,s);l!==void 0&&(n=$a(l),a=Ha(l))}if(n!==void 0&&n(i,s)!==void 0)throw Ys(i,s);if(Array.isArray(o))Oa(t,o,r,s);else{let l=ur(t,new Lt(o,r,s));l!==void 0&&function(c,h,d,m){if(m===null)throw Jr(d,c,h);if(Array.isArray(m)){if(m.length!==1)throw m.length===0?Jr(d,c,h):La(d,c,h);qs(c,h,m[0])}else qs(c,h,m)}(i,s,o,l)}if(a!==void 0&&a(i,s)!==void 0)throw Ys(i,s)}}function Oa(t,e,r,s){for(let n=0;n<e.length;n++){let a=pe(e[n]),i=ur(t,new Lt(a,r,s));i!==void 0&&(n+=oc(e,n,i)-1)}}function oc(t,e,r){return r===null?(t.splice(e,1),0):Array.isArray(r)?(t.splice(e,1,...r),r.length):(t.splice(e,1,r),1)}function hr(t,e){ur(e,new Lt(t))}class Kr{stack=[];constructor(e){this.order=e}visit(e,r){e&&(this.stack.push(e),this.order==="post"?(this.children(e,r),r(e,this)):(r(e,this),this.children(e,r)),this.stack.pop())}children(e,r){switch(e.type){case"Block":case"Template":return Ar.Program(this,e,r);case"ElementNode":return Ar.ElementNode(this,e,r);case"BlockStatement":return Ar.BlockStatement(this,e,r);default:return}}}const Ar={Program(t,e,r){It(t,e.body,r)},Template(t,e,r){It(t,e.body,r)},Block(t,e,r){It(t,e.body,r)},ElementNode(t,e,r){It(t,e.children,r)},BlockStatement(t,e,r){t.visit(e.program,r),t.visit(e.inverse||null,r)}};function It(t,e,r){for(const s of e)t.visit(s,r)}let Pr,lc=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;function cc(t){let e=function(r){let s=r.attributes.length,n=[];for(let i=0;i<s;i++)n.push(pe(r.attributes[i]).name);let a=n.indexOf("as");if(a===-1&&n.length>0&&pe(n[n.length-1]).charAt(0)==="|")throw y("Block parameters must be preceded by the `as` keyword, detected block parameters without `as`",r.loc);if(a!==-1&&s>a&&pe(n[a+1]).charAt(0)==="|"){let i=n.slice(a).join(" ");if(i.charAt(i.length-1)!=="|"||ya(i.match(/\|/gu),"block params must exist here").length!==2)throw y("Invalid block parameters syntax, '"+i+"'",r.loc);let o=[];for(let l=a+1;l<s;l++){let c=pe(n[l]).replace(/\|/gu,"");if(c!==""){if(lc.test(c))throw y("Invalid identifier for block parameters, '"+c+"'",r.loc);let h=r.attributes[l].loc;n[l].startsWith("|")&&(h=h.slice({skipStart:1})),n[l].endsWith("|")&&(h=h.slice({skipEnd:1})),h.endPosition.column-h.startPosition.column>c.length&&(h=h.slice({skipEnd:h.endPosition.column-h.startPosition.column-c.length})),o.push({type:"BlockParam",value:c,loc:h})}}if(o.length===0)throw y("Cannot use zero block parameters",r.loc);return r.attributes=r.attributes.slice(0,a),o}return null}(t);e&&(t.blockParamNodes=e,t.blockParams=e.map(r=>r.value))}function Ke(t,e){(function(r){switch(r.type){case"Block":case"Template":return r.body;case"ElementNode":return r.children}})(t).push(e)}function Ia(t){return t.type==="StringLiteral"||t.type==="BooleanLiteral"||t.type==="NumberLiteral"||t.type==="NullLiteral"||t.type==="UndefinedLiteral"}function Cr(){return Pr||(Pr=new Ee("","(synthetic)")),Pr}function Ma(t){switch(t.type){case"AtHead":case"VarHead":return{original:t.name,parts:[t.name]};case"ThisHead":return{original:"this",parts:[]}}}function Xs(t,e){let r,[s,...n]=cr(t.split("."));return r=s==="this"?{type:"ThisHead",loc:H(e||null)}:s[0]==="@"?{type:"AtHead",name:s,loc:H(e||null)}:{type:"VarHead",name:s,loc:H(e||null)},{head:r,tail:n}}function Qs(t){return{type:"ThisHead",loc:H(t||null)}}function Zs(t,e){return B(t[0]==="@","call builders.at() with a string that starts with '@'"),{type:"AtHead",name:t,loc:H(e||null)}}function en(t,e){return B(t!=="this","You called builders.var() with 'this'. Call builders.this instead"),B(t[0]!=="@",`You called builders.var() with '${t}'. Call builders.at('${t}') instead`),{type:"VarHead",name:t,loc:H(e||null)}}function lt(t,e){if(typeof t!="string"){if("type"in t)return t;{let{head:n,tail:a}=Xs(t.head,D.broken());B(a.length===0,"builder.path({ head, tail }) should not be called with a head with dots in it");let{original:i}=Ma(n);return new At([i,...a].join("."),n,a,H(e||null))}}let{head:r,tail:s}=Xs(t,D.broken());return new At(t,r,s,H(e||null))}function _t(t,e,r){return{type:t,value:e,original:e,loc:H(r||null)}}function Ve(t,e){return{type:"Hash",pairs:t||[],loc:H(e||null)}}function H(...t){if(t.length===1){let e=t[0];return e&&typeof e=="object"?D.forHbsLoc(Cr(),e):D.forHbsLoc(Cr(),Na)}{let[e,r,s,n,a]=t,i=a?new Ee("",a):Cr();return D.forHbsLoc(i,{start:{line:e,column:r},end:{line:s,column:n}})}}var ys={mustache:function(t,e,r,s,n,a){return typeof t=="string"&&(t=lt(t)),{type:"MustacheStatement",path:t,params:e||[],hash:r||Ve([]),escaped:!s,trusting:!!s,loc:H(n||null),strip:a||{open:!1,close:!1}}},block:function(t,e,r,s,n,a,i,o,l){let c,h;return s.type==="Template"?(rr&&Gr("b.program is deprecated. Use b.blockItself instead."),c=Q({},s,{type:"Block"})):c=s,n!=null&&n.type==="Template"?(rr&&Gr("b.program is deprecated. Use b.blockItself instead."),h=Q({},n,{type:"Block"})):h=n,{type:"BlockStatement",path:lt(t),params:e||[],hash:r||Ve([]),program:c||null,inverse:h||null,loc:H(a||null),openStrip:i||{open:!1,close:!1},inverseStrip:o||{open:!1,close:!1},closeStrip:l||{open:!1,close:!1}}},partial:function(t,e,r,s,n){return{type:"PartialStatement",name:t,params:e||[],hash:r||Ve([]),indent:s||"",strip:{open:!1,close:!1},loc:H(n||null)}},comment:function(t,e){return{type:"CommentStatement",value:t,loc:H(e||null)}},mustacheComment:function(t,e){return{type:"MustacheCommentStatement",value:t,loc:H(e||null)}},element:function(t,e={}){let r,{attrs:s,blockParams:n,modifiers:a,comments:i,children:o,loc:l}=e,c=!1;return typeof t=="object"?(c=t.selfClosing,r=t.name):t.slice(-1)==="/"?(r=t.slice(0,-1),c=!0):r=t,{type:"ElementNode",tag:r,nameNode:{type:"ElementNameNode",value:t},startTag:{type:"ElementStartNode",value:t},endTag:{type:"ElementEndNode",value:c?"":t},parts:r.split(".").map(h=>({type:"ElementPartNode",value:h})),selfClosing:c,attributes:s||[],blockParams:n||[],blockParamNodes:n?.map(h=>({type:"BlockParam",value:h}))||[],modifiers:a||[],comments:i||[],children:o||[],loc:H(l||null)}},elementModifier:function(t,e,r,s){return{type:"ElementModifierStatement",path:lt(t),params:e||[],hash:r||Ve([]),loc:H(s||null)}},attr:function(t,e,r){return{type:"AttrNode",name:t,value:e,loc:H(r||null)}},text:function(t,e){return{type:"TextNode",chars:t||"",loc:H(e||null)}},sexpr:function(t,e,r,s){return{type:"SubExpression",path:lt(t),params:e||[],hash:r||Ve([]),loc:H(s||null)}},concat:function(t,e){if(!Y(t))throw new Error("b.concat requires at least one part");return{type:"ConcatStatement",parts:t||[],loc:H(e||null)}},hash:Ve,pair:function(t,e,r){return{type:"HashPair",key:t,value:e,loc:H(r||null)}},literal:_t,program:function(t,e,r){return{type:"Template",body:t||[],blockParams:e||[],loc:H(r||null)}},blockItself:function(t,e,r=!1,s){return{type:"Block",body:t||[],blockParams:e||[],blockParamNodes:e?.map(n=>({type:"BlockParam",value:n}))||[],chained:r,loc:H(s||null)}},template:function(t,e,r){return{type:"Template",body:t||[],blockParams:e||[],loc:H(r||null)}},loc:H,pos:function(t,e){return{line:t,column:e}},path:lt,fullPath:function(t,e,r){let{original:s,parts:n}=Ma(t),a=[...s,...n,...e].join(".");return new At(a,t,e,H(r||null))},head:function(t,e){return t[0]==="@"?Zs(t,e):t==="this"?Qs(e):en(t,e)},at:Zs,var:en,this:Qs,blockName:function(t,e){return{type:"NamedBlockName",name:t,loc:H(e||null)}},string:Nr("StringLiteral"),boolean:Nr("BooleanLiteral"),number:Nr("NumberLiteral"),undefined:()=>_t("UndefinedLiteral",void 0),null:()=>_t("NullLiteral",null)};function Nr(t){return function(e,r){return _t(t,e,r)}}class At{type="PathExpression";parts;this=!1;data=!1;constructor(e,r,s,n){this.original=e,this.loc=n;let a=s.slice();r.type==="ThisHead"?this.this=!0:r.type==="AtHead"?(this.data=!0,a.unshift(r.name.slice(1))):a.unshift(r.name),this.parts=a}_head=void 0;get head(){if(this._head)return this._head;let e;this.this?e="this":this.data?e=`@${wt(cr(this.parts))}`:(yt(this.parts),e=wt(this.parts));let r=this.loc.collapse("start").sliceStartChars({chars:e.length}).loc;return this._head=ys.head(e,r)}get tail(){return this.this?this.parts:this.parts.slice(1)}}const Mt={close:!1,open:!1};var O=new class{pos(t,e){return{line:t,column:e}}blockItself({body:t=[],blockParams:e=[],chained:r=!1,loc:s}){return{type:"Block",body:t,blockParams:e,blockParamNodes:e?.map(n=>({type:"BlockParam",value:n})),chained:r,loc:s}}template({body:t,blockParams:e,loc:r}){return{type:"Template",body:t||[],blockParams:e||[],loc:r}}mustache({path:t,params:e,hash:r,trusting:s,loc:n,strip:a=Mt}){return{type:"MustacheStatement",path:t,params:e,hash:r,escaped:!s,trusting:s,loc:n,strip:a||{open:!1,close:!1}}}block({path:t,params:e,hash:r,defaultBlock:s,elseBlock:n=null,loc:a,openStrip:i=Mt,inverseStrip:o=Mt,closeStrip:l=Mt}){return{type:"BlockStatement",path:t,params:e,hash:r,program:s,inverse:n,loc:a,openStrip:i,inverseStrip:o,closeStrip:l}}comment(t,e){return{type:"CommentStatement",value:t,loc:e}}mustacheComment(t,e){return{type:"MustacheCommentStatement",value:t,loc:e}}concat(t,e){return{type:"ConcatStatement",parts:t,loc:e}}element({tag:t,selfClosing:e,attrs:r,blockParams:s,modifiers:n,comments:a,children:i,loc:o}){return{type:"ElementNode",tag:t,nameNode:{type:"ElementNameNode",value:t},startTag:{type:"ElementStartNode",value:t},endTag:{type:"ElementEndNode",value:e?"":t},parts:t.split(".").map(l=>({type:"ElementPartNode",value:l})),selfClosing:e,attributes:r||[],blockParams:s,blockParamNodes:s.map(l=>({type:"BlockParam",value:l}))||[],modifiers:n||[],comments:a||[],children:i||[],loc:o}}elementModifier({path:t,params:e,hash:r,loc:s}){return{type:"ElementModifierStatement",path:t,params:e,hash:r,loc:s}}attr({name:t,value:e,loc:r}){return{type:"AttrNode",name:t,value:e,loc:r}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:r,loc:s}){return{type:"SubExpression",path:t,params:e,hash:r,loc:s}}path({head:t,tail:e,loc:r}){let{original:s}=function(a){switch(a.type){case"AtHead":case"VarHead":return{original:a.name,parts:[a.name]};case"ThisHead":return{original:"this",parts:[]}}}(t),n=[...s,...e].join(".");return new At(n,t,e,r)}head(t,e){return t[0]==="@"?this.atName(t,e):t==="this"?this.this(e):this.var(t,e)}this(t){return{type:"ThisHead",loc:t}}atName(t,e){return B(t[0]==="@","call builders.at() with a string that starts with '@'"),{type:"AtHead",name:t,loc:e}}var(t,e){return B(t!=="this","You called builders.var() with 'this'. Call builders.this instead"),B(t[0]!=="@",`You called builders.var() with '${t}'. Call builders.at('${t}') instead`),{type:"VarHead",name:t,loc:e}}hash(t,e){return{type:"Hash",pairs:t||[],loc:e}}pair({key:t,value:e,loc:r}){return{type:"HashPair",key:t,value:e,loc:r}}literal({type:t,value:e,loc:r}){return{type:t,value:e,original:e,loc:r}}undefined(){return this.literal({type:"UndefinedLiteral",value:void 0})}null(){return this.literal({type:"NullLiteral",value:null})}string(t,e){return this.literal({type:"StringLiteral",value:t,loc:e})}boolean(t,e){return this.literal({type:"BooleanLiteral",value:t,loc:e})}number(t,e){return this.literal({type:"NumberLiteral",value:t,loc:e})}};class uc{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(e,r=new sr(ln),s="precompile"){this.source=e,this.lines=e.source.split(/\r\n?|\n/u),this.tokenizer=new on(this,r,s)}offset(){let{line:e,column:r}=this.tokenizer;return this.source.offsetFor(e,r)}pos({line:e,column:r}){return this.source.offsetFor(e,r)}finish(e){return Q({},e,{loc:e.loc.until(this.offset())})}get currentAttr(){return ya(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return B(e&&(e.type==="StartTag"||e.type==="EndTag"),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return B(e&&e.type==="StartTag","expected start tag"),e}get currentEndTag(){let e=this.currentNode;return B(e&&e.type==="EndTag","expected end tag"),e}get currentComment(){let e=this.currentNode;return B(e&&e.type==="CommentStatement","expected a comment"),e}get currentData(){let e=this.currentNode;return B(e&&e.type==="TextNode","expected a text node"),e}acceptTemplate(e){return this[e.type](e)}acceptNode(e){return this[e.type](e)}currentElement(){return Bt(cr(this.elementStack))}sourceForNode(e,r){let s,n,a,i=e.loc.start.line-1,o=i-1,l=e.loc.start.column,c=[];for(r?(n=r.loc.end.line-1,a=r.loc.end.column):(n=e.loc.end.line-1,a=e.loc.end.column);o<n;)o++,s=pe(this.lines[o]),o===i?i===n?c.push(s.slice(l,a)):c.push(s.slice(l)):o===n?c.push(s.slice(0,a)):c.push(s);return c.join(`
`)}}const tn="beforeAttributeName";class hc extends uc{get isTopLevel(){return this.elementStack.length===0}Program(e){const r=[];let s;s=this.isTopLevel?O.template({body:r,blockParams:e.blockParams,loc:this.source.spanFor(e.loc)}):O.blockItself({body:r,blockParams:e.blockParams,chained:e.chained,loc:this.source.spanFor(e.loc)});let n,a=e.body.length;if(this.elementStack.push(s),a===0)return this.elementStack.pop();for(n=0;n<a;n++)this.acceptNode(pe(e.body[n]));const i=this.elementStack.pop();if(i!==s){const o=i;throw y(`Unclosed element \`${o.tag}\``,o.loc)}return s}BlockStatement(e){if(this.tokenizer.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));if(this.tokenizer.state!=="data"&&this.tokenizer.state!=="beforeData")throw y("A block may only be used inside an HTML element or another block.",this.source.spanFor(e.loc));const{path:r,params:s,hash:n}=xr(this,e);e.program.loc||(e.program.loc=vt),e.inverse&&!e.inverse.loc&&(e.inverse.loc=vt);const a=this.Program(e.program),i=e.inverse?this.Program(e.inverse):null,o=O.block({path:r,params:s,hash:n,defaultBlock:a,elseBlock:i,loc:this.source.spanFor(e.loc),openStrip:e.openStrip,inverseStrip:e.inverseStrip,closeStrip:e.closeStrip});(function(l,c){const h=[c.loc.getStart().offset,c.loc.getEnd().offset];let d=l.slice(...h),m=h[0],g=d.indexOf("|")+1;m+=g,d=d.slice(g,-1),g=d.indexOf("|"),d=d.slice(0,g);for(const v of c.program.blockParamNodes){const F=[m+new RegExp(`\\b${v.value}\\b`).exec(d).index,0];F[1]=F[0]+v.value.length,v.loc=l.spanFor({start:l.hbsPosFor(F[0]),end:l.hbsPosFor(F[1])})}})(this.source,o),Ke(this.currentElement(),o)}MustacheStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));let s;const{escaped:n,loc:a,strip:i}=e;if(Ia(e.path))s=O.mustache({path:this.acceptNode(e.path),params:[],hash:O.hash([],this.source.spanFor(e.path.loc).collapse("end")),trusting:!n,loc:this.source.spanFor(a),strip:i});else{const{path:o,params:l,hash:c}=xr(this,e);s=O.mustache({path:o,params:l,hash:c,trusting:!n,loc:this.source.spanFor(a),strip:i})}switch(r.state){case"tagOpen":case"tagName":throw y("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":Tr(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),Tr(this.currentStartTag,s),r.transitionTo(tn);break;case"afterAttributeValueQuoted":Tr(this.currentStartTag,s),r.transitionTo(tn);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),r.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:Ke(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(e){this.finalizeTextPart();const r=this.currentAttr;r.isDynamic=!0,r.parts.push(e)}finalizeTextPart(){const e=this.currentAttr.currentPart;e!==null&&(this.currentAttr.parts.push(e),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(e){(function(r,s){let n=s.loc.start.line,a=s.loc.start.column;const i=function(o,l){if(l==="")return{lines:o.split(`
`).length-1,columns:0};const[c]=o.split(l),h=c.split(/\n/u),d=h.length-1;return{lines:d,columns:pe(h[d]).length}}(s.original,s.value);n+=i.lines,i.lines?a=i.columns:a+=i.columns,r.line=n,r.column=a})(this.tokenizer,e),this.tokenizer.tokenizePart(e.value),this.tokenizer.flushData()}CommentStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return this.appendToCommentData(this.sourceForNode(e)),null;const{value:s,loc:n}=e,a=O.mustacheComment(s,this.source.spanFor(n));switch(r.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(a);break;case"beforeData":case"data":Ke(this.currentElement(),a);break;default:throw y(`Using a Handlebars comment when in the \`${r.state}\` state is not supported`,this.source.spanFor(e.loc))}return a}PartialStatement(e){throw y("Handlebars partials are not supported",this.source.spanFor(e.loc))}PartialBlockStatement(e){throw y("Handlebars partial blocks are not supported",this.source.spanFor(e.loc))}Decorator(e){throw y("Handlebars decorators are not supported",this.source.spanFor(e.loc))}DecoratorBlock(e){throw y("Handlebars decorator blocks are not supported",this.source.spanFor(e.loc))}SubExpression(e){const{path:r,params:s,hash:n}=xr(this,e);return O.sexpr({path:r,params:s,hash:n,loc:this.source.spanFor(e.loc)})}PathExpression(e){const{original:r}=e;let s;if(r.indexOf("/")!==-1){if(r.slice(0,2)==="./")throw y('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(e.loc));if(r.slice(0,3)==="../")throw y('Changing context using "../" is not supported in Glimmer',this.source.spanFor(e.loc));if(r.indexOf(".")!==-1)throw y("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(e.loc));s=[e.parts.join("/")]}else{if(r===".")throw y("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(e.loc));s=e.parts}let n,a=!1;if(/^this(?:\..+)?$/u.test(r)&&(a=!0),a)n={type:"ThisHead",loc:{start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+4}}};else if(e.data){const i=s.shift();if(i===void 0)throw y("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(e.loc));n={type:"AtHead",name:`@${i}`,loc:{start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length+1}}}}else{const i=s.shift();if(i===void 0)throw y("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(e.loc));n={type:"VarHead",name:i,loc:{start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length}}}}return new At(e.original,n,s,this.source.spanFor(e.loc))}Hash(e){const r=e.pairs.map(s=>O.pair({key:s.key,value:this.acceptNode(s.value),loc:this.source.spanFor(s.loc)}));return O.hash(r,this.source.spanFor(e.loc))}StringLiteral(e){return O.literal({type:"StringLiteral",value:e.value,loc:e.loc})}BooleanLiteral(e){return O.literal({type:"BooleanLiteral",value:e.value,loc:e.loc})}NumberLiteral(e){return O.literal({type:"NumberLiteral",value:e.value,loc:e.loc})}UndefinedLiteral(e){return O.literal({type:"UndefinedLiteral",value:void 0,loc:e.loc})}NullLiteral(e){return O.literal({type:"NullLiteral",value:null,loc:e.loc})}}function xr(t,e){if(e.path.type.endsWith("Literal")){const a=e.path;let i="";throw i=a.type==="BooleanLiteral"?a.original.toString():a.type==="StringLiteral"?`"${a.original}"`:a.type==="NullLiteral"?"null":a.type==="NumberLiteral"?a.value.toString():"undefined",y(`${a.type} "${a.type==="StringLiteral"?a.original:i}" cannot be called as a sub-expression, replace (${i}) with ${i}`,t.source.spanFor(a.loc))}const r=e.path.type==="PathExpression"?t.PathExpression(e.path):t.SubExpression(e.path),s=e.params?e.params.map(a=>t.acceptNode(a)):[],n=Y(s)?Bt(s).loc:r.loc;return{path:r,params:s,hash:e.hash?t.Hash(e.hash):{type:"Hash",pairs:[],loc:t.source.spanFor(n).collapse("end")}}}function Tr(t,e){const{path:r,params:s,hash:n,loc:a}=e;if(Ia(r)){const o=`{{${function(l){return l.type==="UndefinedLiteral"?"undefined":JSON.stringify(l.value)}(r)}}}`;throw y(`In ${`<${t.name} ... ${o} ...`}, ${o} is not a valid modifier`,e.loc)}const i=O.elementModifier({path:r,params:s,hash:n,loc:a});t.modifiers.push(i)}class pc extends hc{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode=O.comment("",this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn))}appendToCommentData(e){this.currentComment.value+=e}finishComment(){Ke(this.currentElement(),this.finish(this.currentComment))}beginData(){this.currentNode=O.text({chars:"",loc:this.offset().collapsed()})}appendToData(e){this.currentData.chars+=e}finishData(){this.currentData.loc=this.currentData.loc.withEnd(this.offset()),Ke(this.currentElement(),this.currentData)}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",attributes:[],modifiers:[],comments:[],selfClosing:!1,loc:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",attributes:[],modifiers:[],comments:[],selfClosing:!1,loc:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let e=this.finish(this.currentTag);if(e.type==="StartTag"){if(this.finishStartTag(),e.name===":")throw y("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.loc.toJSON(),end:this.offset().toJSON()}));(tr.has(e.name)||e.selfClosing)&&this.finishEndTag(!0)}else e.type==="EndTag"&&this.finishEndTag(!1)}finishStartTag(){let{name:e,attributes:r,modifiers:s,comments:n,selfClosing:a,loc:i}=this.finish(this.currentStartTag),o=O.element({tag:e,selfClosing:a,attrs:r,modifiers:s,comments:n,children:[],blockParams:[],loc:i});o.startTag={type:"ElementStartNode",value:e,loc:i},o.nameNode={type:"ElementNameNode",value:e,loc:i.withStart(this.source.offsetFor(i.startPosition.line,i.startPosition.column+1)).withEnd(this.source.offsetFor(i.startPosition.line,i.startPosition.column+1+e.length))},function(l,c){const h=[c.loc.getStart().offset,c.loc.getEnd().offset];let d=h[0],m=l.slice(...h);for(const g of c.parts){const v=[d+m.indexOf(g.value),0];v[1]=v[0]+g.value.length,m=l.slice(v[1],h[1]),d=v[1],g.loc=l.spanFor({start:l.hbsPosFor(v[0]),end:l.hbsPosFor(v[1])})}}(this.source,o),this.elementStack.push(o)}finishEndTag(e){let r=this.finish(this.currentTag),s=this.elementStack.pop();s.endTag={type:"ElementEndNode",loc:r.loc,value:s.selfClosing?"":r.name},this.validateEndTag(r,s,e);let n=this.currentElement();s.loc=s.loc.withEnd(this.offset()),cc(s),Ke(n,s)}markTagAsSelfClosing(){this.currentTag.selfClosing=!0}appendToTagName(e){this.currentTag.name+=e}beginAttribute(){let e=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:e,valueSpan:e.collapsed()}}appendToAttributeName(e){this.currentAttr.name+=e}beginAttributeValue(e){this.currentAttr.isQuoted=e,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(e){let r=this.currentAttr.parts,s=r[r.length-1],n=this.currentAttr.currentPart;if(n)n.chars+=e,n.loc=n.loc.withEnd(this.offset());else{let a=this.offset();a=e===`
`?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():a.move(-1),this.currentAttr.currentPart=O.text({chars:e,loc:a.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let e=this.currentTag,r=this.offset();if(e.type==="EndTag")throw y("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:e.loc.toJSON(),end:r.toJSON()}));let{name:s,parts:n,start:a,isQuoted:i,isDynamic:o,valueSpan:l}=this.currentAttr,c=this.assembleAttributeValue(n,i,o,a.until(r));c.loc=l.withEnd(r);let h=O.attr({name:s,value:c,loc:a.until(r)});this.currentStartTag.attributes.push(h)}reportSyntaxError(e){throw y(e,this.offset().collapsed())}assembleConcatenatedValue(e){for(const n of e)if(n.type!=="MustacheStatement"&&n.type!=="TextNode")throw y(`Unsupported node in quoted attribute value: ${n.type}`,n.loc);yt(e,"the concatenation parts of an element should not be empty");let r=wt(e),s=Bt(e);return O.concat(e,this.source.spanFor(r.loc).extend(this.source.spanFor(s.loc)))}validateEndTag(e,r,s){if(tr.has(e.name)&&!s)throw y(`<${e.name}> elements do not need end tags. You should remove it`,e.loc);if(r.tag===void 0)throw y(`Closing tag </${e.name}> without an open tag`,e.loc);if(r.tag!==e.name)throw y(`Closing tag </${e.name}> did not match last open tag <${r.tag}> (on line ${r.loc.startPosition.line})`,e.loc)}assembleAttributeValue(e,r,s,n){if(s){if(r)return this.assembleConcatenatedValue(e);{yt(e);const[a,i]=e;if(i===void 0||i.type==="TextNode"&&i.chars==="/")return a;throw y("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return Y(e)?e[0]:O.text({chars:"",loc:n})}}const dc={parse:pr,builders:ys,print:Aa,traverse:hr,Walker:Kr};class mc extends sr{constructor(){super({})}parse(){}}function pr(t,e={}){let r,s,n,a=e.mode||"precompile";typeof t=="string"?(r=new Ee(t,e.meta?.moduleName),s=a==="codemod"?Ut(t,e.parseOptions):Gt(t,e.parseOptions)):t instanceof Ee?(r=t,s=a==="codemod"?Ut(t.source,e.parseOptions):Gt(t.source,e.parseOptions)):(r=new Ee("",e.meta?.moduleName),s=t),a==="codemod"&&(n=new mc);let i=D.forCharPositions(r,0,r.source.length);s.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let o=new pc(r,n,a).acceptTemplate(s);if(e.strictMode&&(o.blockParams=e.locals??[]),e&&e.plugins&&e.plugins.ast)for(const l of e.plugins.ast)hr(o,l(Q({},e,{syntax:dc},{plugins:void 0})).visitor);return o}function rn(t,e,r,s){const n=function(a,i,o){if(a.type==="PathExpression"){if(a.head.type==="AtHead"||a.head.type==="ThisHead")return;const l=a.head.name;if(i.indexOf(l)===-1)return l}else if(a.type==="ElementNode"){const{tag:l}=a,c=l.charAt(0);if(c===":"||c==="@"||!o.includeHtmlElements&&l.indexOf(".")===-1&&l.toLowerCase()===l||l.substr(0,5)==="this.")return;if(l.includes(".")){let[h]=l.split(".");if(i.includes(h))return}return i.includes(l)?void 0:l}}(e,r,s);(Array.isArray(n)?n:[n]).forEach(a=>{if(a!==void 0&&a[0]!=="@"){const i=a.split(".")[0];r.includes(i)||t.add(a.split(".")[0])}})}function fc(t,e={includeHtmlElements:!1,includeKeywords:!1}){const r=pr(t),s=new Set,n=[];hr(r,{Block:{enter({blockParams:i}){i.forEach(o=>{n.push(o)})},exit({blockParams:i}){i.forEach(()=>{n.pop()})}},ElementNode:{enter(i){i.blockParams.forEach(o=>{n.push(o)}),rn(s,i,n,e)},exit({blockParams:i}){i.forEach(()=>{n.pop()})}},PathExpression(i){rn(s,i,n,e)}});let a=[];return s.forEach(i=>a.push(i)),e?.includeKeywords||(a=a.filter(i=>!Pa(i))),a}function L(t){if(t!==void 0){const e=t;return{fields:()=>class{type;constructor(r){this.type=e,Q(this,r)}}}}return{fields:()=>class{constructor(e){Q(this,e)}}}}class ge extends L().fields(){static empty(e){return new ge({loc:e,positional:tt.empty(e),named:Te.empty(e)})}static named(e){return new ge({loc:e.loc,positional:tt.empty(e.loc.collapse("end")),named:e})}nth(e){return this.positional.nth(e)}get(e){return this.named.get(e)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class tt extends L().fields(){static empty(e){return new tt({loc:e,exprs:[]})}get size(){return this.exprs.length}nth(e){return this.exprs[e]||null}isEmpty(){return this.exprs.length===0}}class Te extends L().fields(){static empty(e){return new Te({loc:e,entries:[]})}get size(){return this.entries.length}get(e){let r=this.entries.filter(s=>s.name.chars===e)[0];return r?r.value:null}isEmpty(){return this.entries.length===0}}class ws{loc;name;value;constructor(e){this.loc=e.name.loc.extend(e.value.loc),this.name=e.name,this.value=e.value}}class Fa extends L("HtmlAttr").fields(){}class Da extends L("SplatAttr").fields(){}class _a extends L().fields(){toNamedArgument(){return new ws({name:this.name,value:this.value})}}class Va extends L("ElementModifier").fields(){}class za extends L("GlimmerComment").fields(){}class Ua extends L("HtmlText").fields(){}class Ga extends L("HtmlComment").fields(){}class Ra extends L("AppendContent").fields(){get callee(){return this.value.type==="Call"?this.value.callee:this.value}get args(){return this.value.type==="Call"?this.value.args:ge.empty(this.value.loc.collapse("end"))}}class ja extends L("InvokeBlock").fields(){}class Vt extends L("InvokeComponent").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return ge.named(new Te({loc:re.range(e,this.callee.loc.collapse("end")),entries:e}))}}class Ja extends L("SimpleElement").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return ge.named(new Te({loc:re.range(e,this.tag.loc.collapse("end")),entries:e}))}}class Ka extends L("Literal").fields(){toSlice(){return new R({loc:this.loc,chars:this.value})}}class Wa extends L("Path").fields(){}class Ya extends L("Call").fields(){}class qa extends L("DeprecatedCall").fields(){}class Xa extends L("Interpolate").fields(){}class Qa extends L().fields(){}class Za extends L().fields(){}class vs extends L().fields(){get(e){return this.blocks.filter(r=>r.name.chars===e)[0]||null}}class We extends L().fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return ge.named(new Te({loc:re.range(e,this.name.loc.collapse("end")),entries:e}))}}class ei extends L("This").fields(){}class ti extends L("Arg").fields(){}class ri extends L("Local").fields(){}class si extends L("Free").fields(){}const ue={resolution:()=>he.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},ni={...ue,isAngleBracket:!0};class I{static namespaced(e,r=!1){return new I({namespaces:[e],fallback:!1},r)}static fallback(){return new I({namespaces:[],fallback:!0})}static append({invoke:e}){return new I({namespaces:[K.Component,K.Helper],fallback:!e})}static trustingAppend({invoke:e}){return new I({namespaces:[K.Helper],fallback:!e})}static attr(){return new I({namespaces:[K.Helper],fallback:!0})}constructor(e,r=!1){this.ambiguity=e,this.isAngleBracket=r}resolution(){if(this.ambiguity.namespaces.length===0)return he.GetStrictKeyword;if(this.ambiguity.namespaces.length!==1)return this.ambiguity.fallback?he.GetFreeAsComponentOrHelperHeadOrThisFallback:he.GetFreeAsComponentOrHelperHead;if(this.ambiguity.fallback)return he.GetFreeAsHelperHeadOrThisFallback;switch(this.ambiguity.namespaces[0]){case K.Helper:return he.GetFreeAsHelperHead;case K.Modifier:return he.GetFreeAsModifierHead;case K.Component:return he.GetFreeAsComponentHead}}serialize(){return this.ambiguity.namespaces.length===0?"Loose":this.ambiguity.namespaces.length===1?this.ambiguity.fallback?["ambiguous",Ie.Attr]:["ns",this.ambiguity.namespaces[0]]:this.ambiguity.fallback?["ambiguous",Ie.Append]:["ambiguous",Ie.Invoke]}}const zt=I.fallback();let K=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const ai=K.Helper,ii=K.Modifier,oi=K.Component;var Ie=function(t){return t.Append="Append",t.Attr="Attr",t.Invoke="Invoke",t}(Ie||{}),bc=Object.freeze({__proto__:null,ARGUMENT_RESOLUTION:zt,AppendContent:Ra,ArgReference:ti,Args:ge,Block:Za,COMPONENT_NAMESPACE:oi,CallExpression:Ya,ComponentArg:_a,DeprecatedCallExpression:qa,ElementModifier:Va,FreeVarNamespace:K,FreeVarReference:si,GlimmerComment:za,HELPER_NAMESPACE:ai,HTML_RESOLUTION:ni,HtmlAttr:Fa,HtmlComment:Ga,HtmlText:Ua,InterpolateExpression:Xa,InvokeBlock:ja,InvokeComponent:Vt,LiteralExpression:Ka,LocalVarReference:ri,LooseModeResolution:I,MODIFIER_NAMESPACE:ii,NamedArgument:ws,NamedArguments:Te,NamedBlock:We,NamedBlocks:vs,PathExpression:Wa,PositionalArguments:tt,STRICT_RESOLUTION:ue,SimpleElement:Ja,SplatAttr:Da,Template:Qa,ThisReference:ei,isLiteral:function(t,e){return t.type==="Literal"&&(e===void 0||(e==="null"?t.value===null:typeof t.value===e))},isStrictResolution:function(t){return t===ue},loadResolution:function(t){if(typeof t=="string")switch(t){case"Loose":return I.fallback();case"Strict":return ue}switch(t[0]){case"ambiguous":switch(t[1]){case Ie.Append:return I.append({invoke:!1});case Ie.Attr:return I.attr();case Ie.Invoke:return I.append({invoke:!0})}case"ns":return I.namespaced(t[1])}},node:L});class dr{static top(e,r){return new li(e,r)}child(e){let r=e.map(s=>this.allocate(s));return new ci(this,e,r)}}class li extends dr{constructor(e,r){super(),this.templateLocals=e,this.options=r}symbols=[];upvars=[];size=1;named=Er();blocks=Er();usedTemplateLocals=[];#e=!1;hasLexical(e){return this.options.lexicalScope(e)}getLexical(e){return this.allocateFree(e,ni)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#e=!0}get hasEval(){return this.#e}has(e){return this.templateLocals.includes(e)}get(e){let r=this.usedTemplateLocals.indexOf(e);return r!==-1||(r=this.usedTemplateLocals.length,this.usedTemplateLocals.push(e)),[r,!0]}getLocalsMap(){return Er()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(e,r){r.resolution()===he.GetFreeAsComponentHead&&r.isAngleBracket&&(e=this.options.customizeComponentName(e));let s=this.upvars.indexOf(e);return s!==-1||(s=this.upvars.length,this.upvars.push(e)),s}allocateNamed(e){let r=this.named[e];return r||(r=this.named[e]=this.allocate(e)),r}allocateBlock(e){e==="inverse"&&(e="else");let r=this.blocks[e];return r||(r=this.blocks[e]=this.allocate(`&${e}`)),r}allocate(e){return this.symbols.push(e),this.size++}}class ci extends dr{constructor(e,r,s){super(),this.parent=e,this.symbols=r,this.slots=s}get locals(){return this.symbols}getLexical(e){return this.parent.getLexical(e)}hasLexical(e){return this.parent.hasLexical(e)}has(e){return this.symbols.indexOf(e)!==-1||this.parent.has(e)}get(e){let r=this.#e(e);return r?[r,!1]:this.parent.get(e)}#e(e){let r=this.symbols.indexOf(e);return r===-1?null:pe(this.slots[r])}getLocalsMap(){let e=this.parent.getLocalsMap();return this.symbols.forEach(r=>e[r]=this.get(r)[0]),e}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(e,r){return this.parent.allocateFree(e,r)}allocateNamed(e){return this.parent.allocateNamed(e)}allocateBlock(e){return this.parent.allocateBlock(e)}allocate(e){return this.parent.allocate(e)}}var sn=Object.freeze({__proto__:null});class ui{template(e,r,s){return new Qa({table:e,body:r,loc:s})}block(e,r,s){return new Za({scope:e,body:r,loc:s})}namedBlock(e,r,s){return new We({name:e,block:r,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(e,r,s){return new nn({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(e,r,s)}slice(e,r){return new R({loc:r,chars:e})}args(e,r,s){return new ge({loc:s,positional:e,named:r})}positional(e,r){return new tt({loc:r,exprs:e})}namedArgument(e,r){return new ws({name:e,value:r})}named(e,r){return new Te({loc:r,entries:e})}attr({name:e,value:r,trusting:s},n){return new Fa({loc:n,name:e,value:r,trusting:s})}splatAttr(e,r){return new Da({symbol:e,loc:r})}arg({name:e,value:r,trusting:s},n){return new _a({name:e,value:r,trusting:s,loc:n})}path(e,r,s){return new Wa({loc:s,ref:e,tail:r})}self(e){return new ei({loc:e})}at(e,r,s){return B(e[0]==="@","call builders.at() with a string that starts with '@'"),new ti({loc:s,name:new R({loc:s,chars:e}),symbol:r})}freeVar({name:e,context:r,symbol:s,loc:n}){return B(e!=="this","You called builders.freeVar() with 'this'. Call builders.this instead"),B(e[0]!=="@",`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new si({name:e,resolution:r,symbol:s,loc:n})}localVar(e,r,s,n){return B(e!=="this","You called builders.var() with 'this'. Call builders.this instead"),B(e[0]!=="@",`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new ri({loc:n,name:e,isTemplateLocal:s,symbol:r})}sexp(e,r){return new Ya({loc:r,callee:e.callee,args:e.args})}deprecatedCall(e,r,s){return new qa({loc:s,arg:e,callee:r})}interpolate(e,r){return yt(e),new Xa({loc:r,parts:e})}literal(e,r){return new Ka({loc:r,value:e})}append({table:e,trusting:r,value:s},n){return new Ra({table:e,trusting:r,value:s,loc:n})}modifier({callee:e,args:r},s){return new Va({loc:s,callee:e,args:r})}namedBlocks(e,r){return new vs({loc:r,blocks:e})}blockStatement({program:e,inverse:r=null,...s},n){let a=e.loc,i=[this.namedBlock(R.synthetic("default"),e,e.loc)];return r&&(a=a.extend(r.loc),i.push(this.namedBlock(R.synthetic("else"),r,r.loc))),new ja({loc:n,blocks:this.namedBlocks(i,a),callee:s.callee,args:s.args})}element(e){return new nn(e)}}class nn{builder;constructor(e){this.base=e,this.builder=new ui}simple(e,r,s){return new Ja(Q({tag:e,body:r,componentArgs:[],loc:s},this.base))}named(e,r,s){return new We(Q({name:e,block:r,componentArgs:[],loc:s},this.base))}selfClosingComponent(e,r){return new Vt(Q({loc:r,callee:e,blocks:new vs({blocks:[],loc:r.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(e,r,s,n){let a=this.builder.block(s,r,n),i=this.builder.namedBlock(R.synthetic("default"),a,n);return new Vt(Q({loc:n,callee:e,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(e,r,s){return new Vt(Q({loc:s,callee:e,blocks:this.builder.namedBlocks(r,re.range(r))},this.base))}}function gc(t){return $t(t)?I.namespaced(ai):null}function kc(t){return $t(t)?I.namespaced(ii):null}function yc(t){return $t(t)?I.namespaced(oi):I.fallback()}function wc(t){return hi(t)?I.namespaced(K.Component,!0):null}function $t(t){return hi(t.path)}function hi(t){return t.type==="PathExpression"&&t.head.type==="VarHead"&&t.tail.length===0}function pi(t){return t.params.length>0||t.hash.pairs.length>0}function vc(t,e={lexicalScope:()=>!1}){let r=pr(t,e),s={strictMode:!1,locals:[],...e},n=dr.top(s.locals,{customizeComponentName:e.customizeComponentName??(l=>l),lexicalScope:e.lexicalScope}),a=new Ss(t,s,n),i=new Pt(a);return[new Ec(a.loc(r.loc),r.body.map(l=>i.normalize(l)),a).assertTemplate(n),n.getUsedTemplateLocals()]}class Ss{builder;constructor(e,r,s){this.source=e,this.options=r,this.table=s,this.builder=new ui}get strict(){return this.options.strictMode||!1}loc(e){return this.source.spanFor(e)}resolutionFor(e,r){if(this.strict)return{result:ue};if(this.isFreeVar(e)){let s=r(e);return s===null?{result:"error",path:di(e),head:mi(e)}:{result:s}}return{result:ue}}isLexicalVar(e){return this.table.hasLexical(e)}isFreeVar(e){return e.type==="PathExpression"?e.head.type==="VarHead"&&!this.table.has(e.head.name):e.path.type==="PathExpression"&&this.isFreeVar(e.path)}hasBinding(e){return this.table.has(e)||this.table.hasLexical(e)}child(e){return new Ss(this.source,this.options,this.table.child(e))}customizeComponentName(e){return this.options.customizeComponentName?this.options.customizeComponentName(e):e}}class Wr{constructor(e){this.block=e}normalize(e,r){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return this.path(e,r);case"SubExpression":{let s=this.block.resolutionFor(e,gc);if(s.result==="error")throw y(`You attempted to invoke a path (\`${s.path}\`) but ${s.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,s.result),this.block.loc(e.loc))}}}path(e,r){let s=[],n=this.block.loc(e.head.loc);for(let a of e.tail)n=n.sliceStartChars({chars:a.length,skipStart:1}),s.push(new R({loc:n,chars:a}));return this.block.builder.path(this.ref(e.head,r),s,this.block.loc(e.loc))}callParts(e,r){let{path:s,params:n,hash:a}=e,i=this.normalize(s,r),o=n.map(g=>this.normalize(g,zt)),l=re.range(o,i.loc.collapse("end")),c=this.block.loc(a.loc),h=re.range([l,c]),d=this.block.builder.positional(n.map(g=>this.normalize(g,zt)),l),m=this.block.builder.named(a.pairs.map(g=>this.namedArgument(g)),this.block.loc(a.loc));return{callee:i,args:this.block.builder.args(d,m,h)}}namedArgument(e){let r=this.block.loc(e.loc).sliceStartChars({chars:e.key.length});return this.block.builder.namedArgument(new R({chars:e.key,loc:r}),this.normalize(e.value,zt))}ref(e,r){let{block:s}=this,{builder:n,table:a}=s,i=s.loc(e.loc);switch(e.type){case"ThisHead":return n.self(i);case"AtHead":{let o=a.allocateNamed(e.name);return n.at(e.name,o,i)}case"VarHead":if(s.hasBinding(e.name)){let[o,l]=a.get(e.name);return s.builder.localVar(e.name,o,l,i)}{let o=s.strict?ue:r,l=s.table.allocateFree(e.name,o);return s.builder.freeVar({name:e.name,context:o,symbol:l,loc:i})}}}}class Pt{constructor(e){this.block=e}normalize(e){switch(e.type){case"PartialStatement":throw new Error("Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer");case"BlockStatement":return this.BlockStatement(e);case"ElementNode":return new Sc(this.block).ElementNode(e);case"MustacheStatement":return this.MustacheStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":{let r=this.block.loc(e.loc);return new Ga({loc:r,text:r.slice({skipStart:4,skipEnd:3}).toSlice(e.value)})}case"TextNode":return new Ua({loc:this.block.loc(e.loc),chars:e.chars})}}MustacheCommentStatement(e){let r,s=this.block.loc(e.loc);return r=s.asString().slice(0,5)==="{{!--"?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new za({loc:s,text:r.toSlice(e.value)})}MustacheStatement(e){let{escaped:r}=e,s=this.block.loc(e.loc),n=this.expr.callParts({path:e.path,params:e.params,hash:e.hash},function(i){let o=$t(i),l=pi(i),c=i.trusting;return o?c?I.trustingAppend({invoke:l}):I.append({invoke:l}):I.fallback()}(e)),a=n.args.isEmpty()?n.callee:this.block.builder.sexp(n,s);return this.block.builder.append({table:this.block.table,trusting:!r,value:a},s)}BlockStatement(e){let{program:r,inverse:s}=e,n=this.block.loc(e.loc),a=this.block.resolutionFor(e,yc);if(a.result==="error")throw y(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(e,a.result);return this.block.builder.blockStatement(Q({symbols:this.block.table,program:this.Block(r),inverse:s?this.Block(s):null},i),n)}Block({body:e,loc:r,blockParams:s}){let n=this.block.child(s),a=new Pt(n);return new Ac(this.block.loc(r),e.map(i=>a.normalize(i)),this.block).assertBlock(n.table)}get expr(){return new Wr(this.block)}}class Sc{constructor(e){this.ctx=e}ElementNode(e){let{tag:r,selfClosing:s,comments:n}=e,a=this.ctx.loc(e.loc),[i,...o]=cr(r.split(".")),l=this.classifyTag(i,o,e.loc),c=e.attributes.filter(N=>N.name[0]!=="@").map(N=>this.attr(N)),h=e.attributes.filter(N=>N.name[0]==="@").map(N=>this.arg(N)),d=e.modifiers.map(N=>this.modifier(N)),m=this.ctx.child(e.blockParams),g=new Pt(m),v=e.children.map(N=>g.normalize(N)),F=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:d,comments:n.map(N=>new Pt(this.ctx).MustacheCommentStatement(N))}),ee=new Pc(F,a,v,this.ctx),it=this.ctx.loc(e.loc).sliceStartChars({chars:r.length,skipStart:1});if(l==="ElementHead")return r[0]===":"?ee.assertNamedBlock(it.slice({skipStart:1}).toSlice(r.slice(1)),m.table):ee.assertElement(it.toSlice(r),e.blockParams.length>0);if(e.selfClosing)return F.selfClosingComponent(l,a);{let N=ee.assertComponent(r,m.table,e.blockParams.length>0);return F.componentWithNamedBlocks(l,N,a)}}modifier(e){let r=this.ctx.resolutionFor(e,kc);if(r.result==="error")throw y(`You attempted to invoke a path (\`{{#${r.path}}}\`) as a modifier, but ${r.head} was not in scope. Try adding \`this\` to the beginning of the path`,e.loc);let s=this.expr.callParts(e,r.result);return this.ctx.builder.modifier(s,this.ctx.loc(e.loc))}mustacheAttr(e){let r=this.ctx.builder.sexp(this.expr.callParts(e,function(s){let n=$t(s),a=pi(s);return n?a?I.namespaced(K.Helper):I.attr():a?ue:I.fallback()}(e)),this.ctx.loc(e.loc));return r.args.isEmpty()?r.callee:r}attrPart(e){switch(e.type){case"MustacheStatement":return{expr:this.mustacheAttr(e),trusting:!e.escaped};case"TextNode":return{expr:this.ctx.builder.literal(e.chars,this.ctx.loc(e.loc)),trusting:!0}}}attrValue(e){if(e.type==="ConcatStatement"){let r=e.parts.map(s=>this.attrPart(s).expr);return{expr:this.ctx.builder.interpolate(r,this.ctx.loc(e.loc)),trusting:!1}}return this.attrPart(e)}attr(e){if(B(e.name[0]!=="@","An attr name must not start with `@`"),e.name==="...attributes")return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:s,value:n.expr,trusting:n.trusting},r)}maybeDeprecatedCall(e,r){if(this.ctx.strict||r.type!=="MustacheStatement")return null;let{path:s}=r;if(s.type!=="PathExpression"||s.head.type!=="VarHead")return null;let{name:n}=s.head;if(n==="has-block"||n==="has-block-params"||this.ctx.hasBinding(n)||s.tail.length!==0||r.params.length!==0||r.hash.pairs.length!==0)return null;let a=I.attr(),i=this.ctx.builder.freeVar({name:n,context:a,symbol:this.ctx.table.allocateFree(n,a),loc:s.loc});return{expr:this.ctx.builder.deprecatedCall(e,i,r.loc),trusting:!1}}arg(e){B(e.name[0]==="@","An arg name must start with `@`");let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.maybeDeprecatedCall(s,e.value)||this.attrValue(e.value);return this.ctx.builder.arg({name:s,value:n.expr,trusting:n.trusting},r)}classifyTag(e,r,s){let n=(a=e)[0]===a[0]?.toUpperCase()&&a[0]!==a[0]?.toLowerCase();var a;let i=e[0]==="@"||e==="this"||this.ctx.hasBinding(e);if(this.ctx.strict&&!i){if(n)throw y(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${e}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${e.toLowerCase()}>\``,s);return"ElementHead"}let o=i||n,l=s.sliceStartChars({skipStart:1,chars:e.length}),c=r.reduce((m,g)=>m+1+g.length,0),h=l.getEnd().move(c),d=l.withEnd(h);if(o){let m=O.path({head:O.head(e,l),tail:r,loc:d}),g=this.ctx.isLexicalVar(e)?{result:ue}:this.ctx.resolutionFor(m,wc);if(g.result==="error")throw y(`You attempted to invoke a path (\`<${g.path}>\`) but ${g.head} was not in scope`,s);return new Wr(this.ctx).normalize(m,g.result)}if(this.ctx.table.allocateFree(e,ue),r.length>0)throw y(`You used ${e}.${r.join(".")} as a tag name, but ${e} is not in scope`,s);return"ElementHead"}get expr(){return new Wr(this.ctx)}}class Es{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(e,r,s){this.loc=e,this.children=r,this.block=s,this.namedBlocks=r.filter(n=>n instanceof We),this.hasSemanticContent=!!r.filter(n=>{if(n instanceof We)return!1;switch(n.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(n.chars);default:return!0}}).length,this.nonBlockChildren=r.filter(n=>!(n instanceof We))}}class Ec extends Es{assertTemplate(e){if(Y(this.namedBlocks))throw y("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(e,this.nonBlockChildren,this.block.loc(this.loc))}}class Ac extends Es{assertBlock(e){if(Y(this.namedBlocks))throw y("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(e,this.nonBlockChildren,this.loc)}}class Pc extends Es{constructor(e,r,s,n){super(r,s,n),this.el=e}assertNamedBlock(e,r){if(this.el.base.selfClosing)throw y(`<:${e.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(Y(this.namedBlocks))throw y(`Unexpected named block inside <:${e.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=e.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw y(`<:${e.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw y(`named block <:${e.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=re.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(e,this.block.builder.block(r,this.nonBlockChildren,n),this.loc)}assertElement(e,r){if(r)throw y(`Unexpected block params in <${e}>: simple elements cannot have block params`,this.loc);if(Y(this.namedBlocks)){let s=this.namedBlocks.map(n=>n.name);if(s.length===1)throw y(`Unexpected named block <:foo> inside <${e.chars}> HTML element`,this.loc);{let n=s.map(a=>`<:${a.chars}>`).join(", ");throw y(`Unexpected named blocks inside <${e.chars}> HTML element (${n})`,this.loc)}}return this.el.simple(e,this.nonBlockChildren,this.loc)}assertComponent(e,r,s){if(Y(this.namedBlocks)&&this.hasSemanticContent)throw y(`Unexpected content inside <${e}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(Y(this.namedBlocks)){if(s)throw y(`Unexpected block params list on <${e}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let n=new Set;for(let a of this.namedBlocks){let i=a.name.chars;if(n.has(i))throw y(`Component had two named blocks with the same name, \`<:${i}>\`. Only one block with a given name may be passed`,this.loc);if(i==="inverse"&&n.has("else")||i==="else"&&n.has("inverse"))throw y("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);n.add(i)}return this.namedBlocks}return[this.block.builder.namedBlock(R.synthetic("default"),this.block.builder.block(r,this.nonBlockChildren,this.loc),this.loc)]}}function di(t){return t.type!=="PathExpression"&&t.path.type==="PathExpression"?di(t.path):new ms({entityEncoding:"raw"}).print(t)}function mi(t){if(t.type!=="PathExpression")return t.path.type==="PathExpression"?mi(t.path):new ms({entityEncoding:"raw"}).print(t);switch(t.head.type){case"AtHead":case"VarHead":return t.head.name;case"ThisHead":return"this"}}const Cc=Object.freeze(Object.defineProperty({__proto__:null,AST:sn,ASTv1:sn,ASTv2:bc,BlockSymbolTable:ci,KEYWORDS_TYPES:Ca,Path:Kr,ProgramSymbolTable:li,SourceSlice:R,SpanList:re,SymbolTable:dr,Walker:Kr,WalkerPath:Lt,builders:ys,cannotRemoveNode:Jr,cannotReplaceNode:La,generateSyntaxError:y,getTemplateLocals:fc,getVoidTags:Zl,hasSpan:gs,isKeyword:Pa,isVoidTag:Ea,loc:et,maybeLoc:Ta,node:L,normalize:vc,preprocess:pr,print:Aa,sortByLoc:Sa,src:nc,traverse:hr,visitorKeys:Ba},Symbol.toStringTag,{value:"Module"})),{precompileJSON:Nc}=an(Dl),{getTemplateLocals:xc}=an(Cc);function Lu(t,e={}){let r=fi(t),s,n;try{s=bi(Tc(t,{moduleName:e.moduleName||r,...e}),gi(void 0,"hbs:component"))}catch(a){n=a}return{name:r,component:s,error:n}}function Tc(t,{moduleName:e,scope:r={}}){let s={array:ki,concat:yi,fn:wi,get:vi,hash:Si,on:Ei,...r},n=xc(t),a={strictMode:!0,moduleName:e,locals:n,isProduction:!1,meta:{moduleName:e}},[i,o]=Nc(t,a),l=o.map(m=>{let g=s[m];if(!g)throw new Error(`Attempt to use ${m} in compiled hbs, but it was not available in scope. Available scope includes: ${Object.keys(s)}`);return g}),c=JSON.stringify(i);return Ai({id:e,block:c,moduleName:e??"(dynamically compiled component)",scope:()=>l,isStrictMode:!0})}export{Lu as compileHBS};
