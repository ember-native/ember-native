import{n as oi,s as ci,t as ui,e as nn,o as hi,h as pi,g as mi,f as di,c as fi,b as gi,a as bi}from"./main-DD3VQlwT.js";import{p as Mt,a as Dt,E as Zt,b as an,n as ln}from"./index-BUReOOGB.js";function v(t,e){if(!t)throw new Error(e||"assertion failure")}function W(t){Pi.warn(`DEPRECATION: ${t}`)}function er(t){if(t==null)throw new Error("Expected value to be present");return t}function ot(t,e){if(t==null)throw new Error(e);return t}function ht(t){throw new Error(`Exhausted ${String(t)}`)}function F(t){return t.length>0}function Je(t,e="unexpected empty list"){if(!F(t))throw new Error(e)}function We(t,e="unexpected empty list"){return Je(t,e),t}function tt(t){return t.length===0?void 0:t[t.length-1]}function Rr(t){return t.length===0?void 0:t[0]}function on(t,e){if(t===null)return null;let r=[];for(let s of t)r.push(e(s));return r}function le(){return Object.create(null)}const ki="http://www.w3.org/1999/xlink",yi="http://www.w3.org/XML/1998/namespace",Es="http://www.w3.org/2000/xmlns/";let jr=function(t){return t[t.MAX_SMI=1073741823]="MAX_SMI",t[t.MIN_SMI=-1073741824]="MIN_SMI",t[t.SIGN_BIT=-536870913]="SIGN_BIT",t[t.MAX_INT=536870911]="MAX_INT",t[t.MIN_INT=-536870912]="MIN_INT",t[t.FALSE_HANDLE=0]="FALSE_HANDLE",t[t.TRUE_HANDLE=1]="TRUE_HANDLE",t[t.NULL_HANDLE=2]="NULL_HANDLE",t[t.UNDEFINED_HANDLE=3]="UNDEFINED_HANDLE",t[t.ENCODED_FALSE_HANDLE=0]="ENCODED_FALSE_HANDLE",t[t.ENCODED_TRUE_HANDLE=1]="ENCODED_TRUE_HANDLE",t[t.ENCODED_NULL_HANDLE=2]="ENCODED_NULL_HANDLE",t[t.ENCODED_UNDEFINED_HANDLE=3]="ENCODED_UNDEFINED_HANDLE",t}({});function wi(t){return t&jr.SIGN_BIT}function vi(t){return t|~jr.SIGN_BIT}function Si(t){return~t}function Ei(t){return~t}function Ai(t){return(t|=0)<0?wi(t):Si(t)}function xi(t){return(t|=0)>jr.SIGN_BIT?Ei(t):vi(t)}[1,-1].forEach(t=>xi(Ai(t)));let ae=Object.assign;function Ci(t){return Object.values(t)}const Pi=console,As=console;function ue(t,e="unexpected unreachable branch"){throw As.log("unreachable",t),As.log(`${e} :: ${JSON.stringify(t)} (${t})`),new Error("code reached unreachable")}const u={Append:1,TrustingAppend:2,Comment:3,Modifier:4,Block:6,Component:8,OpenElement:10,OpenElementWithSplat:11,FlushElement:12,CloseElement:13,StaticAttr:14,DynamicAttr:15,ComponentAttr:16,AttrSplat:17,Yield:18,DynamicArg:20,StaticArg:21,TrustingDynamicAttr:22,TrustingComponentAttr:23,StaticComponentAttr:24,Debugger:26,Undefined:27,Call:28,Concat:29,GetSymbol:30,GetLexicalSymbol:32,GetStrictKeyword:31,GetFreeAsComponentOrHelperHead:35,GetFreeAsHelperHead:37,GetFreeAsModifierHead:38,GetFreeAsComponentHead:39,InElement:40,If:41,Each:42,Let:44,WithDynamicVars:45,InvokeComponent:46,HasBlock:48,HasBlockParams:49,Curry:50,Not:51,IfInline:52,GetDynamicVar:53,Log:54},Q={Strict:0,ResolveAsComponentOrHelperHead:1,ResolveAsHelperHead:5,ResolveAsModifierHead:6,ResolveAsComponentHead:7},Pe={class:0,id:1,value:2,name:3,type:4,style:5,href:6},Tt={div:0,span:1,p:2,a:3};var ge=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(ge||{});const cn=/["&\xA0]/u,Ni=new RegExp(cn.source,"gu"),un=/[&<>\xA0]/u,Ti=new RegExp(un.source,"gu");function Bi(t){switch(t.charCodeAt(0)){case ge.NBSP:return"&nbsp;";case ge.QUOT:return"&quot;";case ge.AMP:return"&amp;";default:return t}}function Li(t){switch(t.charCodeAt(0)){case ge.NBSP:return"&nbsp;";case ge.AMP:return"&amp;";case ge.LT:return"&lt;";case ge.GT:return"&gt;";default:return t}}function $i(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const Ar=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]),Oi=/^\S/u;function hn(t){return Ar.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}let Kr=class{buffer="";options;constructor(e){this.options=e}handledByOverride(e,r=!1){if(this.options.override!==void 0){let s=this.options.override(e,this.options);if(typeof s=="string")return r&&Oi.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(e){switch(e.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(e);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(e);case"ConcatStatement":return this.ConcatStatement(e);case"Hash":return this.Hash(e);case"HashPair":return this.HashPair(e);case"ElementModifierStatement":return this.ElementModifierStatement(e)}}Expression(e){switch(e.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(e);case"PathExpression":return this.PathExpression(e);case"SubExpression":return this.SubExpression(e)}}Literal(e){switch(e.type){case"StringLiteral":return this.StringLiteral(e);case"BooleanLiteral":return this.BooleanLiteral(e);case"NumberLiteral":return this.NumberLiteral(e);case"UndefinedLiteral":return this.UndefinedLiteral(e);case"NullLiteral":return this.NullLiteral(e)}}TopLevelStatement(e){switch(e.type){case"MustacheStatement":return this.MustacheStatement(e);case"BlockStatement":return this.BlockStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":return this.CommentStatement(e);case"TextNode":return this.TextNode(e);case"ElementNode":return this.ElementNode(e);case"Block":return this.Block(e);case"Template":return this.Template(e);case"AttrNode":return this.AttrNode(e)}}Template(e){this.TopLevelStatements(e.body)}Block(e){e.chained&&(e.body[0].chained=!0),this.handledByOverride(e)||this.TopLevelStatements(e.body)}TopLevelStatements(e){e.forEach(r=>this.TopLevelStatement(r))}ElementNode(e){this.handledByOverride(e)||(this.OpenElementNode(e),this.TopLevelStatements(e.children),this.CloseElementNode(e))}OpenElementNode(e){this.buffer+=`<${e.tag}`;const r=[...e.attributes,...e.modifiers,...e.comments].sort($i);for(const s of r)switch(this.buffer+=" ",s.type){case"AttrNode":this.AttrNode(s);break;case"ElementModifierStatement":this.ElementModifierStatement(s);break;case"MustacheCommentStatement":this.MustacheCommentStatement(s)}e.blockParams.length&&this.BlockParams(e.blockParams),e.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(e){e.selfClosing||hn(e.tag)||(this.buffer+=`</${e.tag}>`)}AttrNode(e){if(this.handledByOverride(e))return;let{name:r,value:s}=e;this.buffer+=r,(s.type!=="TextNode"||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(e){e.type==="TextNode"?(this.buffer+='"',this.TextNode(e,!0),this.buffer+='"'):this.Node(e)}TextNode(e,r){var s;this.handledByOverride(e)||(this.options.entityEncoding==="raw"?this.buffer+=e.chars:this.buffer+=r?(s=e.chars,cn.test(s)?s.replace(Ni,Bi):s):function(n){return un.test(n)?n.replace(Ti,Li):n}(e.chars))}MustacheStatement(e){this.handledByOverride(e)||(this.buffer+=e.trusting?"{{{":"{{",e.strip.open&&(this.buffer+="~"),this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.strip.close&&(this.buffer+="~"),this.buffer+=e.trusting?"}}}":"}}")}BlockStatement(e){this.handledByOverride(e)||(e.chained?(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=e.openStrip.open?"{{~#":"{{#",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.program.blockParams.length&&this.BlockParams(e.program.blockParams),e.chained?this.buffer+=e.inverseStrip.close?"~}}":"}}":this.buffer+=e.openStrip.close?"~}}":"}}",this.Block(e.program),e.inverse&&(e.inverse.chained||(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=e.inverseStrip.close?"~}}":"}}"),this.Block(e.inverse)),e.chained||(this.buffer+=e.closeStrip.open?"{{~/":"{{/",this.Expression(e.path),this.buffer+=e.closeStrip.close?"~}}":"}}"))}BlockParams(e){this.buffer+=` as |${e.join(" ")}|`}ConcatStatement(e){this.handledByOverride(e)||(this.buffer+='"',e.parts.forEach(r=>{r.type==="TextNode"?this.TextNode(r,!0):this.Node(r)}),this.buffer+='"')}MustacheCommentStatement(e){this.handledByOverride(e)||(this.buffer+=`{{!--${e.value}--}}`)}ElementModifierStatement(e){this.handledByOverride(e)||(this.buffer+="{{",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}CommentStatement(e){this.handledByOverride(e)||(this.buffer+=`<!--${e.value}-->`)}PathExpression(e){this.handledByOverride(e)||(this.buffer+=e.original)}SubExpression(e){this.handledByOverride(e)||(this.buffer+="(",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+=")")}Params(e){e.length&&e.forEach(r=>{this.buffer+=" ",this.Expression(r)})}Hash(e){this.handledByOverride(e,!0)||e.pairs.forEach(r=>{this.buffer+=" ",this.HashPair(r)})}HashPair(e){this.handledByOverride(e)||(this.buffer+=e.key,this.buffer+="=",this.Node(e.value))}StringLiteral(e){this.handledByOverride(e)||(this.buffer+=JSON.stringify(e.value))}BooleanLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}NumberLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}UndefinedLiteral(e){this.handledByOverride(e)||(this.buffer+="undefined")}NullLiteral(e){this.handledByOverride(e)||(this.buffer+="null")}print(e){let{options:r}=this;if(r.override){let s=r.override(e,r);if(s!==void 0)return s}return this.buffer="",this.Node(e),this.buffer}};function Hi(t,e={entityEncoding:"transformed"}){return t?new Kr(e).print(t):""}function Ii(t,e){return t in _t&&(e===void 0||_t[t].includes(e))}const _t={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]},he=Object.freeze({line:1,column:0}),pn=Object.freeze({source:"(synthetic)",start:he,end:he}),ze=Object.freeze({source:"(nonexistent)",start:he,end:he}),be=Object.freeze({source:"(broken)",start:he,end:he});let A=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const pt="MATCH_ANY",xr="IS_INVISIBLE";let Fi=class{_whens;constructor(e){this._whens=e}first(e){for(const r of this._whens){const s=r.match(e);if(F(s))return s[0]}return null}},xs=class{_map=new Map;get(e,r){let s=this._map.get(e);return s||(s=r(),this._map.set(e,s),s)}add(e,r){this._map.set(e,r)}match(e){const r=function(i){switch(i){case A.Broken:case A.InternalsSynthetic:case A.NonExistent:return xr;default:return i}}(e),s=[],n=this._map.get(r),a=this._map.get(pt);return n&&s.push(n),a&&s.push(a),s}};function mn(t){return t(new Mi).check()}let Mi=class{_whens=new xs;check(){return(e,r)=>this.matchFor(e.kind,r.kind)(e,r)}matchFor(e,r){const s=this._whens.match(e);v(F(s),`no match defined for (${e}, ${r}) and no AnyMatch defined either`);const n=new Fi(s).first(r);return v(n!==null,`no match defined for (${e}, ${r}) and no AnyMatch defined either`),n}when(e,r,s){return this._whens.get(e,()=>new xs).add(r,s),this}},q=class Cr{static synthetic(e){let r=D.synthetic(e);return new Cr({loc:r,chars:e})}static load(e,r){return new Cr({loc:D.load(e,r[1]),chars:r[0]})}chars;loc;constructor(e){this.loc=e.loc,this.chars=e.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}},D=class Me{static get NON_EXISTENT(){return new Te(A.NonExistent,ze).wrap()}static load(e,r){return typeof r=="number"?Me.forCharPositions(e,r,r):typeof r=="string"?Me.synthetic(r):Array.isArray(r)?Me.forCharPositions(e,r[0],r[1]):r===A.NonExistent?Me.NON_EXISTENT:r===A.Broken?Me.broken(be):void ue(r)}static forHbsLoc(e,r){const s=new Ye(e,r.start),n=new Ye(e,r.end);return new Wr(e,{start:s,end:n},r).wrap()}static forCharPositions(e,r,s){const n=new mt(e,r),a=new mt(e,s);return new Jr(e,{start:n,end:a}).wrap()}static synthetic(e){return new Te(A.InternalsSynthetic,ze,e).wrap()}static broken(e=be){return new Te(A.Broken,e).wrap()}isInvisible;constructor(e){this.data=e,this.isInvisible=e.kind!==A.CharPosition&&e.kind!==A.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const e=this.data.toHbsSpan();return e===null?be:e.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(e){return re(e.data,this.data.getEnd())}withEnd(e){return re(this.data.getStart(),e.data)}asString(){return this.data.asString()}toSlice(e){const r=this.data.asString();return new q({loc:this,chars:e||r})}get start(){return this.loc.start}set start(e){this.data.locDidUpdate({start:e})}get end(){return this.loc.end}set end(e){this.data.locDidUpdate({end:e})}get source(){return this.module}collapse(e){switch(e){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(e){return re(this.data.getStart(),e.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:e=0,skipEnd:r=0}){return re(this.getStart().move(e).data,this.getEnd().move(-r).data)}sliceStartChars({skipStart:e=0,chars:r}){return re(this.getStart().move(e).data,this.getStart().move(e+r).data)}sliceEndChars({skipEnd:e=0,chars:r}){return re(this.getEnd().move(e-r).data,this.getStart().move(-e).data)}},Jr=class{kind=A.CharPosition;_locPosSpan=null;constructor(e,r){this.source=e,this.charPositions=r}wrap(){return new D(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let e=this._locPosSpan;if(e===null){const r=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();e=this._locPosSpan=r===null||s===null?we:new Wr(this.source,{start:r,end:s})}return e===we?null:e}serialize(){const{start:{charPos:e},end:{charPos:r}}=this.charPositions;return e===r?e:[e,r]}toCharPosSpan(){return this}},Wr=class{kind=A.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(e,r,s=null){this.source=e,this.hbsPositions=r,this._providedHbsLoc=s}serialize(){const e=this.toCharPosSpan();return e===null?A.Broken:e.wrap().serialize()}wrap(){return new D(this)}updateProvided(e,r){this._providedHbsLoc&&(this._providedHbsLoc[r]=e),this._charPosSpan=null,this._providedHbsLoc={start:e,end:e}}locDidUpdate({start:e,end:r}){e!==void 0&&(this.updateProvided(e,"start"),this.hbsPositions.start=new Ye(this.source,e,null)),r!==void 0&&(this.updateProvided(r,"end"),this.hbsPositions.end=new Ye(this.source,r,null))}asString(){const e=this.toCharPosSpan();return e===null?"":e.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let e=this._charPosSpan;if(e===null){const r=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!r||!s)return e=this._charPosSpan=we,null;e=this._charPosSpan=new Jr(this.source,{start:r,end:s})}return e===we?null:e}},Te=class{constructor(e,r,s=null){this.kind=e,this.loc=r,this.string=s}serialize(){switch(this.kind){case A.Broken:case A.NonExistent:return this.kind;case A.InternalsSynthetic:return this.string||""}}wrap(){return new D(this)}asString(){return this.string||""}locDidUpdate({start:e,end:r}){e!==void 0&&(this.loc.start=e),r!==void 0&&(this.loc.end=r)}getModule(){return"an unknown module"}getStart(){return new Nr(this.kind,this.loc.start)}getEnd(){return new Nr(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return be}};const re=mn(t=>t.when(A.HbsPosition,A.HbsPosition,(e,r)=>new Wr(e.source,{start:e,end:r}).wrap()).when(A.CharPosition,A.CharPosition,(e,r)=>new Jr(e.source,{start:e,end:r}).wrap()).when(A.CharPosition,A.HbsPosition,(e,r)=>{const s=r.toCharPos();return s===null?new Te(A.Broken,be).wrap():re(e,s)}).when(A.HbsPosition,A.CharPosition,(e,r)=>{const s=e.toCharPos();return s===null?new Te(A.Broken,be).wrap():re(s,r)}).when(xr,pt,e=>new Te(e.kind,be).wrap()).when(pt,xr,(e,r)=>new Te(r.kind,be).wrap())),we="BROKEN";let St=class Pr{static forHbsPos(e,r){return new Ye(e,r,null).wrap()}static broken(e=he){return new Nr(A.Broken,e).wrap()}constructor(e){this.data=e}get offset(){const e=this.data.toCharPos();return e===null?null:e.offset}eql(e){return Di(this.data,e.data)}until(e){return re(this.data,e.data)}move(e){const r=this.data.toCharPos();if(r===null)return Pr.broken();{const s=r.offset+e;return r.source.check(s)?new mt(r.source,s).wrap():Pr.broken()}}collapsed(){return re(this.data,this.data)}toJSON(){return this.data.toJSON()}},mt=class{kind=A.CharPosition;_locPos=null;constructor(e,r){this.source=e,this.charPos=r}toCharPos(){return this}toJSON(){const e=this.toHbsPos();return e===null?he:e.toJSON()}wrap(){return new St(this)}get offset(){return this.charPos}toHbsPos(){let e=this._locPos;if(e===null){const r=this.source.hbsPosFor(this.charPos);this._locPos=e=r===null?we:new Ye(this.source,r,this.charPos)}return e===we?null:e}},Ye=class{kind=A.HbsPosition;_charPos;constructor(e,r,s=null){this.source=e,this.hbsPos=r,this._charPos=s===null?null:new mt(e,s)}toCharPos(){let e=this._charPos;if(e===null){const r=this.source.charPosFor(this.hbsPos);this._charPos=e=r===null?we:new mt(this.source,r)}return e===we?null:e}toJSON(){return this.hbsPos}wrap(){return new St(this)}toHbsPos(){return this}},Nr=class{constructor(e,r){this.kind=e,this.pos=r}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new St(this)}get offset(){return null}};const Di=mn(t=>t.when(A.HbsPosition,A.HbsPosition,({hbsPos:e},{hbsPos:r})=>e.column===r.column&&e.line===r.line).when(A.CharPosition,A.CharPosition,({charPos:e},{charPos:r})=>e===r).when(A.CharPosition,A.HbsPosition,({offset:e},r)=>e===r.toCharPos()?.offset).when(A.HbsPosition,A.CharPosition,(e,{offset:r})=>e.toCharPos()?.offset===r).when(pt,pt,()=>!1));let Ve=class dn{static from(e,r={}){return new dn(e,r.meta?.moduleName)}constructor(e,r="an unknown module"){this.source=e,this.module=r}check(e){return e>=0&&e<=this.source.length}slice(e,r){return this.source.slice(e,r)}offsetFor(e,r){return St.forHbsPos(this,{line:e,column:r})}spanFor({start:e,end:r}){return D.forHbsLoc(this,{start:{line:e.line,column:e.column},end:{line:r.line,column:r.column}})}hbsPosFor(e){let r=0,s=0;if(e>this.source.length)return null;for(;;){let n=this.source.indexOf(`
`,s);if(e<=n||n===-1)return{line:r+1,column:e-s};r+=1,s=n+1}}charPosFor(e){let{line:r,column:s}=e,n=this.source.length,a=0,i=0;for(;i<n;){let l=this.source.indexOf(`
`,i);if(l===-1&&(l=this.source.length),a===r-1)return i+s>l?l:i+s;if(l===-1)return 0;a+=1,i=l+1}return n}},ve=class fn{static range(e,r=D.NON_EXISTENT){return new fn(e.map(qe)).getRangeOffset(r)}_span;constructor(e=[]){this._span=e}add(e){this._span.push(e)}getRangeOffset(e){if(F(this._span)){let r=Rr(this._span),s=tt(this._span);return r.extend(s)}return e}};function qe(t){if(Array.isArray(t)){let e=Rr(t),r=tt(t);return qe(e).extend(qe(r))}return t instanceof D?t:t.loc}function gn(t){return!Array.isArray(t)||t.length!==0}function Tr(t,e){return gn(t)?qe(t):e}var zt=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:ze,SYNTHETIC_LOCATION:pn,Source:Ve,SourceOffset:St,SourceSlice:q,SourceSpan:D,SpanList:ve,UNKNOWN_POSITION:he,hasSpan:gn,loc:qe,maybeLoc:Tr});function p(t,e){let{module:r,loc:s}=e,{line:n,column:a}=s.start,i=e.asString(),l=i?`

|
|  ${i.split(`
`).join(`
|  `)}
|

`:"",o=new Error(`${t}: ${l}(error occurred in '${r}' @ line ${n} : column ${a})`);return o.name="SyntaxError",o.location=e,o.code=i,o}const _i={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},Yr=function(){function t(e,r,s,n){let a=Error.call(this,e);this.key=n,this.message=e,this.node=r,this.parent=s,a.stack&&(this.stack=a.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function Cs(t,e,r){return new Yr("Cannot remove a node unless it is part of an array",t,e,r)}function zi(t,e,r){return new Yr("Cannot replace a node with multiple nodes unless it is part of an array",t,e,r)}function Ps(t,e){return new Yr("Replacing and removing in key handlers is not yet supported.",t,null,e)}let tr=class{node;parent;parentKey;constructor(e,r=null,s=null){this.node=e,this.parent=r,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new Vi(this)}}},Vi=class{path;constructor(e){this.path=e}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}};function bn(t){return typeof t=="function"?t:t.enter}function kn(t){return typeof t=="function"?void 0:t.exit}function rr(t,e){let r,s,n,{node:a,parent:i,parentKey:l}=e,o=function(c,h){if(c.Program&&(h==="Template"&&!c.Template||h==="Block"&&!c.Block))return W(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${h}') `),c.Program;let m=c[h];return m!==void 0?m:c.All}(t,a.type);if(o!==void 0&&(r=bn(o),s=kn(o)),r!==void 0&&(n=r(a,e)),n!=null){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(yn(t,n,i,l),n):rr(t,new tr(n,i,l))||n;n=void 0}if(n===void 0){let c=_i[a.type];for(let h=0;h<c.length;h++)Ui(t,o,e,c[h]);s!==void 0&&(n=s(a,e))}return n}function Ns(t,e,r){t[e]=r}function Ui(t,e,r,s){let n,a,{node:i}=r,l=function(o,c){return o[c]}(i,s);if(l){if(e!==void 0){let o=function(c,h){let m=typeof c!="function"?c.keys:void 0;if(m===void 0)return;let d=m[h];return d!==void 0?d:m.All}(e,s);o!==void 0&&(n=bn(o),a=kn(o))}if(n!==void 0&&n(i,s)!==void 0)throw Ps(i,s);if(Array.isArray(l))yn(t,l,r,s);else{let o=rr(t,new tr(l,r,s));o!==void 0&&function(c,h,m,d){if(d===null)throw Cs(m,c,h);if(Array.isArray(d)){if(d.length!==1)throw d.length===0?Cs(m,c,h):zi(m,c,h);Ns(c,h,d[0])}else Ns(c,h,d)}(i,s,l,o)}if(a!==void 0&&a(i,s)!==void 0)throw Ps(i,s)}}function yn(t,e,r,s){for(let n=0;n<e.length;n++){let a=er(e[n]),i=rr(t,new tr(a,r,s));i!==void 0&&(n+=Gi(e,n,i)-1)}}function Gi(t,e,r){return r===null?(t.splice(e,1),0):Array.isArray(r)?(t.splice(e,1,...r),r.length):(t.splice(e,1,r),1)}function wn(t,e){rr(e,new tr(t))}let Ri=class{stack=[];constructor(e){this.order=e}visit(e,r){e&&(this.stack.push(e),this.order==="post"?(this.children(e,r),r(e,this)):(r(e,this),this.children(e,r)),this.stack.pop())}children(e,r){switch(e.type){case"Block":case"Template":return void Ts(this,e.body,r);case"ElementNode":return void Ts(this,e.children,r);case"BlockStatement":return this.visit(e.program,r),void this.visit(e.inverse||null,r);default:return}}};function Ts(t,e,r){for(const s of e)t.visit(s,r)}function Ue(t,e){(function(r){switch(r.type){case"Block":case"Template":return r.body;case"ElementNode":return r.children}})(t).push(e)}function vn(t){return t.type==="StringLiteral"||t.type==="BooleanLiteral"||t.type==="NumberLiteral"||t.type==="NullLiteral"||t.type==="UndefinedLiteral"}let cr;function ur(){return cr||(cr=new Ve("","(synthetic)")),cr}function Bs(t,e){return f.var({name:t,loc:L(e||null)})}function de(t,e){let r=L(e||null);if(typeof t!="string"){if("type"in t)return t;{v(t.head.indexOf(".")===-1,"builder.path({ head, tail }) should not be called with a head with dots in it");let{head:a,tail:i}=t;return f.path({head:f.head({original:a,loc:r.sliceStartChars({chars:a.length})}),tail:i,loc:L(e||null)})}}let{head:s,tail:n}=function(a,i){let[l,...o]=We(a.split(".")),c=f.head({original:l,loc:L(i||null)});return f.path({head:c,tail:o,loc:L(i||null)})}(t,r);return f.path({head:s,tail:n,loc:r})}function $t(t,e,r){return f.literal({type:t,value:e,loc:L(r||null)})}function at(t=[],e){return f.hash({pairs:t,loc:L(e||null)})}function Sn(t){return t.map(e=>typeof e=="string"?f.var({name:e,loc:D.synthetic(e)}):e)}function Ls(t=[],e=[],r=!1,s){return f.blockItself({body:t,params:Sn(e),chained:r,loc:L(s||null)})}function $s(t=[],e=[],r){return f.template({body:t,blockParams:e,loc:L(r||null)})}function L(...t){if(t.length===1){let e=t[0];return e&&typeof e=="object"?D.forHbsLoc(ur(),e):D.forHbsLoc(ur(),pn)}{let[e,r,s,n,a]=t,i=a?new Ve("",a):ur();return D.forHbsLoc(i,{start:{line:e,column:r},end:{line:s||e,column:n||r}})}}var En={mustache:function(t,e=[],r=at([]),s=!1,n,a){return f.mustache({path:de(t),params:e,hash:r,trusting:s,strip:a,loc:L(n||null)})},block:function(t,e,r,s,n=null,a,i,l,o){let c,h=null;return s.type==="Template"?(W("b.program is deprecated. Use b.blockItself instead."),c=f.blockItself({params:Sn(s.blockParams),body:s.body,loc:s.loc})):c=s,n?.type==="Template"?(W("b.program is deprecated. Use b.blockItself instead."),v(n.blockParams.length===0,"{{else}} block cannot have block params"),h=f.blockItself({params:[],body:n.body,loc:n.loc})):h=n,f.block({path:de(t),params:e||[],hash:r||at([]),defaultBlock:c,elseBlock:h,loc:L(a||null),openStrip:i,inverseStrip:l,closeStrip:o})},comment:function(t,e){return f.comment({value:t,loc:L(e||null)})},mustacheComment:function(t,e){return f.mustacheComment({value:t,loc:L(e||null)})},element:function(t,e={}){let r,s,{attrs:n,blockParams:a,modifiers:i,comments:l,children:o,openTag:c,closeTag:h,loc:m}=e;typeof t=="string"?t.endsWith("/")?(r=de(t.slice(0,-1)),s=!0):r=de(t):"type"in t?(v(t.type==="PathExpression",`Invalid tag type ${t.type}`),r=t):"path"in t?(v(t.path.type==="PathExpression",`Invalid tag type ${t.path.type}`),r=t.path,s=t.selfClosing):(r=de(t.name),s=t.selfClosing),s&&v(h==null,"Cannot build a self-closing tag with a closeTag source location");let d=a?.map(S=>typeof S=="string"?Bs(S):S),y=null;return h?y=L(h||null):h===void 0&&(y=s||hn(r.original)?null:L(null)),f.element({path:r,selfClosing:s||!1,attributes:n||[],params:d||[],modifiers:i||[],comments:l||[],children:o||[],openTag:L(c||null),closeTag:y,loc:L(m||null)})},elementModifier:function(t,e,r,s){return f.elementModifier({path:de(t),params:e||[],hash:r||at([]),loc:L(s||null)})},attr:function(t,e,r){return f.attr({name:t,value:e,loc:L(r||null)})},text:function(t="",e){return f.text({chars:t,loc:L(e||null)})},sexpr:function(t,e=[],r=at([]),s){return f.sexpr({path:de(t),params:e,hash:r,loc:L(s||null)})},concat:function(t,e){if(!F(t))throw new Error("b.concat requires at least one part");return f.concat({parts:t,loc:L(e||null)})},hash:at,pair:function(t,e,r){return f.pair({key:t,value:e,loc:L(r||null)})},literal:$t,program:function(t,e,r){return W("b.program is deprecated. Use b.template or b.blockItself instead."),e&&e.length?Ls(t,e,!1,r):$s(t,[],r)},blockItself:Ls,template:$s,loc:L,pos:function(t,e){return f.pos({line:t,column:e})},path:de,fullPath:function(t,e=[],r){return f.path({head:t,tail:e,loc:L(r||null)})},head:function(t,e){return f.head({original:t,loc:L(e||null)})},at:function(t,e){return f.atName({name:t,loc:L(e||null)})},var:Bs,this:function(t){return f.this({loc:L(t||null)})},string:hr("StringLiteral"),boolean:hr("BooleanLiteral"),number:hr("NumberLiteral"),undefined:()=>$t("UndefinedLiteral",void 0),null:()=>$t("NullLiteral",null)};function hr(t){return function(e,r){return $t(t,e,r)}}const Bt={close:!1,open:!1},f=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:r=!1,loc:s}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map(n=>n.name)},set blockParams(n){this.params=n.map(a=>f.var({name:a,loc:D.synthetic(a)}))},chained:r,loc:s}}template({body:t,blockParams:e,loc:r}){return{type:"Template",body:t,blockParams:e,loc:r}}mustache({path:t,params:e,hash:r,trusting:s,loc:n,strip:a=Bt}){return function({path:i,params:l,hash:o,trusting:c,strip:h,loc:m}){const d={type:"MustacheStatement",path:i,params:l,hash:o,trusting:c,strip:h,loc:m};return Object.defineProperty(d,"escaped",{enumerable:!1,get(){return W("The escaped property on mustache nodes is deprecated, use trusting instead"),!this.trusting},set(y){W("The escaped property on mustache nodes is deprecated, use trusting instead"),this.trusting=!y}}),d}({path:t,params:e,hash:r,trusting:s,strip:a,loc:n})}block({path:t,params:e,hash:r,defaultBlock:s,elseBlock:n=null,loc:a,openStrip:i=Bt,inverseStrip:l=Bt,closeStrip:o=Bt}){return{type:"BlockStatement",path:t,params:e,hash:r,program:s,inverse:n,loc:a,openStrip:i,inverseStrip:l,closeStrip:o}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:c,get tag(){return this.path.original},set tag(m){this.path.original=m},get blockParams(){return this.params.map(m=>m.name)},set blockParams(m){this.params=m.map(d=>f.var({name:d,loc:D.synthetic(d)}))},get selfClosing(){return h},set selfClosing(m){h=m,this.closeTag=m?null:D.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:r,loc:s}){return{type:"ElementModifierStatement",path:t,params:e,hash:r,loc:s}}attr({name:t,value:e,loc:r}){return{type:"AttrNode",name:t,value:e,loc:r}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:r,loc:s}){return{type:"SubExpression",path:t,params:e,hash:r,loc:s}}path({head:t,tail:e,loc:r}){return function({head:s,tail:n,loc:a}){const i={type:"PathExpression",head:s,tail:n,get original(){return[this.head.original,...this.tail].join(".")},set original(l){let[o,...c]=We(l.split("."));this.head=En.head(o,this.head.loc),this.tail=c},loc:a};return Object.defineProperty(i,"parts",{enumerable:!1,get(){W("The parts property on path nodes is deprecated, use head and tail instead");let l=We(this.original.split("."));return l[0]==="this"?l.shift():l[0].startsWith("@")&&(l[0]=l[0].slice(1)),Object.freeze(l)},set(l){W("The parts property on mustache nodes is deprecated, use head and tail instead");let o=[...l];o[0]==="this"||o[0]?.startsWith("@")||(this.head.type==="ThisHead"?o.unshift("this"):this.head.type==="AtHead"&&(o[0]=`@${o[0]}`)),this.original=o.join(".")}}),Object.defineProperty(i,"this",{enumerable:!1,get(){return W("The this property on path nodes is deprecated, use head.type instead"),this.head.type==="ThisHead"}}),Object.defineProperty(i,"data",{enumerable:!1,get(){return W("The data property on path nodes is deprecated, use head.type instead"),this.head.type==="AtHead"}}),i}({head:t,tail:e,loc:r})}head({original:t,loc:e}){return t==="this"?this.this({loc:e}):t[0]==="@"?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:t,loc:e}){let r="";const s={type:"AtHead",get name(){return r},set name(n){v(n[0]==="@","call builders.at() with a string that starts with '@'"),v(n.indexOf(".")===-1,"builder.at() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}var({name:t,loc:e}){let r="";const s={type:"VarHead",get name(){return r},set name(n){v(n!=="this","You called builders.var() with 'this'. Call builders.this instead"),v(n[0]!=="@",`You called builders.var() with '${t}'. Call builders.at('${t}') instead`),v(n.indexOf(".")===-1,"builder.var() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:r}){return{type:"HashPair",key:t,value:e,loc:r}}literal({type:t,value:e,loc:r}){return function({type:s,value:n,loc:a}){const i={type:s,value:n,loc:a};return Object.defineProperty(i,"original",{enumerable:!1,get(){return W("The original property on literal nodes is deprecated, use value instead"),this.value},set(l){W("The original property on literal nodes is deprecated, use value instead"),this.value=l}}),i}({type:t,value:e,loc:r})}};let ji=class{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(e,r=new Zt(ln),s="precompile"){this.source=e,this.lines=e.source.split(/\r\n?|\n/u),this.tokenizer=new an(this,r,s)}offset(){let{line:e,column:r}=this.tokenizer;return this.source.offsetFor(e,r)}pos({line:e,column:r}){return this.source.offsetFor(e,r)}finish(e){return ae({},e,{loc:e.start.until(this.offset())})}get currentAttr(){return ot(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return v(e&&(e.type==="StartTag"||e.type==="EndTag"),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return v(e&&e.type==="StartTag","expected start tag"),e}get currentEndTag(){let e=this.currentNode;return v(e&&e.type==="EndTag","expected end tag"),e}get currentComment(){let e=this.currentNode;return v(e&&e.type==="CommentStatement","expected a comment"),e}get currentData(){let e=this.currentNode;return v(e&&e.type==="TextNode","expected a text node"),e}acceptNode(e){return this[e.type](e)}currentElement(){return tt(We(this.elementStack))}sourceForNode(e,r){let s,n,a,i=e.loc.start.line-1,l=i-1,o=e.loc.start.column,c=[];for(r?(n=r.loc.end.line-1,a=r.loc.end.column):(n=e.loc.end.line-1,a=e.loc.end.column);l<n;)l++,s=er(this.lines[l]),l===i?i===n?c.push(s.slice(o,a)):c.push(s.slice(o)):l===n?c.push(s.slice(0,a)):c.push(s);return c.join(`
`)}};const Os="beforeAttributeName";let Ki=class extends ji{pendingError=null;parse(e,r){let s=f.template({body:[],blockParams:r,loc:this.source.spanFor(e.loc)}),n=this.parseProgram(s,e);return this.pendingError?.eof(n.loc.getEnd()),n}Program(e,r){v(Array.isArray(r),"[BUG] Program in parser unexpectedly called without block params");let s=f.blockItself({body:[],params:r,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(s,e)}parseProgram(e,r){if(r.body.length===0)return e;let s;try{this.elementStack.push(e);for(let n of r.body)this.acceptNode(n)}finally{s=this.elementStack.pop()}if(e!==s){if(s?.type==="ElementNode")throw p(`Unclosed element \`${s.tag}\``,s.loc);v(s!==void 0,"[BUG] empty parser elementStack"),v(!1,`[BUG] mismatched parser elementStack node: ${e.type}`)}return e}BlockStatement(e){if(this.tokenizer.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));if(this.tokenizer.state!=="data"&&this.tokenizer.state!=="beforeData")throw p("A block may only be used inside an HTML element or another block.",this.source.spanFor(e.loc));const{path:r,params:s,hash:n}=pr(this,e),a=this.source.spanFor(e.loc);let i=[];if(e.program.blockParams?.length){let h=n.loc.collapse("end");h=e.program.loc?h.withEnd(this.source.spanFor(e.program.loc).getStart()):e.program.body[0]?h.withEnd(this.source.spanFor(e.program.body[0].loc).getStart()):h.withEnd(a.getEnd());const m=h.asString();let d=m.indexOf("|")+1;const y=m.indexOf("|",d);for(const S of e.program.blockParams){let I,z;I=d>=y?-1:m.indexOf(S,d),I===-1||I+S.length>y?(d=y,z=this.source.spanFor(ze)):(d=I,z=h.sliceStartChars({skipStart:d,chars:S.length}),d+=S.length),i.push(f.var({name:S,loc:z}))}}e.program.loc||(e.program.loc=ze),e.inverse&&!e.inverse.loc&&(e.inverse.loc=ze);const l=this.Program(e.program,i),o=e.inverse?this.Program(e.inverse,[]):null,c=f.block({path:r,params:s,hash:n,defaultBlock:l,elseBlock:o,loc:this.source.spanFor(e.loc),openStrip:e.openStrip,inverseStrip:e.inverseStrip,closeStrip:e.closeStrip});Ue(this.currentElement(),c)}MustacheStatement(e){this.pendingError?.mustache(this.source.spanFor(e.loc));const{tokenizer:r}=this;if(r.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));let s;const{escaped:n,loc:a,strip:i}=e;if("original"in e.path&&e.path.original==="...attributes")throw p("Illegal use of ...attributes",this.source.spanFor(e.loc));if(vn(e.path))s=f.mustache({path:this.acceptNode(e.path),params:[],hash:f.hash({pairs:[],loc:this.source.spanFor(e.path.loc).collapse("end")}),trusting:!n,loc:this.source.spanFor(a),strip:i});else{const{path:l,params:o,hash:c}=pr(this,e);s=f.mustache({path:l,params:o,hash:c,trusting:!n,loc:this.source.spanFor(a),strip:i})}switch(r.state){case"tagOpen":case"tagName":throw p("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":mr(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),mr(this.currentStartTag,s),r.transitionTo(Os);break;case"afterAttributeValueQuoted":mr(this.currentStartTag,s),r.transitionTo(Os);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),r.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:Ue(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(e){this.finalizeTextPart();const r=this.currentAttr;r.isDynamic=!0,r.parts.push(e)}finalizeTextPart(){const e=this.currentAttr.currentPart;e!==null&&(this.currentAttr.parts.push(e),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(e){(function(r,s){let n=s.loc.start.line,a=s.loc.start.column;const i=function(l,o){if(o==="")return{lines:l.split(`
`).length-1,columns:0};const[c]=l.split(o),h=c.split(/\n/u),m=h.length-1;return{lines:m,columns:er(h[m]).length}}(s.original,s.value);n+=i.lines,i.lines?a=i.columns:a+=i.columns,r.line=n,r.column=a})(this.tokenizer,e),this.tokenizer.tokenizePart(e.value),this.tokenizer.flushData()}CommentStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return this.appendToCommentData(this.sourceForNode(e)),null;const{value:s,loc:n}=e,a=f.mustacheComment({value:s,loc:this.source.spanFor(n)});switch(r.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(a);break;case"beforeData":case"data":Ue(this.currentElement(),a);break;default:throw p(`Using a Handlebars comment when in the \`${r.state}\` state is not supported`,this.source.spanFor(e.loc))}return a}PartialStatement(e){throw p("Handlebars partials are not supported",this.source.spanFor(e.loc))}PartialBlockStatement(e){throw p("Handlebars partial blocks are not supported",this.source.spanFor(e.loc))}Decorator(e){throw p("Handlebars decorators are not supported",this.source.spanFor(e.loc))}DecoratorBlock(e){throw p("Handlebars decorator blocks are not supported",this.source.spanFor(e.loc))}SubExpression(e){const{path:r,params:s,hash:n}=pr(this,e);return f.sexpr({path:r,params:s,hash:n,loc:this.source.spanFor(e.loc)})}PathExpression(e){const{original:r}=e;let s;if(r.indexOf("/")!==-1){if(r.slice(0,2)==="./")throw p('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(e.loc));if(r.slice(0,3)==="../")throw p('Changing context using "../" is not supported in Glimmer',this.source.spanFor(e.loc));if(r.indexOf(".")!==-1)throw p("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(e.loc));s=[e.parts.join("/")]}else{if(r===".")throw p("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(e.loc));s=e.parts}let n,a=!1;if(/^this(?:\..+)?$/u.test(r)&&(a=!0),a)n=f.this({loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+4}})});else if(e.data){const i=s.shift();if(i===void 0)throw p("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(e.loc));n=f.atName({name:`@${i}`,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length+1}})})}else{const i=s.shift();if(i===void 0)throw p("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(e.loc));n=f.var({name:i,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length}})})}return f.path({head:n,tail:s,loc:this.source.spanFor(e.loc)})}Hash(e){const r=e.pairs.map(s=>f.pair({key:s.key,value:this.acceptNode(s.value),loc:this.source.spanFor(s.loc)}));return f.hash({pairs:r,loc:this.source.spanFor(e.loc)})}StringLiteral(e){return f.literal({type:"StringLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}BooleanLiteral(e){return f.literal({type:"BooleanLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}NumberLiteral(e){return f.literal({type:"NumberLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}UndefinedLiteral(e){return f.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(e.loc)})}NullLiteral(e){return f.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(e.loc)})}};function pr(t,e){let r;switch(e.path.type){case"PathExpression":r=t.PathExpression(e.path);break;case"SubExpression":r=t.SubExpression(e.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let a;throw a=e.path.type==="BooleanLiteral"?e.path.original.toString():e.path.type==="StringLiteral"?`"${e.path.original}"`:e.path.type==="NullLiteral"?"null":e.path.type==="NumberLiteral"?e.path.value.toString():"undefined",p(`${e.path.type} "${e.path.type==="StringLiteral"?e.path.original:a}" cannot be called as a sub-expression, replace (${a}) with ${a}`,t.source.spanFor(e.path.loc))}}const s=e.params?e.params.map(a=>t.acceptNode(a)):[],n=F(s)?tt(s).loc:r.loc;return{path:r,params:s,hash:e.hash?t.Hash(e.hash):f.hash({pairs:[],loc:t.source.spanFor(n).collapse("end")})}}function mr(t,e){const{path:r,params:s,hash:n,loc:a}=e;if(vn(r)){const l=`{{${function(o){return o.type==="UndefinedLiteral"?"undefined":JSON.stringify(o.value)}(r)}}}`;throw p(`In <${t.name} ... ${l} ..., ${l} is not a valid modifier`,e.loc)}const i=f.elementModifier({path:r,params:s,hash:n,loc:a});t.modifiers.push(i)}function Oe(t){return/[\t\n\f ]/u.test(t)}let Ji=class extends Ki{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(e){this.currentComment.value+=e}finishComment(){Ue(this.currentElement(),f.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(e){this.currentData.chars+=e}finishData(){Ue(this.currentElement(),f.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let e=this.finish(this.currentTag);if(e.type==="StartTag"){if(this.finishStartTag(),e.name===":")throw p("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(Ar.has(e.name)||e.selfClosing)&&this.finishEndTag(!0)}else e.type==="EndTag"&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:r,nameEnd:s}=this.currentStartTag;v(e!=="","tag name cannot be empty"),v(r!==null,"nameStart unexpectedly null"),v(s!==null,"nameEnd unexpectedly null");let n=r.until(s),[a,...i]=We(e.split(".")),l=f.path({head:f.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:o,modifiers:c,comments:h,params:m,selfClosing:d,loc:y}=this.finish(this.currentStartTag),S=f.element({path:l,selfClosing:d,attributes:o,modifiers:c,comments:h,params:m,children:[],openTag:y,closeTag:d?null:D.broken(),loc:y});this.elementStack.push(S)}finishEndTag(e){let{start:r}=this.currentTag,s=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(s,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?v(n.closeTag===null,"element.closeTag unexpectedly present"):n.closeTag=r.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),Ue(a,f.element(n))}markTagAsSelfClosing(){let e=this.currentTag;if(e.type!=="StartTag")throw p("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:e.start.toJSON(),end:this.offset().toJSON()}));e.selfClosing=!0}appendToTagName(e){let r=this.currentTag;if(r.name+=e,r.type==="StartTag"){let s=this.offset();r.nameStart===null&&(v(r.nameEnd===null,"nameStart and nameEnd must both be null"),r.nameStart=s.move(-1)),r.nameEnd=s}}beginAttribute(){let e=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:e,valueSpan:e.collapsed()}}appendToAttributeName(e){this.currentAttr.name+=e,this.currentAttr.name==="as"&&this.parsePossibleBlockParams()}beginAttributeValue(e){this.currentAttr.isQuoted=e,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(e){let r=this.currentAttr.parts,s=r[r.length-1],n=this.currentAttr.currentPart;if(n)n.chars+=e,n.loc=n.loc.withEnd(this.offset());else{let a=this.offset();a=e===`
`?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():a.move(-1),this.currentAttr.currentPart=f.text({chars:e,loc:a.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let e=this.currentTag,r=this.offset();if(e.type==="EndTag")throw p("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:e.start.toJSON(),end:r.toJSON()}));let{name:s,parts:n,start:a,isQuoted:i,isDynamic:l,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&n.length===0&&!i&&!l)throw p("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",a.until(a.move(s.length)));let c=this.assembleAttributeValue(n,i,l,a.until(r));c.loc=o.withEnd(r);let h=f.attr({name:s,value:c,loc:a.until(r)});this.currentStartTag.attributes.push(h)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;v(this.tokenizer.state==="attributeName","must be in TokenizerState.attributeName");const r=this.currentStartTag,s=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:l=>{if(v(n.state==="PossibleAs","bug in block params parser"),Oe(l))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if(l==="|")throw p('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',s.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:l=>{v(n.state==="BeforeStartPipe","bug in block params parser"),Oe(l)?this.tokenizer.consume():l==="|"?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:l=>{if(v(n.state==="BeforeBlockParamName","bug in block params parser"),Oe(l))this.tokenizer.consume();else if(l==="")n={state:"Done"},this.pendingError={mustache(o){throw p("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"){if(r.params.length===0)throw p("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",s.start.until(this.offset().move(1)));n={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw p('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n={state:"BlockParamName",name:l,start:this.offset()},this.tokenizer.consume()}},BlockParamName:l=>{if(v(n.state==="BlockParamName","bug in block params parser"),l==="")n={state:"Done"},this.pendingError={mustache(o){throw p("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"||Oe(l)){let o=n.start.until(this.offset());if(n.name==="this"||e.test(n.name))throw p(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,o);r.params.push(f.var({name:n.name,loc:o})),n=l==="|"?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw p('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n.name+=l,this.tokenizer.consume()}},AfterEndPipe:l=>{v(n.state==="AfterEndPipe","bug in block params parser"),Oe(l)?this.tokenizer.consume():l===""?(n={state:"Done"},this.pendingError={mustache(o){throw p("Invalid block parameters syntax: modifiers cannot follow parameters list",o)},eof(o){throw p('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}}):l===">"||l==="/"?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:l=>{if(v(n.state==="Error","bug in block params parser"),l===""||l==="/"||l===">"||Oe(l))throw p(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{v(!1,"This should never be called")}};let i;do i=this.tokenizer.peek(),a[n.state](i);while(n.state!=="Done"&&i!=="");v(n.state==="Done","bug in block params parser")}reportSyntaxError(e){throw p(e,this.offset().collapsed())}assembleConcatenatedValue(e){for(const n of e)if(n.type!=="MustacheStatement"&&n.type!=="TextNode")throw p(`Unsupported node in quoted attribute value: ${n.type}`,n.loc);Je(e,"the concatenation parts of an element should not be empty");let r=Rr(e),s=tt(e);return f.concat({parts:e,loc:this.source.spanFor(r.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(e,r,s){if(Ar.has(e.name)&&!s)throw p(`<${e.name}> elements do not need end tags. You should remove it`,e.loc);if(r.tag===void 0)throw p(`Closing tag </${e.name}> without an open tag`,e.loc);if(r.tag!==e.name)throw p(`Closing tag </${e.name}> did not match last open tag <${r.tag}> (on line ${r.loc.startPosition.line})`,e.loc)}assembleAttributeValue(e,r,s,n){if(s){if(r)return this.assembleConcatenatedValue(e);{Je(e);const[a,i]=e;if(i===void 0||i.type==="TextNode"&&i.chars==="/")return a;throw p("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return F(e)?e[0]:f.text({chars:"",loc:n})}};const Wi={parse:An,builders:En,print:Hi,traverse:wn,Walker:Ri};let Yi=class extends Zt{constructor(){super({})}parse(){}};function An(t,e={}){let r,s,n,a=e.mode||"precompile";typeof t=="string"?(r=new Ve(t,e.meta?.moduleName),s=a==="codemod"?Mt(t,e.parseOptions):Dt(t,e.parseOptions)):t instanceof Ve?(r=t,s=a==="codemod"?Mt(t.source,e.parseOptions):Dt(t.source,e.parseOptions)):(r=new Ve("",e.meta?.moduleName),s=t),a==="codemod"&&(n=new Yi);let i=D.forCharPositions(r,0,r.source.length);s.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let l=new Ji(r,n,a).parse(s,e.locals??[]);if(e?.plugins?.ast)for(const o of e.plugins.ast)wn(l,o(ae({},e,{syntax:Wi},{plugins:void 0})).visitor);return l}function b(t){if(t!==void 0){const e=t;return{fields:()=>class{type;constructor(r){this.type=e,ae(this,r)}}}}return{fields:()=>class{constructor(e){ae(this,e)}}}}let rt=class Br extends b().fields(){static empty(e){return new Br({loc:e,positional:Vt.empty(e),named:st.empty(e)})}static named(e){return new Br({loc:e.loc,positional:Vt.empty(e.loc.collapse("end")),named:e})}nth(e){return this.positional.nth(e)}get(e){return this.named.get(e)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}},Vt=class xn extends b().fields(){static empty(e){return new xn({loc:e,exprs:[]})}get size(){return this.exprs.length}nth(e){return this.exprs[e]||null}isEmpty(){return this.exprs.length===0}},st=class Cn extends b().fields(){static empty(e){return new Cn({loc:e,entries:[]})}get size(){return this.entries.length}get(e){let r=this.entries.filter(s=>s.name.chars===e)[0];return r?r.value:null}isEmpty(){return this.entries.length===0}},qr=class{loc;name;value;constructor(e){this.loc=e.name.loc.extend(e.value.loc),this.name=e.name,this.value=e.value}},Pn=class extends b("HtmlAttr").fields(){},Nn=class extends b("SplatAttr").fields(){},Tn=class extends b().fields(){toNamedArgument(){return new qr({name:this.name,value:this.value})}},Bn=class extends b("ElementModifier").fields(){},Ln=class extends b("GlimmerComment").fields(){},$n=class extends b("HtmlText").fields(){},On=class extends b("HtmlComment").fields(){},Hn=class extends b("AppendContent").fields(){get callee(){return this.value.type==="Call"?this.value.callee:this.value}get args(){return this.value.type==="Call"?this.value.args:rt.empty(this.value.loc.collapse("end"))}},In=class extends b("InvokeBlock").fields(){},Ot=class extends b("InvokeComponent").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return rt.named(new st({loc:ve.range(e,this.callee.loc.collapse("end")),entries:e}))}},Fn=class extends b("SimpleElement").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return rt.named(new st({loc:ve.range(e,this.tag.loc.collapse("end")),entries:e}))}},Mn=class extends b("Literal").fields(){toSlice(){return new q({loc:this.loc,chars:this.value})}},Dn=class extends b("Path").fields(){},_n=class extends b("Keyword").fields(){},zn=class extends b("Call").fields(){},Vn=class extends b("Interpolate").fields(){},Un=class extends b().fields(){},Gn=class extends b().fields(){},Xr=class extends b().fields(){get(e){return this.blocks.filter(r=>r.name.chars===e)[0]||null}},Ge=class extends b().fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return rt.named(new st({loc:ve.range(e,this.name.loc.collapse("end")),entries:e}))}},Rn=class extends b("This").fields(){},jn=class extends b("Arg").fields(){},Kn=class extends b("Local").fields(){},Jn=class extends b("Free").fields(){};const j={resolution:()=>u.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},qi={...j,isAngleBracket:!0};let oe=class Lr{static namespaced(e,r=!1){return new Lr([e],r)}static append(){return new Lr([se.Component,se.Helper])}static trustingAppend(){return this.namespaced(se.Helper)}constructor(e,r=!1){this.namespaces=e,this.isAngleBracket=r}resolution(){if(this.namespaces.length!==1)return u.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case se.Helper:return u.GetFreeAsHelperHead;case se.Modifier:return u.GetFreeAsModifierHead;case se.Component:return u.GetFreeAsComponentHead}}serialize(){return this.namespaces.length===1?this.namespaces[0]:"ComponentOrHelper"}},se=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const Qr=se.Helper,Wn=se.Modifier,Zr=se.Component;var Se=Object.freeze({__proto__:null,AppendContent:Hn,ArgReference:jn,Args:rt,Block:Gn,COMPONENT_NAMESPACE:Zr,CallExpression:zn,ComponentArg:Tn,ElementModifier:Bn,FreeVarNamespace:se,FreeVarReference:Jn,GlimmerComment:Ln,HELPER_NAMESPACE:Qr,HTML_RESOLUTION:qi,HtmlAttr:Pn,HtmlComment:On,HtmlText:$n,InterpolateExpression:Vn,InvokeBlock:In,InvokeComponent:Ot,KeywordExpression:_n,LiteralExpression:Mn,LocalVarReference:Kn,LooseModeResolution:oe,MODIFIER_NAMESPACE:Wn,NamedArgument:qr,NamedArguments:st,NamedBlock:Ge,NamedBlocks:Xr,PathExpression:Dn,PositionalArguments:Vt,STRICT_RESOLUTION:j,SimpleElement:Fn,SplatAttr:Nn,Template:Un,ThisReference:Rn,isLiteral:function(t,e){return t.type==="Literal"&&(e===void 0||(e==="null"?t.value===null:typeof t.value===e))},isStrictResolution:function(t){return t===j},loadResolution:function(t){return t==="Strict"?j:t==="ComponentOrHelper"?oe.append():oe.namespaced(t)},node:b});let es=class{static top(e,r,s){return new Xi(e,r,s)}child(e){let r=e.map(s=>this.allocate(s));return new Qi(this,e,r)}},Xi=class extends es{constructor(e,r,s){super(),this.templateLocals=e,this.keywords=r,this.options=s}symbols=[];upvars=[];size=1;named=le();blocks=le();usedTemplateLocals=[];#e=!1;hasLexical(e){return this.options.lexicalScope(e)}hasKeyword(e){return this.keywords.includes(e)}getKeyword(e){return this.allocateFree(e,j)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#e=!0}get hasEval(){return this.#e}has(e){return this.templateLocals.includes(e)}get(e){let r=this.usedTemplateLocals.indexOf(e);return r!==-1||(r=this.usedTemplateLocals.length,this.usedTemplateLocals.push(e)),[r,!0]}getLocalsMap(){return le()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(e,r){r.resolution()===u.GetFreeAsComponentHead&&r.isAngleBracket&&(e=this.options.customizeComponentName(e));let s=this.upvars.indexOf(e);return s!==-1||(s=this.upvars.length,this.upvars.push(e)),s}allocateNamed(e){let r=this.named[e];return r||(r=this.named[e]=this.allocate(e)),r}allocateBlock(e){e==="inverse"&&(e="else");let r=this.blocks[e];return r||(r=this.blocks[e]=this.allocate(`&${e}`)),r}allocate(e){return this.symbols.push(e),this.size++}},Qi=class extends es{constructor(e,r,s){super(),this.parent=e,this.symbols=r,this.slots=s}get locals(){return this.symbols}hasLexical(e){return this.parent.hasLexical(e)}getKeyword(e){return this.parent.getKeyword(e)}hasKeyword(e){return this.parent.hasKeyword(e)}has(e){return this.symbols.indexOf(e)!==-1||this.parent.has(e)}get(e){let r=this.#e(e);return r?[r,!1]:this.parent.get(e)}#e(e){let r=this.symbols.indexOf(e);return r===-1?null:er(this.slots[r])}getLocalsMap(){let e=this.parent.getLocalsMap();return this.symbols.forEach(r=>e[r]=this.get(r)[0]),e}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(e,r){return this.parent.allocateFree(e,r)}allocateNamed(e){return this.parent.allocateNamed(e)}allocateBlock(e){return this.parent.allocateBlock(e)}allocate(e){return this.parent.allocate(e)}},Yn=class{template(e,r,s){return new Un({table:e,body:r,loc:s})}block(e,r,s){return new Gn({scope:e,body:r,loc:s})}namedBlock(e,r,s){return new Ge({name:e,block:r,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(e,r,s){return new Hs({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(e,r,s)}slice(e,r){return new q({loc:r,chars:e})}args(e,r,s){return new rt({loc:s,positional:e,named:r})}positional(e,r){return new Vt({loc:r,exprs:e})}namedArgument(e,r){return new qr({name:e,value:r})}named(e,r){return new st({loc:r,entries:e})}attr({name:e,value:r,trusting:s},n){return new Pn({loc:n,name:e,value:r,trusting:s})}splatAttr(e,r){return new Nn({symbol:e,loc:r})}arg({name:e,value:r,trusting:s},n){return new Tn({name:e,value:r,trusting:s,loc:n})}path(e,r,s){return new Dn({loc:s,ref:e,tail:r})}keyword(e,r,s){return new _n({loc:s,name:e,symbol:r})}self(e){return new Rn({loc:e})}at(e,r,s){return v(e[0]==="@","call builders.at() with a string that starts with '@'"),new jn({loc:s,name:new q({loc:s,chars:e}),symbol:r})}freeVar({name:e,context:r,symbol:s,loc:n}){return v(e!=="this","You called builders.freeVar() with 'this'. Call builders.this instead"),v(e[0]!=="@",`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new Jn({name:e,resolution:r,symbol:s,loc:n})}localVar(e,r,s,n){return v(e!=="this","You called builders.var() with 'this'. Call builders.this instead"),v(e[0]!=="@",`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new Kn({loc:n,name:e,isTemplateLocal:s,symbol:r})}sexp(e,r){return new zn({loc:r,callee:e.callee,args:e.args})}interpolate(e,r){return Je(e),new Vn({loc:r,parts:e})}literal(e,r){return new Mn({loc:r,value:e})}append({table:e,trusting:r,value:s},n){return new Hn({table:e,trusting:r,value:s,loc:n})}modifier({callee:e,args:r},s){return new Bn({loc:s,callee:e,args:r})}namedBlocks(e,r){return new Xr({loc:r,blocks:e})}blockStatement({program:e,inverse:r=null,...s},n){let a=e.loc,i=[this.namedBlock(q.synthetic("default"),e,e.loc)];return r&&(a=a.extend(r.loc),i.push(this.namedBlock(q.synthetic("else"),r,r.loc))),new In({loc:n,blocks:this.namedBlocks(i,a),callee:s.callee,args:s.args})}element(e){return new Hs(e)}},Hs=class{builder;constructor(e){this.base=e,this.builder=new Yn}simple(e,r,s){return new Fn(ae({tag:e,body:r,componentArgs:[],loc:s},this.base))}named(e,r,s){return new Ge(ae({name:e,block:r,componentArgs:[],loc:s},this.base))}selfClosingComponent(e,r){return new Ot(ae({loc:r,callee:e,blocks:new Xr({blocks:[],loc:r.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(e,r,s,n){let a=this.builder.block(s,r,n),i=this.builder.namedBlock(q.synthetic("default"),a,n);return new Ot(ae({loc:n,callee:e,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(e,r,s){return new Ot(ae({loc:s,callee:e,blocks:this.builder.namedBlocks(r,ve.range(r))},this.base))}};function Zi(t){return Et(t)?oe.namespaced(Qr):null}function el(t){return Et(t)?oe.namespaced(Wn):null}function tl(t){return Et(t)?oe.namespaced(Zr):null}function rl(t){return qn(t)?oe.namespaced(Zr,!0):null}function sl(t){return Et(t)?oe.namespaced(Qr):null}function nl(t){let e=Et(t),r=t.trusting;return e?r?oe.trustingAppend():oe.append():null}function Et(t){return qn(t.path)}function qn(t){return t.type==="PathExpression"&&t.head.type==="VarHead"&&t.tail.length===0}function al(t,e={lexicalScope:()=>!1}){let r=An(t,e),s={strictMode:!1,...e,locals:r.blockParams,keywords:e.keywords??[]},n=es.top(s.locals,s.keywords,{customizeComponentName:e.customizeComponentName??(o=>o),lexicalScope:e.lexicalScope}),a=new il(t,s,n),i=new Or(a);return[new ol(a.loc(r.loc),r.body.map(o=>i.normalize(o)),a).assertTemplate(n),n.getUsedTemplateLocals()]}let il=class Xn{builder;constructor(e,r,s){this.source=e,this.options=r,this.table=s,this.builder=new Yn}get strict(){return this.options.strictMode||!1}loc(e){return this.source.spanFor(e)}resolutionFor(e,r){if(this.strict)return{result:j};if(this.isFreeVar(e)){let s=r(e);return s===null?{result:"error",path:Zn(e),head:ea(e)}:{result:s}}return{result:j}}isLexicalVar(e){return this.table.hasLexical(e)}isKeyword(e){return this.strict&&!this.table.hasLexical(e)&&this.table.hasKeyword(e)}isFreeVar(e){return e.type==="PathExpression"?e.head.type==="VarHead"&&!this.table.has(e.head.name):e.path.type==="PathExpression"&&this.isFreeVar(e.path)}hasBinding(e){return this.table.has(e)||this.table.hasLexical(e)}child(e){return new Xn(this.source,this.options,this.table.child(e))}customizeComponentName(e){return this.options.customizeComponentName?this.options.customizeComponentName(e):e}},$r=class{constructor(e){this.block=e}normalize(e,r){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return v(r,"[BUG] resolution is required"),this.path(e,r);case"SubExpression":{dt(e.path)&&ft(e.path,e.loc);let s=this.block.resolutionFor(e,Zi);if(s.result==="error")throw p(`You attempted to invoke a path (\`${s.path}\`) but ${s.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,s.result),this.block.loc(e.loc))}}}path(e,r){let s=this.block.loc(e.loc);if(e.head.type==="VarHead"&&e.tail.length===0&&this.block.isKeyword(e.head.name))return this.block.builder.keyword(e.head.name,this.block.table.getKeyword(e.head.name),s);let n=[],a=this.block.loc(e.head.loc);for(let i of e.tail)a=a.sliceStartChars({chars:i.length,skipStart:1}),n.push(new q({loc:a,chars:i}));return this.block.builder.path(this.ref(e.head,r),n,s)}callParts(e,r){let{path:s,params:n,hash:a,loc:i}=e,l=this.normalize(s,r),o=n.map(S=>this.normalize(S,j)),c=ve.range(o,l.loc.collapse("end")),h=this.block.loc(a.loc),m=ve.range([c,h]),d=this.block.builder.positional(n.map(S=>this.normalize(S,j)),c),y=this.block.builder.named(a.pairs.map(S=>this.namedArgument(S)),this.block.loc(a.loc));switch(l.type){case"Literal":throw p(`Invalid invocation of a literal value (\`${l.value}\`)`,i);case"Interpolate":throw p("Invalid invocation of a interpolated string",i)}return{callee:l,args:this.block.builder.args(d,y,m)}}namedArgument(e){let r=this.block.loc(e.loc).sliceStartChars({chars:e.key.length});return this.block.builder.namedArgument(new q({chars:e.key,loc:r}),this.normalize(e.value,j))}ref(e,r){let{block:s}=this,{builder:n,table:a}=s,i=s.loc(e.loc);switch(e.type){case"ThisHead":return n.self(i);case"AtHead":{let l=a.allocateNamed(e.name);return n.at(e.name,l,i)}case"VarHead":if(s.hasBinding(e.name)){let[l,o]=a.get(e.name);return s.builder.localVar(e.name,l,o,i)}{let l=s.strict?j:r,o=s.table.allocateFree(e.name,l);return s.builder.freeVar({name:e.name,context:l,symbol:o,loc:i})}}}},Or=class Qn{constructor(e){this.block=e}normalize(e){switch(e.type){case"BlockStatement":return this.BlockStatement(e);case"ElementNode":return new ll(this.block).ElementNode(e);case"MustacheStatement":return this.MustacheStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":{let r=this.block.loc(e.loc);return new On({loc:r,text:r.slice({skipStart:4,skipEnd:3}).toSlice(e.value)})}case"TextNode":return new $n({loc:this.block.loc(e.loc),chars:e.chars})}}MustacheCommentStatement(e){let r,s=this.block.loc(e.loc);return r=s.asString().slice(0,5)==="{{!--"?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new Ln({loc:s,text:r.toSlice(e.value)})}MustacheStatement(e){let r,{path:s,params:n,hash:a,trusting:i}=e,l=this.block.loc(e.loc);if(dt(s))n.length===0&&a.pairs.length===0?r=this.expr.normalize(s):ft(s,l);else{let o=this.block.resolutionFor(e,nl);if(o.result==="error")throw p(`You attempted to render a path (\`{{${o.path}}}\`), but ${o.head} was not in scope`,l);let c=this.expr.callParts({path:s,params:n,hash:a,loc:l},o.result);r=c.args.isEmpty()?c.callee:this.block.builder.sexp(c,l)}return this.block.builder.append({table:this.block.table,trusting:i,value:r},l)}BlockStatement(e){let{program:r,inverse:s}=e,n=this.block.loc(e.loc);dt(e.path)&&ft(e.path,n);let a=this.block.resolutionFor(e,tl);if(a.result==="error")throw p(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(e,a.result);return this.block.builder.blockStatement(ae({symbols:this.block.table,program:this.Block(r),inverse:s?this.Block(s):null},i),n)}Block({body:e,loc:r,blockParams:s}){let n=this.block.child(s),a=new Qn(n);return new cl(this.block.loc(r),e.map(i=>a.normalize(i)),this.block).assertBlock(n.table)}get expr(){return new $r(this.block)}},ll=class{constructor(e){this.ctx=e}ElementNode(e){let{tag:r,selfClosing:s,comments:n}=e,a=this.ctx.loc(e.loc),[i,...l]=We(r.split(".")),o=this.classifyTag(i,l,e.loc),c=e.attributes.filter(P=>P.name[0]!=="@").map(P=>this.attr(P)),h=e.attributes.filter(P=>P.name[0]==="@").map(P=>this.arg(P)),m=e.modifiers.map(P=>this.modifier(P)),d=this.ctx.child(e.blockParams),y=new Or(d),S=e.children.map(P=>y.normalize(P)),I=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:m,comments:n.map(P=>new Or(this.ctx).MustacheCommentStatement(P))}),z=new ul(I,a,S,this.ctx),nt=this.ctx.loc(e.loc).sliceStartChars({chars:r.length,skipStart:1});if(o==="ElementHead")return r[0]===":"?z.assertNamedBlock(nt.slice({skipStart:1}).toSlice(r.slice(1)),d.table):z.assertElement(nt.toSlice(r),e.blockParams.length>0);if(e.selfClosing)return I.selfClosingComponent(o,a);{let P=z.assertComponent(r,d.table,e.blockParams.length>0);return I.componentWithNamedBlocks(o,P,a)}}modifier(e){dt(e.path)&&ft(e.path,e.loc);let r=this.ctx.resolutionFor(e,el);if(r.result==="error")throw p(`You attempted to invoke a path (\`{{${r.path}}}\`) as a modifier, but ${r.head} was not in scope`,e.loc);let s=this.expr.callParts(e,r.result);return this.ctx.builder.modifier(s,this.ctx.loc(e.loc))}mustacheAttr(e){let{path:r,params:s,hash:n,loc:a}=e;if(dt(r)){if(s.length===0&&n.pairs.length===0)return this.expr.normalize(r);ft(r,a)}let i=this.ctx.resolutionFor(e,sl);if(i.result==="error")throw p(`You attempted to render a path (\`{{${i.path}}}\`), but ${i.head} was not in scope`,e.loc);let l=this.ctx.builder.sexp(this.expr.callParts(e,i.result),this.ctx.loc(e.loc));return l.args.isEmpty()?l.callee:l}attrPart(e){switch(e.type){case"MustacheStatement":return{expr:this.mustacheAttr(e),trusting:e.trusting};case"TextNode":return{expr:this.ctx.builder.literal(e.chars,this.ctx.loc(e.loc)),trusting:!0}}}attrValue(e){if(e.type==="ConcatStatement"){let r=e.parts.map(s=>this.attrPart(s).expr);return{expr:this.ctx.builder.interpolate(r,this.ctx.loc(e.loc)),trusting:!1}}return this.attrPart(e)}attr(e){if(v(e.name[0]!=="@","An attr name must not start with `@`"),e.name==="...attributes")return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:s,value:n.expr,trusting:n.trusting},r)}checkArgCall(e){let{value:r}=e;if(r.type!=="MustacheStatement"||r.params.length!==0||r.hash.pairs.length!==0)return;let{path:s}=r;if(s.type!=="PathExpression"||s.tail.length>0)return;let n=this.ctx.resolutionFor(s,()=>null);if(n.result==="error"&&n.path!=="has-block")throw p(`You attempted to pass a path as argument (\`${e.name}={{${n.path}}}\`) but ${n.head} was not in scope. Try:
* \`${e.name}={{this.${n.path}}}\` if this is meant to be a property lookup, or
* \`${e.name}={{(${n.path})}}\` if this is meant to invoke the resolved helper, or
* \`${e.name}={{helper "${n.path}"}}\` if this is meant to pass the resolved helper by value`,e.loc)}arg(e){v(e.name[0]==="@","An arg name must start with `@`"),this.checkArgCall(e);let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.arg({name:s,value:n.expr,trusting:n.trusting},r)}classifyTag(e,r,s){let n=(a=e)[0]===a[0]?.toUpperCase()&&a[0]!==a[0]?.toLowerCase();var a;let i=e[0]==="@"||e==="this"||this.ctx.hasBinding(e);if(this.ctx.strict&&!i){if(n)throw p(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${e}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${e.toLowerCase()}>\``,s);return"ElementHead"}let l=i||n,o=s.sliceStartChars({skipStart:1,chars:e.length}),c=r.reduce((d,y)=>d+1+y.length,0),h=o.getEnd().move(c),m=o.withEnd(h);if(l){let d=f.path({head:f.head({original:e,loc:o}),tail:r,loc:m}),y=this.ctx.isLexicalVar(e)?{result:j}:this.ctx.resolutionFor(d,rl);if(y.result==="error")throw p(`You attempted to invoke a path (\`<${y.path}>\`) but ${y.head} was not in scope`,s);return new $r(this.ctx).normalize(d,y.result)}if(this.ctx.table.allocateFree(e,j),r.length>0)throw p(`You used ${e}.${r.join(".")} as a tag name, but ${e} is not in scope`,s);return"ElementHead"}get expr(){return new $r(this.ctx)}},ts=class{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(e,r,s){this.loc=e,this.children=r,this.block=s,this.namedBlocks=r.filter(n=>n instanceof Ge),this.hasSemanticContent=!!r.filter(n=>{if(n instanceof Ge)return!1;switch(n.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(n.chars);default:return!0}}).length,this.nonBlockChildren=r.filter(n=>!(n instanceof Ge))}},ol=class extends ts{assertTemplate(e){if(F(this.namedBlocks))throw p("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(e,this.nonBlockChildren,this.block.loc(this.loc))}},cl=class extends ts{assertBlock(e){if(F(this.namedBlocks))throw p("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(e,this.nonBlockChildren,this.loc)}},ul=class extends ts{constructor(e,r,s,n){super(r,s,n),this.el=e}assertNamedBlock(e,r){if(this.el.base.selfClosing)throw p(`<:${e.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(F(this.namedBlocks))throw p(`Unexpected named block inside <:${e.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=e.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw p(`<:${e.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw p(`named block <:${e.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=ve.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(e,this.block.builder.block(r,this.nonBlockChildren,n),this.loc)}assertElement(e,r){if(r)throw p(`Unexpected block params in <${e.chars}>: simple elements cannot have block params`,this.loc);if(F(this.namedBlocks)){let s=this.namedBlocks.map(n=>n.name);if(s.length===1)throw p(`Unexpected named block <:foo> inside <${e.chars}> HTML element`,this.loc);{let n=s.map(a=>`<:${a.chars}>`).join(", ");throw p(`Unexpected named blocks inside <${e.chars}> HTML element (${n})`,this.loc)}}return this.el.simple(e,this.nonBlockChildren,this.loc)}assertComponent(e,r,s){if(F(this.namedBlocks)&&this.hasSemanticContent)throw p(`Unexpected content inside <${e}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(F(this.namedBlocks)){if(s)throw p(`Unexpected block params list on <${e}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let n=new Set;for(let a of this.namedBlocks){let i=a.name.chars;if(n.has(i))throw p(`Component had two named blocks with the same name, \`<:${i}>\`. Only one block with a given name may be passed`,this.loc);if(i==="inverse"&&n.has("else")||i==="else"&&n.has("inverse"))throw p("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);n.add(i)}return this.namedBlocks}return[this.block.builder.namedBlock(q.synthetic("default"),this.block.builder.block(r,this.nonBlockChildren,this.loc),this.loc)]}};function dt(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function ft(t,e){throw p(`Unexpected literal \`${t.type==="StringLiteral"?JSON.stringify(t.value):String(t.value)}\``,e)}function Zn(t){return t.type!=="PathExpression"&&t.path.type==="PathExpression"?Zn(t.path):new Kr({entityEncoding:"raw"}).print(t)}function ea(t){return t.type==="PathExpression"?t.head.original:t.path.type==="PathExpression"?ea(t.path):new Kr({entityEncoding:"raw"}).print(t)}const G={Component:0,Helper:1,Modifier:2};(function(t){return t[t.pc=0]="pc",t[t.ra=1]="ra",t[t.fp=2]="fp",t[t.sp=3]="sp",t})({});(function(t){return t[t.s0=4]="s0",t[t.s1=5]="s1",t})({});(function(t){return t[t.t0=6]="t0",t[t.t1=7]="t1",t})({});let N=function(t){return t.Block="Block",t.Call="Call",t.Element="Element",t.AppendPath="AppendPath",t.AppendExpr="AppendExpr",t.Literal="Literal",t.Modifier="Modifier",t.DynamicComponent="DynamicComponent",t.Comment="Comment",t.Splat="Splat",t.Keyword="Keyword",t}({}),Y=function(t){return t.Local="Local",t.Free="Free",t.Arg="Arg",t.Block="Block",t.This="This",t}({});function ta(t){if(Array.isArray(t))return function(e){if(!Array.isArray(e))return!1;const r=e[0];if(typeof r=="number")switch(r){case H.Literal:case H.Get:case H.Concat:case H.HasBlock:case H.HasBlockParams:return!0;default:return!1}return r[0]==="("}(t)?Ds(t):function(e){if(Array.isArray(e)&&typeof e[0]=="string")switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(t)?function(e){const r=e[0];switch(r[0]){case"(":{let s=null,n=null;return e.length===3?(s=ce(e[1]),n=De(e[2])):e.length===2&&(Array.isArray(e[1])?s=ce(e[1]):n=De(e[1])),{kind:N.Call,head:lt(r),params:s,hash:n,trusted:!1}}case"#":{const{head:s,params:n,hash:a,blocks:i,blockParams:l}=Is(e);return{kind:N.Block,head:s,params:n,hash:a,blocks:i,blockParams:l}}case"!":{const s=e[0].slice(1),{params:n,hash:a,blocks:i,blockParams:l}=Is(e);return{kind:N.Keyword,name:s,params:n,hash:a,blocks:i,blockParams:l}}case"<":{let s=le(),n=[];return e.length===3?(s=Ms(e[1]),n=ct(e[2])):e.length===2&&(Array.isArray(e[1])?n=ct(e[1]):s=Ms(e[1])),{kind:N.Element,name:ot(pl(r),`BUG: expected ${r} to look like a tag name`),attrs:s,block:n}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(t):function(e){switch(e[0]){case H.Literal:return{kind:N.Literal,value:e[1]};case H.Append:return Ds(e[1],e[2]);case H.Modifier:return{kind:N.Modifier,params:ce(e[1]),hash:De(e[2])};case H.DynamicComponent:return{kind:N.DynamicComponent,expr:xt(e[1]),hash:De(e[2]),block:ct(e[3])};case H.Comment:return{kind:N.Comment,value:e[1]}}}(t);if(typeof t=="string")return Hr(At(t),!1);throw ue(t)}function Hr(t,e){return t.type===T.GetPath?{kind:N.AppendPath,path:t,trusted:e}:{kind:N.AppendExpr,expr:t,trusted:e}}function hl(t){const e=/^(#|!)(.*)$/u.exec(t);if(e===null)throw new Error("Unexpected missing # in block head");return At(e[2])}function lt(t){const e=/^\((.*)\)$/u.exec(t);if(e===null)throw new Error("Unexpected missing () in call head");return At(e[1])}function ra(t,e=[]){const r=sa(t);return F(e)?{type:T.GetPath,path:{head:r,tail:e}}:{type:T.GetVar,variable:r}}function At(t){const{kind:e,name:r}=sa(t),[s,...n]=r.split("."),a={kind:e,name:s,mode:"loose"};return F(n)?{type:T.GetPath,path:{head:a,tail:n}}:{type:T.GetVar,variable:a}}function sa(t){let e,r;if(/^this(?:\.|$)/u.test(t))return{kind:Y.This,name:t,mode:"loose"};switch(t[0]){case"^":e=Y.Free,r=t.slice(1);break;case"@":e=Y.Arg,r=t.slice(1);break;case"&":e=Y.Block,r=t.slice(1);break;default:e=Y.Local,r=t}return{kind:e,name:r,mode:"loose"}}function Is(t){const e=t[0];let r=le(),s=null,n=null,a=null;return t.length===2?r=dr(t[1]):t.length===3?(Array.isArray(t[1])?s=ce(t[1]):{hash:n,blockParams:a}=Fs(t[1]),r=dr(t[2])):t.length===4&&(s=ce(t[1]),{hash:n,blockParams:a}=Fs(t[2]),r=dr(t[3])),{head:hl(e),params:s,hash:n,blockParams:a,blocks:r}}function Fs(t){if(t===null)return{hash:null,blockParams:null};let e=null,r=null;return function(s,n){Object.keys(s).forEach(a=>{const i=s[a];n(a,i)})}(t,(s,n)=>{s==="as"?r=Array.isArray(n)?n:[n]:(e=e||le(),e[s]=xt(n))}),{hash:e,blockParams:r}}function dr(t){return Array.isArray(t)?{default:ct(t)}:rs(t,ct)}function ct(t){return t.map(e=>ta(e))}function Ms(t){return rs(t,e=>{return(r=e,r==="splat"?{expr:N.Splat,trusted:!1}:{expr:xt(r)}).expr;var r})}function rs(t,e){const r=le();return Object.keys(t).forEach(s=>{r[s]=e(t[s],s)}),r}function pl(t){return/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(t)?.[1]??null}let H=function(t){return t[t.Literal=0]="Literal",t[t.Comment=1]="Comment",t[t.Append=2]="Append",t[t.Modifier=3]="Modifier",t[t.DynamicComponent=4]="DynamicComponent",t[t.Get=5]="Get",t[t.Concat=6]="Concat",t[t.HasBlock=7]="HasBlock",t[t.HasBlockParams=8]="HasBlockParams",t}({}),T=function(t){return t.Literal="Literal",t.Call="Call",t.GetPath="GetPath",t.GetVar="GetVar",t.Concat="Concat",t.HasBlock="HasBlock",t.HasBlockParams="HasBlockParams",t}({});function Ds(t,e=!1){if(t==null)return{expr:{type:T.Literal,value:t},kind:N.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case H.Literal:return{expr:{type:T.Literal,value:t[1]},kind:N.AppendExpr,trusted:!1};case H.Get:return Hr(ra(t[1],t[2]),e);case H.Concat:return{expr:{type:T.Concat,params:ce(t.slice(1))},kind:N.AppendExpr,trusted:e};case H.HasBlock:return{expr:{type:T.HasBlock,name:t[1]},kind:N.AppendExpr,trusted:e};case H.HasBlockParams:return{expr:{type:T.HasBlockParams,name:t[1]},kind:N.AppendExpr,trusted:e};default:if(na(t))return{expr:aa(t),kind:N.AppendExpr,trusted:e};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw ue(t);switch(typeof t){case"string":return Hr(At(t),e);case"boolean":case"number":return{expr:{type:T.Literal,value:t},kind:N.AppendExpr,trusted:!0};default:throw ue(t)}}}function xt(t){if(t==null)return{type:T.Literal,value:t};if(Array.isArray(t))switch(t[0]){case H.Literal:return{type:T.Literal,value:t[1]};case H.Get:return ra(t[1],t[2]);case H.Concat:return{type:T.Concat,params:ce(t.slice(1))};case H.HasBlock:return{type:T.HasBlock,name:t[1]};case H.HasBlockParams:return{type:T.HasBlockParams,name:t[1]};default:if(na(t))return aa(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw ue(t);switch(typeof t){case"string":return At(t);case"boolean":case"number":return{type:T.Literal,value:t};default:throw ue(t)}}}function na(t){return typeof t[0]=="string"&&t[0][0]==="("}function ce(t){return t.map(xt)}function De(t){return t===null?null:rs(t,xt)}function aa(t){switch(t.length){case 1:return{type:T.Call,head:lt(t[0]),params:null,hash:null};case 2:return Array.isArray(t[1])?{type:T.Call,head:lt(t[0]),params:ce(t[1]),hash:null}:{type:T.Call,head:lt(t[0]),params:null,hash:De(t[1])};case 3:return{type:T.Call,head:lt(t[0]),params:ce(t[1]),hash:De(t[2])}}}class ia{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return fr(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return fr(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return fr(this._symbols,e)}child(e){return new ss(this,e)}}class ss{locals=le();constructor(e,r){this.parent=e;for(let s of r)this.locals[s]=e.top.symbol(s)}get paramSymbols(){return Ci(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new ss(this,e)}}function fr(t,e){let r=t.indexOf(e);return r===-1&&(r=t.length,t.push(e)),r}function _s(t){return new Error(`unimplemented ${t}`)}function ml(t,e){let r=[];return t.forEach(s=>r.push(...sr(ta(s),e))),r}function dl(t,e){let r=[];return t.forEach(s=>r.push(...sr(s,e))),r}function sr(t,e=new ia){switch(t.kind){case N.AppendPath:return[[t.trusted?u.TrustingAppend:u.Append,ns(t.path,e)]];case N.AppendExpr:return[[t.trusted?u.TrustingAppend:u.Append,$e(t.expr,t.trusted?"TrustedAppend":"Append",e)]];case N.Call:{let{head:r,params:s,hash:n,trusted:a}=t,i=s?Ut(s,e):null,l=n?Fr(n,e):null,o=Ir(r,a?Q.ResolveAsHelperHead:Q.ResolveAsComponentOrHelperHead,e);return[[a?u.TrustingAppend:u.Append,[u.Call,o,i,l]]]}case N.Literal:return[[u.Append,t.value]];case N.Comment:return[[u.Comment,t.value]];case N.Block:{let r=function(i,l,o){let c=[],h=[];for(const[m,d]of Object.entries(i))if(c.push(m),m==="default"){let y=o.child(l||[]);h.push(Gt(d,y,y.paramSymbols))}else h.push(Gt(d,o,[]));return[c,h]}(t.blocks,t.blockParams,e),s=Fr(t.hash,e),n=Ut(t.params,e),a=Ir(t.head,Q.ResolveAsComponentHead,e);return[[u.Block,a,n,s,r]]}case N.Keyword:return[yl(t,e)];case N.Element:return function({name:r,attrs:s,block:n},a){let i=[wl(s)?[u.OpenElementWithSplat,r]:[u.OpenElement,r]];if(s){let{params:l,args:o}=function(c,h){let m=[],d=[],y=[];for(const[S,I]of Object.entries(c))I===N.Splat?m.push([u.AttrSplat,h.block("&attrs")]):S[0]==="@"?(d.push(S),y.push($e(I,"Strict",h))):m.push(...Sl(S,I,vl(S),h));return{params:m,args:F(d)&&F(y)?[d,y]:null}}(s,a);i.push(...l),v(o===null,"Can't pass args to a simple element")}if(i.push([u.FlushElement]),Array.isArray(n))n.forEach(l=>i.push(...sr(l,a)));else if(n!==null)throw ue(n);return i.push([u.CloseElement]),i}(t,e);case N.Modifier:throw _s("modifier");case N.DynamicComponent:throw _s("dynamic component");default:throw ue(t)}}function fl(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[H.Literal,r]}function gl(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[H.Comment,r]}function bl(t){return String.fromCharCode(parseInt(t,16))}const kl=`
`;function yl(t,e){let{name:r}=t,s=Ut(t.params,e),n=e.child(t.blockParams||[]),a=Gt(t.blocks.default,n,n.paramSymbols),i=t.blocks.else?Gt(t.blocks.else,e,[]):null;switch(r){case"let":return[u.Let,ot(s,"let requires params"),a];case"if":return[u.If,ot(s,"if requires params")[0],a,i];case"each":{let l=t.hash?t.hash.key:null,o=l?$e(l,"Strict",e):null;return[u.Each,ot(s,"if requires params")[0],o,a,i]}default:throw new Error("unimplemented keyword")}}function wl(t){return t!==null&&Object.keys(t).some(e=>t[e]===N.Splat)}function vl(t){if(t==="xmlns")return Es;let e=/^([^:]*):([^:]*)$/u.exec(t);if(e===null)return null;switch(e[1]){case"xlink":return ki;case"xml":return yi;case"xmlns":return Es}return null}function Sl(t,e,r,s){if(e.type===T.Literal){let n=e.value;if(n===!1)return[];if(n===!0)return[[u.StaticAttr,t,"",r??void 0]];if(typeof n=="string")return[[u.StaticAttr,t,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[u.DynamicAttr,t,$e(e,"AttrValue",s),r??void 0]]}function zs(t,e){switch(t){case"Append":return e?"AppendBare":"AppendInvoke";case"TrustedAppend":return e?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return e?"AttrValueBare":"AttrValueInvoke";default:return t}}function $e(t,e,r){switch(t.type){case T.GetPath:return ns(t,r);case T.GetVar:return ut(t.variable,zs(e,!0),r);case T.Concat:return[u.Concat,El(t.params,r)];case T.Call:{let s=Ut(t.params,r),n=Fr(t.hash,r),a=Ir(t.head,e==="Strict"?"SubExpression":zs(e,!1),r);return[u.Call,a,s,n]}case T.HasBlock:return[u.HasBlock,ut({kind:Y.Block,name:t.name},Q.Strict,r)];case T.HasBlockParams:return[u.HasBlockParams,ut({kind:Y.Block,name:t.name},Q.Strict,r)];case T.Literal:return t.value===void 0?[u.Undefined]:t.value;default:ue(t)}}function Ir(t,e,r){return t.type===T.GetVar?ut(t.variable,e,r):ns(t,r)}function ns(t,e){return ut(t.path.head,Q.Strict,e,t.path.tail)}function ut(t,e,r,s){let n,a=u.GetSymbol;return t.kind===Y.Free?(a=e==="Strict"?u.GetStrictKeyword:e==="AppendBare"||e==="AppendInvoke"?u.GetFreeAsComponentOrHelperHead:e==="TrustedAppendBare"||e==="TrustedAppendInvoke"||e==="AttrValueBare"||e==="AttrValueInvoke"||e==="SubExpression"?u.GetFreeAsHelperHead:function(i){switch(i){case Q.Strict:return u.GetStrictKeyword;case Q.ResolveAsComponentOrHelperHead:return u.GetFreeAsComponentOrHelperHead;case Q.ResolveAsHelperHead:return u.GetFreeAsHelperHead;case Q.ResolveAsModifierHead:return u.GetFreeAsModifierHead;case Q.ResolveAsComponentHead:return u.GetFreeAsComponentHead;default:return ht(i)}}(e),n=r.freeVar(t.name)):(a=u.GetSymbol,n=function(i,l,o){switch(i){case Y.Arg:return l.arg(o);case Y.Block:return l.block(o);case Y.Local:return l.local(o);case Y.This:return l.this();default:return ht(i)}}(t.kind,r,t.name)),s===void 0||s.length===0?[a,n]:(v(a!==u.GetStrictKeyword,"[BUG] keyword with a path"),[a,n,s])}function Ut(t,e){return t!==null&&F(t)?t.map(r=>$e(r,"Strict",e)):null}function El(t,e){return t.map(r=>$e(r,"AttrValue",e))}function Fr(t,e){if(t===null)return null;let r=[[],[]];for(const[s,n]of Object.entries(t))r[0].push(s),r[1].push($e(n,"Strict",e));return r}function Gt(t,e,r=[]){return[dl(t,e),r]}class Al extends b("Template").fields(){}class xl extends b("InElement").fields(){}class la extends b("Not").fields(){}class Vs extends b("If").fields(){}class Cl extends b("IfInline").fields(){}class Pl extends b("Each").fields(){}class Nl extends b("Let").fields(){}class Tl extends b("WithDynamicVars").fields(){}class Bl extends b("GetDynamicVar").fields(){}class Ll extends b("Log").fields(){}class oa extends b("InvokeComponent").fields(){}class $l extends b("NamedBlocks").fields(){}class Ol extends b("NamedBlock").fields(){}class Hl extends b("AppendTrustedHTML").fields(){}class Rt extends b("AppendTextNode").fields(){}class Il extends b("AppendComment").fields(){}class Fl extends b("Component").fields(){}class Ml extends b("StaticAttr").fields(){}class Dl extends b("DynamicAttr").fields(){}class _l extends b("SimpleElement").fields(){}class zl extends b("ElementParameters").fields(){}class Vl extends b("Yield").fields(){}class Ul extends b("Debugger").fields(){}class ca extends b("CallExpression").fields(){}class Gl extends b("Modifier").fields(){}class Rl extends b("InvokeBlock").fields(){}class jl extends b("SplatAttr").fields(){}class Kl extends b("PathExpression").fields(){}class Jl extends b("Missing").fields(){}class Wl extends b("InterpolateExpression").fields(){}class Yl extends b("HasBlock").fields(){}class ql extends b("HasBlockParams").fields(){}class Xl extends b("Curry").fields(){}class Ql extends b("Positional").fields(){}class ua extends b("NamedArguments").fields(){}class ha extends b("NamedArgument").fields(){}class Zl extends b("Args").fields(){}class eo extends b("Tail").fields(){}class as{constructor(e){this.list=e}toArray(){return this.list}map(e){let r=on(this.list,e);return new as(r)}filter(e){let r=[];for(let s of this.list)e(s)&&r.push(s);return gt(r)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class jt{list=[];map(e){return new jt}filter(e){return new jt}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function gt(t){return F(t)?new as(t):new jt}class is{static all(...e){let r=[];for(let s of e){if(s.isErr)return s.cast();r.push(s.value)}return w(r)}}const _=is;class to extends is{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return w(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class pa extends is{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return E(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function w(t){return new to(t)}function E(t){return new pa(t)}class Le{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter(r=>r instanceof pa)[0];return e!==void 0?e.cast():w(this.items.map(r=>r.value))}toOptionalList(){return this.toArray().mapOk(e=>gt(e))}}function Kt(t){return t.type==="Path"&&t.ref.type==="Free"&&t.ref.name in _t?new Se.CallExpression({callee:t,args:Se.Args.empty(t.loc),loc:t.loc}):t}const C=new class{visit(t,e){switch(t.type){case"Literal":return w(this.Literal(t));case"Keyword":return w(this.Keyword(t));case"Interpolate":return this.Interpolate(t,e);case"Path":return this.PathExpression(t);case"Call":{let r=fo.translate(t,e);return r!==null?r:this.CallExpression(t,e)}}}visitList(t,e){return new Le(t.map(r=>C.visit(r,e))).toOptionalList()}PathExpression(t){let e=this.VariableReference(t.ref),{tail:r}=t;if(F(r)){let s=r[0].loc.extend(tt(r).loc);return w(new Kl({loc:t.loc,head:e,tail:new eo({loc:s,members:r})}))}return w(e)}VariableReference(t){return t}Literal(t){return t}Keyword(t){return t}Interpolate(t,e){let r=t.parts.map(Kt);return C.visitList(r,e).mapOk(s=>new Wl({loc:t.loc,parts:s}))}CallExpression(t,e){if(t.callee.type==="Call")throw new Error("unimplemented: subexpression at the head of a subexpression");return _.all(C.visit(t.callee,e),C.Args(t.args,e)).mapOk(([r,s])=>new ca({loc:t.loc,callee:r,args:s}))}Args({positional:t,named:e,loc:r},s){return _.all(this.Positional(t,s),this.NamedArguments(e,s)).mapOk(([n,a])=>new Zl({loc:r,positional:n,named:a}))}Positional(t,e){return C.visitList(t.exprs,e).mapOk(r=>new Ql({loc:t.loc,list:r}))}NamedArguments(t,e){let r=t.entries.map(s=>{let n=Kt(s.value);return C.visit(n,e).mapOk(a=>new ha({loc:s.loc,key:s.name,value:a}))});return new Le(r).toOptionalList().mapOk(s=>new ua({loc:t.loc,entries:s}))}};class ro{types;constructor(e,r,s){this.keyword=e,this.delegate=s;let n=new Set;for(let a of so[r])n.add(a);this.types=n}match(e){if(!this.types.has(e.type))return!1;let r=Jt(e);return r!==null&&r.type==="Path"&&r.ref.type==="Free"&&r.ref.name===this.keyword}translate(e,r){if(this.match(e)){let s=Jt(e);return s!==null&&s.type==="Path"&&s.tail.length>0?E(p(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${s.loc.asString()}\`, but it cannot be used with additional path segments. 

Error caused by`,e.loc)):this.delegate.assert(e,r).andThen(n=>this.delegate.translate({node:e,state:r},n))}return null}}const so={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function Jt(t){switch(t.type){case"Path":return t;case"AppendContent":return Jt(t.value);case"Call":case"InvokeBlock":case"ElementModifier":return t.callee;default:return null}}class no{_keywords=[];_type;constructor(e){this._type=e}kw(e,r){return this._keywords.push(function(s,n,a){return new ro(s,n,a)}(e,this._type,r)),this}translate(e,r){for(let n of this._keywords){let a=n.translate(e,r);if(a!==null)return a}let s=Jt(e);if(s&&s.type==="Path"&&s.ref.type==="Free"&&Ii(s.ref.name)){let{name:n}=s.ref,a=this._type,i=_t[n];if(!i.includes(a))return E(p(`The \`${n}\` keyword was used incorrectly. It was used as ${ao[a]}, but its valid usages are:

${function(l,o){return o.map(c=>{switch(c){case"Append":return`- As an append statement, as in: {{${l}}}`;case"Block":return`- As a block statement, as in: {{#${l}}}{{/${l}}}`;case"Call":return`- As an expression, as in: (${l})`;case"Modifier":return`- As a modifier, as in: <div {{${l}}}></div>`;default:return ht(c)}}).join(`

`)}(n,i)}

Error caused by`,e.loc))}return null}}const ao={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function nr(t){return new no(t)}function He({assert:t,translate:e}){return{assert:t,translate:({node:r,state:s},n)=>e({node:r,state:s},n).mapOk(a=>new Rt({text:a,loc:r.loc}))}}const io={[G.Component]:"component",[G.Helper]:"helper",[G.Modifier]:"modifier"};function Wt(t){return(e,r)=>{let s=io[t],n=t===G.Component,{args:a}=e,i=a.nth(0);if(i===null)return E(p(`(${s}) requires a ${s} definition or identifier as its first positional parameter, did not receive any parameters.`,a.loc));if(i.type==="Literal"){if(n&&r.isStrict)return E(p(`(${s}) cannot resolve string values in strict mode templates`,e.loc));if(!n)return E(p(`(${s}) cannot resolve string values, you must pass a ${s} definition directly`,e.loc))}return a=new Se.Args({positional:new Se.PositionalArguments({exprs:a.positional.exprs.slice(1),loc:a.positional.loc}),named:a.named,loc:a.loc}),w({definition:i,args:a})}}function lo(t){return({node:e,state:r},{definition:s,args:n})=>{let a=C.visit(s,r),i=C.Args(n,r);return _.all(a,i).mapOk(([l,o])=>new Xl({loc:e.loc,curriedType:t,definition:l,args:o}))}}function gr(t){return{assert:Wt(t),translate:lo(t)}}const ma={assert:function(t){let e=t.type==="AppendContent"?t.value:t,r=e.type==="Call"?e.args.named:null,s=e.type==="Call"?e.args.positional:null;if(r&&!r.isEmpty())return E(p("(-get-dynamic-vars) does not take any named arguments",t.loc));let n=s?.nth(0);return n?s&&s.size>1?E(p("(-get-dynamic-vars) only receives one positional arg",t.loc)):w(n):E(p("(-get-dynamic-vars) requires a var name to get",t.loc))},translate:function({node:t,state:e},r){return C.visit(r,e).mapOk(s=>new Bl({name:s,loc:t.loc}))}};function oo(t){return e=>{let r=e.type==="AppendContent"?e.value:e,s=r.type==="Call"?r.args.named:null,n=r.type==="Call"?r.args.positional:null;if(s&&!s.isEmpty())return E(p(`(${t}) does not take any named arguments`,r.loc));if(!n||n.isEmpty())return w(q.synthetic("default"));if(n.exprs.length===1){let a=n.exprs[0];return Se.isLiteral(a,"string")?w(a.toSlice()):E(p(`(${t}) can only receive a string literal as its first argument`,r.loc))}return E(p(`(${t}) only takes a single positional argument`,r.loc))}}function co(t){return({node:e,state:{scope:r}},s)=>w(t==="has-block"?new Yl({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}):new ql({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}))}function Yt(t){return{assert:oo(t),translate:co(t)}}function uo(t){return e=>{let r=t==="unless",s=e.type==="AppendContent"?e.value:e,n=s.type==="Call"?s.args.named:null,a=s.type==="Call"?s.args.positional:null;if(n&&!n.isEmpty())return E(p(`(${t}) cannot receive named parameters, received ${n.entries.map(c=>c.name.chars).join(", ")}`,e.loc));let i=a?.nth(0);if(!a||!i)return E(p(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,e.loc));let l=a.nth(1),o=a.nth(2);return l===null?E(p(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,e.loc)):a.size>3?E(p(`When used inline, (${t}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${t}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${a?.size??0} parameters`,e.loc)):w({condition:i,truthy:l,falsy:o})}}function ho(t){let e=t==="unless";return({node:r,state:s},{condition:n,truthy:a,falsy:i})=>{let l=C.visit(n,s),o=C.visit(a,s),c=i?C.visit(i,s):w(null);return _.all(l,o,c).mapOk(([h,m,d])=>(e&&(h=new la({value:h,loc:r.loc})),new Cl({loc:r.loc,condition:h,truthy:m,falsy:d})))}}function qt(t){return{assert:uo(t),translate:ho(t)}}const da={assert:function(t){let{args:{named:e,positional:r}}=t;return e&&!e.isEmpty()?E(p("(log) does not take any named arguments",t.loc)):w(r)},translate:function({node:t,state:e},r){return C.Positional(r,e).mapOk(s=>new Ll({positional:s,loc:t.loc}))}},po=nr("Append").kw("has-block",He(Yt("has-block"))).kw("has-block-params",He(Yt("has-block-params"))).kw("-get-dynamic-var",He(ma)).kw("log",He(da)).kw("if",He(qt("if"))).kw("unless",He(qt("unless"))).kw("yield",{assert(t){let{args:e}=t;if(e.named.isEmpty())return w({target:zt.SourceSpan.synthetic("default").toSlice(),positional:e.positional});{let r=e.named.get("to");return e.named.size>1||r===null?E(p("yield only takes a single named argument: 'to'",e.named.loc)):Se.isLiteral(r,"string")?w({target:r.toSlice(),positional:e.positional}):E(p("you can only yield to a literal string value",r.loc))}},translate:({node:t,state:e},{target:r,positional:s})=>C.Positional(s,e).mapOk(n=>new Vl({loc:t.loc,target:r,to:e.scope.allocateBlock(r.chars),positional:n}))}).kw("debugger",{assert(t){let{args:e}=t,{positional:r}=e;return e.isEmpty()?w(void 0):r.isEmpty()?E(p("debugger does not take any named arguments",t.loc)):E(p("debugger does not take any positional arguments",t.loc))},translate:({node:t,state:{scope:e}})=>(e.setHasDebugger(),w(new Ul({loc:t.loc,scope:e})))}).kw("component",{assert:Wt(G.Component),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e);return _.all(n,a).mapOk(([i,l])=>new oa({loc:t.loc,definition:i,args:l,blocks:null}))}}).kw("helper",{assert:Wt(G.Helper),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e);return _.all(n,a).mapOk(([i,l])=>{let o=new ca({callee:i,args:l,loc:t.loc});return new Rt({loc:t.loc,text:o})})}}),mo=nr("Block").kw("in-element",{assert(t){let{args:e}=t,r=e.get("guid");if(r)return E(p("Cannot pass `guid` to `{{#in-element}}`",r.loc));let s=e.get("insertBefore"),n=e.nth(0);return n===null?E(p("{{#in-element}} requires a target element as its first positional parameter",e.loc)):w({insertBefore:s,destination:n})},translate({node:t,state:e},{insertBefore:r,destination:s}){let n=t.blocks.get("default"),a=V.NamedBlock(n,e),i=C.visit(s,e);return _.all(a,i).andThen(([l,o])=>r?C.visit(r,e).mapOk(c=>({body:l,destination:o,insertBefore:c})):w({body:l,destination:o,insertBefore:new Jl({loc:t.callee.loc.collapse("end")})})).mapOk(({body:l,destination:o,insertBefore:c})=>new xl({loc:t.loc,block:l,insertBefore:c,guid:e.generateUniqueCursor(),destination:o}))}}).kw("if",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return E(p(`{{#if}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return E(p(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?E(p("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):w({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=C.visit(r,e),i=V.NamedBlock(s,e),l=n?V.NamedBlock(n,e):w(null);return _.all(a,i,l).mapOk(([o,c,h])=>new Vs({loc:t.loc,condition:o,block:c,inverse:h}))}}).kw("unless",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return E(p(`{{#unless}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return E(p(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?E(p("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):w({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=C.visit(r,e),i=V.NamedBlock(s,e),l=n?V.NamedBlock(n,e):w(null);return _.all(a,i,l).mapOk(([o,c,h])=>new Vs({loc:t.loc,condition:new la({value:o,loc:t.loc}),block:c,inverse:h}))}}).kw("each",{assert(t){let{args:e}=t;if(!e.named.entries.every(n=>n.name.chars==="key"))return E(p(`{{#each}} can only receive the 'key' named parameter, received ${e.named.entries.filter(n=>n.name.chars!=="key").map(n=>n.name.chars).join(", ")}`,e.named.loc));if(e.positional.size>1)return E(p(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${e.positional.size} parameters`,e.positional.loc));let r=e.nth(0),s=e.get("key");return r===null?E(p("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",e.loc)):w({value:r,key:s})},translate({node:t,state:e},{value:r,key:s}){let n=t.blocks.get("default"),a=t.blocks.get("else"),i=C.visit(r,e),l=s?C.visit(s,e):w(null),o=V.NamedBlock(n,e),c=a?V.NamedBlock(a,e):w(null);return _.all(i,l,o,c).mapOk(([h,m,d,y])=>new Pl({loc:t.loc,value:h,key:m,block:d,inverse:y}))}}).kw("let",{assert(t){let{args:e}=t;return e.named.isEmpty()?e.positional.size===0?E(p("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",e.positional.loc)):t.blocks.get("else")?E(p("{{#let}} cannot receive an {{else}} block",e.positional.loc)):w({positional:e.positional}):E(p(`{{#let}} cannot receive named parameters, received ${e.named.entries.map(r=>r.name.chars).join(", ")}`,e.named.loc))},translate({node:t,state:e},{positional:r}){let s=t.blocks.get("default"),n=C.Positional(r,e),a=V.NamedBlock(s,e);return _.all(n,a).mapOk(([i,l])=>new Nl({loc:t.loc,positional:i,block:l}))}}).kw("-with-dynamic-vars",{assert:t=>w({named:t.args.named}),translate({node:t,state:e},{named:r}){let s=t.blocks.get("default"),n=C.NamedArguments(r,e),a=V.NamedBlock(s,e);return _.all(n,a).mapOk(([i,l])=>new Tl({loc:t.loc,named:i,block:l}))}}).kw("component",{assert:Wt(G.Component),translate({node:t,state:e},{definition:r,args:s}){let n=C.visit(r,e),a=C.Args(s,e),i=V.NamedBlocks(t.blocks,e);return _.all(n,a,i).mapOk(([l,o,c])=>new oa({loc:t.loc,definition:l,args:o,blocks:c}))}}),fo=nr("Call").kw("has-block",Yt("has-block")).kw("has-block-params",Yt("has-block-params")).kw("-get-dynamic-var",ma).kw("log",da).kw("if",qt("if")).kw("unless",qt("unless")).kw("component",gr(G.Component)).kw("helper",gr(G.Helper)).kw("modifier",gr(G.Modifier)),go=nr("Modifier"),Ne="http://www.w3.org/1999/xlink",br="http://www.w3.org/XML/1998/namespace",Us="http://www.w3.org/2000/xmlns/",bo={"xlink:actuate":Ne,"xlink:arcrole":Ne,"xlink:href":Ne,"xlink:role":Ne,"xlink:show":Ne,"xlink:title":Ne,"xlink:type":Ne,"xml:base":br,"xml:lang":br,"xml:space":br,xmlns:Us,"xmlns:xlink":Us},ko={div:Tt.div,span:Tt.span,p:Tt.p,a:Tt.a},yo=["div","span","p","a"];function Gs(t){return typeof t=="string"?t:yo[t]}const wo={class:Pe.class,id:Pe.id,value:Pe.value,name:Pe.name,type:Pe.type,style:Pe.style,href:Pe.href},vo=["class","id","value","name","type","style","href"];function fa(t){return wo[t]??t}function Ie(t){return typeof t=="string"?t:vo[t]}class Rs{delegate;constructor(e,r,s){this.element=e,this.state=s,this.delegate=r}toStatement(){return this.prepare().andThen(e=>this.delegate.toStatement(this,e))}attr(e){let r=e.name,s=e.value,n=(a=r.chars,bo[a]||void 0);var a;return Se.isLiteral(s,"string")?w(new Ml({loc:e.loc,name:r,value:s.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):C.visit(Kt(s),this.state).mapOk(i=>{let l=e.trusting;return new Dl({loc:e.loc,name:r,value:i,namespace:n,kind:{trusting:l,component:this.delegate.dynamicFeatures}})})}modifier(e){let r=go.translate(e,this.state);if(r!==null)return r;let s=C.visit(e.callee,this.state),n=C.Args(e.args,this.state);return _.all(s,n).mapOk(([a,i])=>new Gl({loc:e.loc,callee:a,args:i}))}attrs(){let e=new Le,r=new Le,s=null,n=this.element.attrs.filter(a=>a.type==="SplatAttr").length===0;for(let a of this.element.attrs)a.type==="SplatAttr"?e.add(w(new jl({loc:a.loc,symbol:this.state.scope.allocateBlock("attrs")}))):a.name.chars==="type"&&n?s=a:e.add(this.attr(a));for(let a of this.element.componentArgs)r.add(this.delegate.arg(a,this));return s&&e.add(this.attr(s)),_.all(r.toArray(),e.toArray()).mapOk(([a,i])=>({attrs:i,args:new ua({loc:Tr(a,zt.SourceSpan.NON_EXISTENT),entries:gt(a)})}))}prepare(){let e=this.attrs(),r=new Le(this.element.modifiers.map(s=>this.modifier(s))).toArray();return _.all(e,r).mapOk(([s,n])=>{let{attrs:a,args:i}=s,l=[...a,...n];return{args:i,params:new zl({loc:Tr(l,zt.SourceSpan.NON_EXISTENT),body:gt(l)})}})}}class So{dynamicFeatures=!0;constructor(e,r){this.tag=e,this.element=r}arg(e,{state:r}){let s=e.name;return C.visit(Kt(e.value),r).mapOk(n=>new ha({loc:e.loc,key:s,value:n}))}toStatement(e,{args:r,params:s}){let{element:n,state:a}=e;return this.blocks(a).mapOk(i=>new Fl({loc:n.loc,tag:this.tag,params:s,args:r,blocks:i}))}blocks(e){return V.NamedBlocks(this.element.blocks,e)}}class Eo{constructor(e,r,s){this.tag=e,this.element=r,this.dynamicFeatures=s}isComponent=!1;arg(e){return E(p(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:r}){let{state:s,element:n}=e;return V.visitList(this.element.body,s).mapOk(a=>new _l({loc:n.loc,tag:this.tag,params:r,body:a.toArray(),dynamicFeatures:this.dynamicFeatures}))}}const V=new class{visitList(t,e){return new Le(t.map(r=>V.visit(r,e))).toOptionalList().mapOk(r=>r.filter(s=>s!==null))}visit(t,e){switch(t.type){case"GlimmerComment":return w(null);case"AppendContent":return this.AppendContent(t,e);case"HtmlText":return w(this.TextNode(t));case"HtmlComment":return w(this.HtmlComment(t));case"InvokeBlock":return this.InvokeBlock(t,e);case"InvokeComponent":return this.Component(t,e);case"SimpleElement":return this.SimpleElement(t,e)}}InvokeBlock(t,e){let r=mo.translate(t,e);if(r!==null)return r;let s=C.visit(t.callee,e),n=C.Args(t.args,e);return _.all(s,n).andThen(([a,i])=>this.NamedBlocks(t.blocks,e).mapOk(l=>new Rl({loc:t.loc,head:a,args:i,blocks:l})))}NamedBlocks(t,e){return new Le(t.blocks.map(r=>this.NamedBlock(r,e))).toArray().mapOk(r=>new $l({loc:t.loc,blocks:gt(r)}))}NamedBlock(t,e){return e.visitBlock(t.block).mapOk(r=>new Ol({loc:t.loc,name:t.name,body:r.toArray(),scope:t.block.scope}))}SimpleElement(t,e){return new Rs(t,new Eo(t.tag,t,function({attrs:r,modifiers:s}){return s.length>0||!!r.filter(n=>n.type==="SplatAttr")[0]}(t)),e).toStatement()}Component(t,e){return C.visit(t.callee,e).andThen(r=>new Rs(t,new So(r,t),e).toStatement())}AppendContent(t,e){let r=po.translate(t,e);return r!==null?r:C.visit(t.value,e).mapOk(s=>t.trusting?new Hl({loc:t.loc,html:s}):new Rt({loc:t.loc,text:s}))}TextNode(t){return new Rt({loc:t.loc,text:new Se.LiteralExpression({loc:t.loc,value:t.chars})})}HtmlComment(t){return new Il({loc:t.loc,value:t.text})}};class Ao{_currentScope;_cursorCount=0;constructor(e,r){this.isStrict=r,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let r=this._currentScope;this._currentScope=e.scope;try{return V.visitList(e.body,this)}finally{this._currentScope=r}}}var R=function(t){return t.Value="value",t.Component="component",t.Helper="helper",t.Modifier="modifier",t.ComponentOrHelper="component or helper",t}(R||{});class xo{static validate(e){return new this(e).validate()}constructor(e){this.template=e}validate(){return this.Statements(this.template.body).mapOk(()=>this.template)}Statements(e){let r=w(null);for(let s of e)r=r.andThen(()=>this.Statement(s));return r}NamedBlocks({blocks:e}){let r=w(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedBlock(s));return r}NamedBlock(e){return this.Statements(e.body)}Statement(e){switch(e.type){case"InElement":return this.InElement(e);case"Debugger":case"AppendComment":return w(null);case"Yield":return this.Yield(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"AppendTextNode":return this.AppendTextNode(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e)}}Expressions(e){let r=w(null);for(let s of e)r=r.andThen(()=>this.Expression(s));return r}Expression(e,r=e,s){switch(e.type){case"Literal":case"Keyword":case"Missing":case"This":case"Arg":case"Local":case"HasBlock":case"HasBlockParams":case"GetDynamicVar":return w(null);case"PathExpression":return this.Expression(e.head,r,s);case"Free":return this.errorFor(e.name,r,s);case"InterpolateExpression":return this.InterpolateExpression(e,r,s);case"CallExpression":return this.CallExpression(e,r,s??R.Helper);case"Not":return this.Expression(e.value,r,s);case"IfInline":return this.IfInline(e);case"Curry":return this.Curry(e);case"Log":return this.Log(e)}}Args(e){return this.Positional(e.positional).andThen(()=>this.NamedArguments(e.named))}Positional(e,r){let s=w(null),n=e.list.toArray();return s=n.length===1?this.Expression(n[0],r):this.Expressions(n),s}NamedArguments({entries:e}){let r=w(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedArgument(s));return r}NamedArgument(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,R.Helper):this.Expression(e.value,e)}ElementParameters({body:e}){let r=w(null);for(let s of e.toArray())r=r.andThen(()=>this.ElementParameter(s));return r}ElementParameter(e){switch(e.type){case"StaticAttr":case"SplatAttr":return w(null);case"DynamicAttr":return this.DynamicAttr(e);case"Modifier":return this.Modifier(e)}}DynamicAttr(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,R.Helper):this.Expression(e.value,e)}Modifier(e){return this.Expression(e.callee,e,R.Modifier).andThen(()=>this.Args(e.args))}InElement(e){return this.Expression(e.destination).andThen(()=>this.Expression(e.insertBefore)).andThen(()=>this.NamedBlock(e.block))}Yield(e){return this.Positional(e.positional,e)}AppendTrustedHTML(e){return this.Expression(e.html,e)}AppendTextNode(e){return e.text.type==="CallExpression"?this.Expression(e.text,e,R.ComponentOrHelper):this.Expression(e.text,e)}Component(e){return this.Expression(e.tag,e,R.Component).andThen(()=>this.ElementParameters(e.params)).andThen(()=>this.NamedArguments(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}SimpleElement(e){return this.ElementParameters(e.params).andThen(()=>this.Statements(e.body))}InvokeBlock(e){return this.Expression(e.head,e.head,R.Component).andThen(()=>this.Args(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}If(e){return this.Expression(e.condition,e).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):w(null))}Each(e){return this.Expression(e.value,e).andThen(()=>e.key?this.Expression(e.key,e):w(null)).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):w(null))}Let(e){return this.Positional(e.positional).andThen(()=>this.NamedBlock(e.block))}WithDynamicVars(e){return this.NamedArguments(e.named).andThen(()=>this.NamedBlock(e.block))}InvokeComponent(e){return this.Expression(e.definition,e,R.Component).andThen(()=>this.Args(e.args)).andThen(()=>e.blocks?this.NamedBlocks(e.blocks):w(null))}InterpolateExpression(e,r,s){let n=e.parts.toArray();return n.length===1?this.Expression(n[0],r,s):this.Expressions(n)}CallExpression(e,r,s){return this.Expression(e.callee,r,s).andThen(()=>this.Args(e.args))}IfInline(e){return this.Expression(e.condition).andThen(()=>this.Expression(e.truthy)).andThen(()=>e.falsy?this.Expression(e.falsy):w(null))}Curry(e){let r;return r=e.curriedType===G.Component?R.Component:e.curriedType===G.Helper?R.Helper:R.Modifier,this.Expression(e.definition,e,r).andThen(()=>this.Args(e.args))}Log(e){return this.Positional(e.positional,e)}errorFor(e,r,s=R.Value){return E(p(`Attempted to resolve a ${s} in a strict mode template, but that value was not in scope: ${e}`,qe(r)))}}class Co{upvars;symbols;constructor([e,r,s,n]){this.upvars=n,this.symbols=r}format(e){let r=[];for(let s of e[0])r.push(this.formatOpcode(s));return r}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case u.Append:return["append",this.formatOpcode(e[1])];case u.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case u.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case u.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case u.OpenElement:return["open-element",Gs(e[1])];case u.OpenElementWithSplat:return["open-element-with-splat",Gs(e[1])];case u.CloseElement:return["close-element"];case u.FlushElement:return["flush-element"];case u.StaticAttr:return["static-attr",Ie(e[1]),e[2],e[3]];case u.StaticComponentAttr:return["static-component-attr",Ie(e[1]),e[2],e[3]];case u.DynamicAttr:return["dynamic-attr",Ie(e[1]),this.formatOpcode(e[2]),e[3]];case u.ComponentAttr:return["component-attr",Ie(e[1]),this.formatOpcode(e[2]),e[3]];case u.AttrSplat:return["attr-splat"];case u.Yield:return["yield",e[1],this.formatParams(e[2])];case u.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case u.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case u.TrustingDynamicAttr:return["trusting-dynamic-attr",Ie(e[1]),this.formatOpcode(e[2]),e[3]];case u.TrustingComponentAttr:return["trusting-component-attr",Ie(e[1]),this.formatOpcode(e[2]),e[3]];case u.Debugger:return["debugger",e[1]];case u.Comment:return["comment",e[1]];case u.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case u.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case u.HasBlock:return["has-block",this.formatOpcode(e[1])];case u.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case u.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case u.Undefined:return["undefined"];case u.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case u.Concat:return["concat",this.formatParams(e[1])];case u.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]]];case u.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case u.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case u.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case u.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case u.GetSymbol:return e[1]===0?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case u.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case u.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case u.IfInline:return["if-inline"];case u.Not:return["not"];case u.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case u.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case u.Log:return["log",this.formatParams(e[1])];case u.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case u.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case u.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case G.Component:return"component";case G.Helper:return"helper";case G.Modifier:return"modifier";default:throw ht(e)}}formatElementParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatHash(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatOpcode(e[1][n]),r),le())}formatBlocks(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatBlock(e[1][n]),r),le())}formatBlock(e){return{statements:e[0].map(r=>this.formatOpcode(r)),parameters:e[1]}}}const x=new class{expr(t){switch(t.type){case"Missing":return;case"Literal":return this.Literal(t);case"Keyword":return this.Keyword(t);case"CallExpression":return this.CallExpression(t);case"PathExpression":return this.PathExpression(t);case"Arg":return[u.GetSymbol,t.symbol];case"Local":return this.Local(t);case"This":return[u.GetSymbol,0];case"Free":return[t.resolution.resolution(),t.symbol];case"HasBlock":return this.HasBlock(t);case"HasBlockParams":return this.HasBlockParams(t);case"Curry":return this.Curry(t);case"Not":return this.Not(t);case"IfInline":return this.IfInline(t);case"InterpolateExpression":return this.InterpolateExpression(t);case"GetDynamicVar":return this.GetDynamicVar(t);case"Log":return this.Log(t)}}Literal({value:t}){return t===void 0?[u.Undefined]:t}Missing(){}HasBlock({symbol:t}){return[u.HasBlock,[u.GetSymbol,t]]}HasBlockParams({symbol:t}){return[u.HasBlockParams,[u.GetSymbol,t]]}Curry({definition:t,curriedType:e,args:r}){return[u.Curry,x.expr(t),e,x.Positional(r.positional),x.NamedArguments(r.named)]}Local({isTemplateLocal:t,symbol:e}){return[t?u.GetLexicalSymbol:u.GetSymbol,e]}Keyword({symbol:t}){return[u.GetStrictKeyword,t]}PathExpression({head:t,tail:e}){let r=x.expr(t);return v(r[0]!==u.GetStrictKeyword,"[BUG] keyword in a PathExpression"),[...r,x.Tail(e)]}InterpolateExpression({parts:t}){return[u.Concat,t.map(e=>x.expr(e)).toArray()]}CallExpression({callee:t,args:e}){return[u.Call,x.expr(t),...x.Args(e)]}Tail({members:t}){return on(t,e=>e.chars)}Args({positional:t,named:e}){return[this.Positional(t),this.NamedArguments(e)]}Positional({list:t}){return t.map(e=>x.expr(e)).toPresentArray()}NamedArgument({key:t,value:e}){return[t.chars,x.expr(e)]}NamedArguments({entries:t}){let e=t.toArray();if(F(e)){let r=[],s=[];for(let n of e){let[a,i]=x.NamedArgument(n);r.push(a),s.push(i)}return Je(r),Je(s),[r,s]}return null}Not({value:t}){return[u.Not,x.expr(t)]}IfInline({condition:t,truthy:e,falsy:r}){let s=[u.IfInline,x.expr(t),x.expr(e)];return r&&s.push(x.expr(r)),s}GetDynamicVar({name:t}){return[u.GetDynamicVar,x.expr(t)]}Log({positional:t}){return[u.Log,this.Positional(t)]}};class js{constructor(e){this.statements=e}toArray(){return this.statements}}const M=new class{list(t){let e=[];for(let r of t){let s=M.content(r);s&&s instanceof js?e.push(...s.toArray()):e.push(s)}return e}content(t){return this.visitContent(t)}visitContent(t){switch(t.type){case"Debugger":return[u.Debugger,t.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(t);case"AppendTextNode":return this.AppendTextNode(t);case"AppendTrustedHTML":return this.AppendTrustedHTML(t);case"Yield":return this.Yield(t);case"Component":return this.Component(t);case"SimpleElement":return this.SimpleElement(t);case"InElement":return this.InElement(t);case"InvokeBlock":return this.InvokeBlock(t);case"If":return this.If(t);case"Each":return this.Each(t);case"Let":return this.Let(t);case"WithDynamicVars":return this.WithDynamicVars(t);case"InvokeComponent":return this.InvokeComponent(t);default:return ht(t)}}Yield({to:t,positional:e}){return[u.Yield,t,x.Positional(e)]}InElement({guid:t,insertBefore:e,destination:r,block:s}){let n=M.NamedBlock(s)[1],a=x.expr(r),i=x.expr(e);return i===void 0?[u.InElement,n,t,a]:[u.InElement,n,t,a,i]}InvokeBlock({head:t,args:e,blocks:r}){return[u.Block,x.expr(t),...x.Args(e),M.NamedBlocks(r)]}AppendTrustedHTML({html:t}){return[u.TrustingAppend,x.expr(t)]}AppendTextNode({text:t}){return[u.Append,x.expr(t)]}AppendComment({value:t}){return[u.Comment,t.chars]}SimpleElement({tag:t,params:e,body:r,dynamicFeatures:s}){let n=s?u.OpenElementWithSplat:u.OpenElement;return new js([[n,(a=t.chars,ko[a]??a)],...M.ElementParameters(e).toArray(),[u.FlushElement],...M.list(r),[u.CloseElement]]);var a}Component({tag:t,params:e,args:r,blocks:s}){let n=x.expr(t),a=M.ElementParameters(e),i=x.NamedArguments(r),l=M.NamedBlocks(s);return[u.Component,n,a.toPresentArray(),i,l]}ElementParameters({body:t}){return t.map(e=>M.ElementParameter(e))}ElementParameter(t){switch(t.type){case"SplatAttr":return[u.AttrSplat,t.symbol];case"DynamicAttr":return[(e=t.kind,e.component?e.trusting?u.TrustingComponentAttr:u.ComponentAttr:e.trusting?u.TrustingDynamicAttr:u.DynamicAttr),...No(t)];case"StaticAttr":return[To(t.kind),...Po(t)];case"Modifier":return[u.Modifier,x.expr(t.callee),...x.Args(t.args)]}var e}NamedBlocks({blocks:t}){let e=[],r=[];for(let s of t.toArray()){let[n,a]=M.NamedBlock(s);e.push(n),r.push(a)}return e.length>0?[e,r]:null}NamedBlock({name:t,body:e,scope:r}){let s=t.chars;return s==="inverse"&&(s="else"),[s,[M.list(e),r.slots]]}If({condition:t,block:e,inverse:r}){return[u.If,x.expr(t),M.NamedBlock(e)[1],r?M.NamedBlock(r)[1]:null]}Each({value:t,key:e,block:r,inverse:s}){return[u.Each,x.expr(t),e?x.expr(e):null,M.NamedBlock(r)[1],s?M.NamedBlock(s)[1]:null]}Let({positional:t,block:e}){return[u.Let,x.Positional(t),M.NamedBlock(e)[1]]}WithDynamicVars({named:t,block:e}){return[u.WithDynamicVars,x.NamedArguments(t),M.NamedBlock(e)[1]]}InvokeComponent({definition:t,args:e,blocks:r}){return[u.InvokeComponent,x.expr(t),x.Positional(e.positional),x.NamedArguments(e.named),r?M.NamedBlocks(r):null]}};function Po({name:t,value:e,namespace:r}){let s=[fa(t.chars),e.chars];return r&&s.push(r),s}function No({name:t,value:e,namespace:r}){let s=[fa(t.chars),x.expr(e)];return r&&s.push(r),s}function To(t){return t.component?u.StaticComponentAttr:u.StaticAttr}const ls=(()=>{const t=typeof module=="object"&&typeof module.require=="function"?module.require:globalThis.require;if(t)try{const e=t("crypto"),r=s=>{const n=e.createHash("sha1");return n.update(s,"utf8"),n.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),ga={id:ls};function ba(t,e=ga){const r=new zt.Source(t??"",e.meta?.moduleName),[s,n]=al(r,{lexicalScope:()=>!1,...e}),a=function(i,l,o){let c=new Ao(l.table,o),h=V.visitList(l.body,c).mapOk(m=>new Al({loc:l.loc,scope:l.table,body:m.toArray()}));return o&&(h=h.andThen(m=>xo.validate(m))),h}(0,s,e.strictMode??!1).mapOk(i=>function(l){let o=M.list(l.body),c=l.scope;return[o,c.symbols,c.hasEval,c.upvars]}(i));if(a.isOk)return[a.value,n];throw a.reason}function Bo(t,e=ga){const[r,s]=ba(t,e),n=e.meta?.moduleName,a=e.id||ls,i=JSON.stringify(r),l={id:a(JSON.stringify(e.meta)+i),block:i,moduleName:n??"(unknown template module)",scope:"796d24e6-2450-4fb0-8cdf-b65638b5ef70",isStrictMode:e.strictMode??!1};s.length===0&&delete l.scope;let o=JSON.stringify(l);if(s.length>0){const c=`()=>[${s.join(",")}]`;o=o.replace('"796d24e6-2450-4fb0-8cdf-b65638b5ef70"',c)}return o}const Lo=Object.freeze(Object.defineProperty({__proto__:null,Builder:H,NEWLINE:kl,ProgramSymbols:ia,WireFormatDebugger:Co,buildStatement:sr,buildStatements:ml,c:gl,defaultId:ls,precompile:Bo,precompileJSON:ba,s:fl,unicode:bl},Symbol.toStringTag,{value:"Module"}));function kr(){return Object.create(null)}let ie=Object.assign;const Ks=console;function $o(t,e="unexpected unreachable branch"){throw Ks.log("unreachable",t),Ks.log(`${e} :: ${JSON.stringify(t)} (${t})`),new Error("code reached unreachable")}const _e={GetStrictKeyword:31,GetFreeAsComponentOrHelperHead:35,GetFreeAsHelperHead:37,GetFreeAsModifierHead:38,GetFreeAsComponentHead:39},ka=/["&\xA0]/u,Oo=new RegExp(ka.source,"gu"),ya=/[&<>\xA0]/u,Ho=new RegExp(ya.source,"gu");function Io(t){switch(t.charCodeAt(0)){case 160:return"&nbsp;";case 34:return"&quot;";case 38:return"&amp;";default:return t}}function Fo(t){switch(t.charCodeAt(0)){case 160:return"&nbsp;";case 38:return"&amp;";case 60:return"&lt;";case 62:return"&gt;";default:return t}}function wa(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const Xt=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]);function Mo(){return[...Xt]}const Do=/^\S/u;function os(t){return Xt.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class cs{buffer="";options;constructor(e){this.options=e}handledByOverride(e,r=!1){if(this.options.override!==void 0){let s=this.options.override(e,this.options);if(typeof s=="string")return r&&Do.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(e){switch(e.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(e);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(e);case"ConcatStatement":return this.ConcatStatement(e);case"Hash":return this.Hash(e);case"HashPair":return this.HashPair(e);case"ElementModifierStatement":return this.ElementModifierStatement(e)}}Expression(e){switch(e.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(e);case"PathExpression":return this.PathExpression(e);case"SubExpression":return this.SubExpression(e)}}Literal(e){switch(e.type){case"StringLiteral":return this.StringLiteral(e);case"BooleanLiteral":return this.BooleanLiteral(e);case"NumberLiteral":return this.NumberLiteral(e);case"UndefinedLiteral":return this.UndefinedLiteral(e);case"NullLiteral":return this.NullLiteral(e)}}TopLevelStatement(e){switch(e.type){case"MustacheStatement":return this.MustacheStatement(e);case"BlockStatement":return this.BlockStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":return this.CommentStatement(e);case"TextNode":return this.TextNode(e);case"ElementNode":return this.ElementNode(e);case"Block":return this.Block(e);case"Template":return this.Template(e);case"AttrNode":return this.AttrNode(e)}}Template(e){this.TopLevelStatements(e.body)}Block(e){e.chained&&(e.body[0].chained=!0),this.handledByOverride(e)||this.TopLevelStatements(e.body)}TopLevelStatements(e){e.forEach(r=>this.TopLevelStatement(r))}ElementNode(e){this.handledByOverride(e)||(this.OpenElementNode(e),this.TopLevelStatements(e.children),this.CloseElementNode(e))}OpenElementNode(e){this.buffer+=`<${e.tag}`;const r=[...e.attributes,...e.modifiers,...e.comments].sort(wa);for(const s of r)switch(this.buffer+=" ",s.type){case"AttrNode":this.AttrNode(s);break;case"ElementModifierStatement":this.ElementModifierStatement(s);break;case"MustacheCommentStatement":this.MustacheCommentStatement(s)}e.blockParams.length&&this.BlockParams(e.blockParams),e.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(e){e.selfClosing||os(e.tag)||(this.buffer+=`</${e.tag}>`)}AttrNode(e){if(this.handledByOverride(e))return;let{name:r,value:s}=e;this.buffer+=r,(s.type!=="TextNode"||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(e){e.type==="TextNode"?(this.buffer+='"',this.TextNode(e,!0),this.buffer+='"'):this.Node(e)}TextNode(e,r){var s;this.handledByOverride(e)||(this.options.entityEncoding==="raw"?this.buffer+=e.chars:this.buffer+=r?(s=e.chars,ka.test(s)?s.replace(Oo,Io):s):function(n){return ya.test(n)?n.replace(Ho,Fo):n}(e.chars))}MustacheStatement(e){this.handledByOverride(e)||(this.buffer+=e.trusting?"{{{":"{{",e.strip.open&&(this.buffer+="~"),this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.strip.close&&(this.buffer+="~"),this.buffer+=e.trusting?"}}}":"}}")}BlockStatement(e){this.handledByOverride(e)||(e.chained?(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=e.openStrip.open?"{{~#":"{{#",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.program.blockParams.length&&this.BlockParams(e.program.blockParams),e.chained?this.buffer+=e.inverseStrip.close?"~}}":"}}":this.buffer+=e.openStrip.close?"~}}":"}}",this.Block(e.program),e.inverse&&(e.inverse.chained||(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=e.inverseStrip.close?"~}}":"}}"),this.Block(e.inverse)),e.chained||(this.buffer+=e.closeStrip.open?"{{~/":"{{/",this.Expression(e.path),this.buffer+=e.closeStrip.close?"~}}":"}}"))}BlockParams(e){this.buffer+=` as |${e.join(" ")}|`}ConcatStatement(e){this.handledByOverride(e)||(this.buffer+='"',e.parts.forEach(r=>{r.type==="TextNode"?this.TextNode(r,!0):this.Node(r)}),this.buffer+='"')}MustacheCommentStatement(e){this.handledByOverride(e)||(this.buffer+=`{{!--${e.value}--}}`)}ElementModifierStatement(e){this.handledByOverride(e)||(this.buffer+="{{",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}CommentStatement(e){this.handledByOverride(e)||(this.buffer+=`<!--${e.value}-->`)}PathExpression(e){this.handledByOverride(e)||(this.buffer+=e.original)}SubExpression(e){this.handledByOverride(e)||(this.buffer+="(",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+=")")}Params(e){e.length&&e.forEach(r=>{this.buffer+=" ",this.Expression(r)})}Hash(e){this.handledByOverride(e,!0)||e.pairs.forEach(r=>{this.buffer+=" ",this.HashPair(r)})}HashPair(e){this.handledByOverride(e)||(this.buffer+=e.key,this.buffer+="=",this.Node(e.value))}StringLiteral(e){this.handledByOverride(e)||(this.buffer+=JSON.stringify(e.value))}BooleanLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}NumberLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}UndefinedLiteral(e){this.handledByOverride(e)||(this.buffer+="undefined")}NullLiteral(e){this.handledByOverride(e)||(this.buffer+="null")}print(e){let{options:r}=this;if(r.override){let s=r.override(e,r);if(s!==void 0)return s}return this.buffer="",this.Node(e),this.buffer}}function va(t,e={entityEncoding:"transformed"}){return t?new cs(e).print(t):""}function Sa(t,e){return t in Mr&&(e===void 0||Mr[t].includes(e))}const Mr={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]};function X(t){return t.length>0}function Xe(t,e="unexpected empty list"){return t}function Ct(t){return t.length===0?void 0:t[t.length-1]}function us(t){return t.length===0?void 0:t[0]}const pe=Object.freeze({line:1,column:0}),Ea=Object.freeze({source:"(synthetic)",start:pe,end:pe}),Re=Object.freeze({source:"(nonexistent)",start:pe,end:pe}),ke=Object.freeze({source:"(broken)",start:pe,end:pe}),Z="CharPosition",ee="HbsPosition",hs="InternalsSynthetic",Qt="NonExistent",Ee="Broken",bt="MATCH_ANY",Dr="IS_INVISIBLE";class _o{_whens;constructor(e){this._whens=e}first(e){for(const r of this._whens){const s=r.match(e);if(X(s))return s[0]}return null}}class Js{_map=new Map;get(e,r){let s=this._map.get(e);return s||(s=r(),this._map.set(e,s),s)}add(e,r){this._map.set(e,r)}match(e){const r=function(i){switch(i){case Ee:case hs:case Qt:return Dr;default:return i}}(e),s=[],n=this._map.get(r),a=this._map.get(bt);return n&&s.push(n),a&&s.push(a),s}}function Aa(t){return t(new zo).validate()}class zo{_whens=new Js;validate(){return(e,r)=>this.matchFor(e.kind,r.kind)(e,r)}matchFor(e,r){const s=this._whens.match(e);return X(s),new _o(s).first(r)}when(e,r,s){return this._whens.get(e,()=>new Js).add(r,s),this}}class U{static synthetic(e){let r=O.synthetic(e);return new U({loc:r,chars:e})}static load(e,r){return new U({loc:O.load(e,r[1]),chars:r[0]})}chars;loc;constructor(e){this.loc=e.loc,this.chars=e.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class O{static get NON_EXISTENT(){return new Be(Qt,Re).wrap()}static load(e,r){return typeof r=="number"?O.forCharPositions(e,r,r):typeof r=="string"?O.synthetic(r):Array.isArray(r)?O.forCharPositions(e,r[0],r[1]):r===Qt?O.NON_EXISTENT:r===Ee?O.broken(ke):void $o(r)}static forHbsLoc(e,r){const s=new Qe(e,r.start),n=new Qe(e,r.end);return new ms(e,{start:s,end:n},r).wrap()}static forCharPositions(e,r,s){const n=new kt(e,r),a=new kt(e,s);return new ps(e,{start:n,end:a}).wrap()}static synthetic(e){return new Be(hs,Re,e).wrap()}static broken(e=ke){return new Be(Ee,e).wrap()}isInvisible;constructor(e){var r;this.data=e,this.isInvisible=(r=e.kind)!==Z&&r!==ee}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const e=this.data.toHbsSpan();return e===null?ke:e.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(e){return ne(e.data,this.data.getEnd())}withEnd(e){return ne(this.data.getStart(),e.data)}asString(){return this.data.asString()}toSlice(e){const r=this.data.asString();return new U({loc:this,chars:e||r})}get start(){return this.loc.start}set start(e){this.data.locDidUpdate({start:e})}get end(){return this.loc.end}set end(e){this.data.locDidUpdate({end:e})}get source(){return this.module}collapse(e){switch(e){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(e){return ne(this.data.getStart(),e.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:e=0,skipEnd:r=0}){return ne(this.getStart().move(e).data,this.getEnd().move(-r).data)}sliceStartChars({skipStart:e=0,chars:r}){return ne(this.getStart().move(e).data,this.getStart().move(e+r).data)}sliceEndChars({skipEnd:e=0,chars:r}){return ne(this.getEnd().move(e-r).data,this.getStart().move(-e).data)}}class ps{kind=Z;#e=null;constructor(e,r){this.source=e,this.charPositions=r}wrap(){return new O(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let e=this.#e;if(e===null){const r=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();e=this.#e=r===null||s===null?Ae:new ms(this.source,{start:r,end:s})}return e===Ae?null:e}serialize(){const{start:{charPos:e},end:{charPos:r}}=this.charPositions;return e===r?e:[e,r]}toCharPosSpan(){return this}}class ms{kind=ee;#e=null;#t;constructor(e,r,s=null){this.source=e,this.hbsPositions=r,this.#t=s}serialize(){const e=this.toCharPosSpan();return e===null?Ee:e.wrap().serialize()}wrap(){return new O(this)}updateProvided(e,r){this.#t&&(this.#t[r]=e),this.#e=null,this.#t={start:e,end:e}}locDidUpdate({start:e,end:r}){e!==void 0&&(this.updateProvided(e,"start"),this.hbsPositions.start=new Qe(this.source,e,null)),r!==void 0&&(this.updateProvided(r,"end"),this.hbsPositions.end=new Qe(this.source,r,null))}asString(){const e=this.toCharPosSpan();return e===null?"":e.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let e=this.#e;if(e===null){const r=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!r||!s)return e=this.#e=Ae,null;e=this.#e=new ps(this.source,{start:r,end:s})}return e===Ae?null:e}}class Be{constructor(e,r,s=null){this.kind=e,this.loc=r,this.string=s}serialize(){switch(this.kind){case Ee:case Qt:return this.kind;case hs:return this.string||""}}wrap(){return new O(this)}asString(){return this.string||""}locDidUpdate({start:e,end:r}){e!==void 0&&(this.loc.start=e),r!==void 0&&(this.loc.end=r)}getModule(){return"an unknown module"}getStart(){return new _r(this.kind,this.loc.start)}getEnd(){return new _r(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return ke}}const ne=Aa(t=>t.when(ee,ee,(e,r)=>new ms(e.source,{start:e,end:r}).wrap()).when(Z,Z,(e,r)=>new ps(e.source,{start:e,end:r}).wrap()).when(Z,ee,(e,r)=>{const s=r.toCharPos();return s===null?new Be(Ee,ke).wrap():ne(e,s)}).when(ee,Z,(e,r)=>{const s=e.toCharPos();return s===null?new Be(Ee,ke).wrap():ne(s,r)}).when(Dr,bt,e=>new Be(e.kind,ke).wrap()).when(bt,Dr,(e,r)=>new Be(r.kind,ke).wrap())),Ae="BROKEN";class xe{static forHbsPos(e,r){return new Qe(e,r,null).wrap()}static broken(e=pe){return new _r(Ee,e).wrap()}constructor(e){this.data=e}get offset(){const e=this.data.toCharPos();return e===null?null:e.offset}eql(e){return Vo(this.data,e.data)}until(e){return ne(this.data,e.data)}move(e){const r=this.data.toCharPos();if(r===null)return xe.broken();{const s=r.offset+e;return r.source.validate(s)?new kt(r.source,s).wrap():xe.broken()}}collapsed(){return ne(this.data,this.data)}toJSON(){return this.data.toJSON()}}class kt{kind=Z;_locPos=null;constructor(e,r){this.source=e,this.charPos=r}toCharPos(){return this}toJSON(){const e=this.toHbsPos();return e===null?pe:e.toJSON()}wrap(){return new xe(this)}get offset(){return this.charPos}toHbsPos(){let e=this._locPos;if(e===null){const r=this.source.hbsPosFor(this.charPos);this._locPos=e=r===null?Ae:new Qe(this.source,r,this.charPos)}return e===Ae?null:e}}class Qe{kind=ee;_charPos;constructor(e,r,s=null){this.source=e,this.hbsPos=r,this._charPos=s===null?null:new kt(e,s)}toCharPos(){let e=this._charPos;if(e===null){const r=this.source.charPosFor(this.hbsPos);this._charPos=e=r===null?Ae:new kt(this.source,r)}return e===Ae?null:e}toJSON(){return this.hbsPos}wrap(){return new xe(this)}toHbsPos(){return this}}class _r{constructor(e,r){this.kind=e,this.pos=r}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new xe(this)}get offset(){return null}}const Vo=Aa(t=>t.when(ee,ee,({hbsPos:e},{hbsPos:r})=>e.column===r.column&&e.line===r.line).when(Z,Z,({charPos:e},{charPos:r})=>e===r).when(Z,ee,({offset:e},r)=>e===r.toCharPos()?.offset).when(ee,Z,(e,{offset:r})=>e.toCharPos()?.offset===r).when(bt,bt,()=>!1));class ye{static from(e,r={}){return new ye(e,r.meta?.moduleName)}constructor(e,r="an unknown module"){this.source=e,this.module=r}validate(e){return e>=0&&e<=this.source.length}slice(e,r){return this.source.slice(e,r)}offsetFor(e,r){return xe.forHbsPos(this,{line:e,column:r})}spanFor({start:e,end:r}){return O.forHbsLoc(this,{start:{line:e.line,column:e.column},end:{line:r.line,column:r.column}})}hbsPosFor(e){let r=0,s=0;if(e>this.source.length)return null;for(;;){let n=this.source.indexOf(`
`,s);if(e<=n||n===-1)return{line:r+1,column:e-s};r+=1,s=n+1}}charPosFor(e){let{line:r,column:s}=e,n=this.source.length,a=0,i=0;for(;i<n;){let l=this.source.indexOf(`
`,i);if(l===-1&&(l=this.source.length),a===r-1)return i+s>l?l:i+s;if(l===-1)return 0;a+=1,i=l+1}return n}}class te{static range(e,r=O.NON_EXISTENT){return new te(e.map(Ze)).getRangeOffset(r)}_span;constructor(e=[]){this._span=e}add(e){this._span.push(e)}getRangeOffset(e){if(X(this._span)){let r=us(this._span),s=Ct(this._span);return r.extend(s)}return e}}function Ze(t){if(Array.isArray(t)){let e=us(t),r=Ct(t);return Ze(e).extend(Ze(r))}return t instanceof O?t:t.loc}function ds(t){return!Array.isArray(t)||t.length!==0}function xa(t,e){return ds(t)?Ze(t):e}var Uo=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:Re,SYNTHETIC_LOCATION:Ea,Source:ye,SourceOffset:xe,SourceSlice:U,SourceSpan:O,SpanList:te,UNKNOWN_POSITION:pe,hasSpan:ds,loc:Ze,maybeLoc:xa});function k(t,e){let{module:r,loc:s}=e,{line:n,column:a}=s.start,i=e.asString(),l=i?`

|
|  ${i.split(`
`).join(`
|  `)}
|

`:"",o=new Error(`${t}: ${l}(error occurred in '${r}' @ line ${n} : column ${a})`);return o.name="SyntaxError",o.location=e,o.code=i,o}const Ca={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},fs=function(){function t(e,r,s,n){let a=Error.call(this,e);this.key=n,this.message=e,this.node=r,this.parent=s,a.stack&&(this.stack=a.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function zr(t,e,r){return new fs("Cannot remove a node unless it is part of an array",t,e,r)}function Pa(t,e,r){return new fs("Cannot replace a node with multiple nodes unless it is part of an array",t,e,r)}function Ws(t,e){return new fs("Replacing and removing in key handlers is not yet supported.",t,null,e)}class Pt{node;parent;parentKey;constructor(e,r=null,s=null){this.node=e,this.parent=r,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new Go(this)}}}class Go{path;constructor(e){this.path=e}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function Na(t){return typeof t=="function"?t:t.enter}function Ta(t){return typeof t=="function"?void 0:t.exit}function ar(t,e){let r,s,n,{node:a,parent:i,parentKey:l}=e,o=function(c,h){if(c.Program&&(h==="Template"&&!c.Template||h==="Block"&&!c.Block))return c.Program;let m=c[h];return m!==void 0?m:c.All}(t,a.type);if(o!==void 0&&(r=Na(o),s=Ta(o)),r!==void 0&&(n=r(a,e)),n!=null){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(Ba(t,n,i,l),n):ar(t,new Pt(n,i,l))||n;n=void 0}if(n===void 0){let c=Ca[a.type];for(let h=0;h<c.length;h++)Ro(t,o,e,c[h]);s!==void 0&&(n=s(a,e))}return n}function Ys(t,e,r){t[e]=r}function Ro(t,e,r,s){let n,a,{node:i}=r,l=function(o,c){return o[c]}(i,s);if(l){if(e!==void 0){let o=function(c,h){let m=typeof c!="function"?c.keys:void 0;if(m===void 0)return;let d=m[h];return d!==void 0?d:m.All}(e,s);o!==void 0&&(n=Na(o),a=Ta(o))}if(n!==void 0&&n(i,s)!==void 0)throw Ws(i,s);if(Array.isArray(l))Ba(t,l,r,s);else{let o=ar(t,new Pt(l,r,s));o!==void 0&&function(c,h,m,d){if(d===null)throw zr(m,c,h);if(Array.isArray(d)){if(d.length!==1)throw d.length===0?zr(m,c,h):Pa(m,c,h);Ys(c,h,d[0])}else Ys(c,h,d)}(i,s,l,o)}if(a!==void 0&&a(i,s)!==void 0)throw Ws(i,s)}}function Ba(t,e,r,s){for(let n=0;n<e.length;n++){let a=e[n],i=ar(t,new Pt(a,r,s));i!==void 0&&(n+=jo(e,n,i)-1)}}function jo(t,e,r){return r===null?(t.splice(e,1),0):Array.isArray(r)?(t.splice(e,1,...r),r.length):(t.splice(e,1,r),1)}function ir(t,e){ar(e,new Pt(t))}class Vr{stack=[];constructor(e){this.order=e}visit(e,r){e&&(this.stack.push(e),this.order==="post"?(this.children(e,r),r(e,this)):(r(e,this),this.children(e,r)),this.stack.pop())}children(e,r){switch(e.type){case"Block":case"Template":return void qs(this,e.body,r);case"ElementNode":return void qs(this,e.children,r);case"BlockStatement":return this.visit(e.program,r),void this.visit(e.inverse||null,r);default:return}}}function qs(t,e,r){for(const s of e)t.visit(s,r)}function je(t,e){(function(r){switch(r.type){case"Block":case"Template":return r.body;case"ElementNode":return r.children}})(t).push(e)}function La(t){return t.type==="StringLiteral"||t.type==="BooleanLiteral"||t.type==="NumberLiteral"||t.type==="NullLiteral"||t.type==="UndefinedLiteral"}let yr;function wr(){return yr||(yr=new ye("","(synthetic)")),yr}function Xs(t,e){return g.var({name:t,loc:$(e||null)})}function fe(t,e){let r=$(e||null);if(typeof t!="string"){if("type"in t)return t;{t.head.indexOf(".");let{head:a,tail:i}=t;return g.path({head:g.head({original:a,loc:r.sliceStartChars({chars:a.length})}),tail:i,loc:$(e||null)})}}let{head:s,tail:n}=function(a,i){let[l,...o]=Xe(a.split(".")),c=g.head({original:l,loc:$(i||null)});return g.path({head:c,tail:o,loc:$(i||null)})}(t,r);return g.path({head:s,tail:n,loc:r})}function Ht(t,e,r){return g.literal({type:t,value:e,loc:$(r||null)})}function it(t=[],e){return g.hash({pairs:t,loc:$(e||null)})}function $a(t){return t.map(e=>typeof e=="string"?g.var({name:e,loc:O.synthetic(e)}):e)}function Qs(t=[],e=[],r=!1,s){return g.blockItself({body:t,params:$a(e),chained:r,loc:$(s||null)})}function Zs(t=[],e=[],r){return g.template({body:t,blockParams:e,loc:$(r||null)})}function $(...t){if(t.length===1){let e=t[0];return e&&typeof e=="object"?O.forHbsLoc(wr(),e):O.forHbsLoc(wr(),Ea)}{let[e,r,s,n,a]=t,i=a?new ye("",a):wr();return O.forHbsLoc(i,{start:{line:e,column:r},end:{line:s||e,column:n||r}})}}var gs={mustache:function(t,e=[],r=it([]),s=!1,n,a){return g.mustache({path:fe(t),params:e,hash:r,trusting:s,strip:a,loc:$(n||null)})},block:function(t,e,r,s,n=null,a,i,l,o){let c,h=null;return c=s.type==="Template"?g.blockItself({params:$a(s.blockParams),body:s.body,loc:s.loc}):s,n?.type==="Template"?(n.blockParams.length,h=g.blockItself({params:[],body:n.body,loc:n.loc})):h=n,g.block({path:fe(t),params:e||[],hash:r||it([]),defaultBlock:c,elseBlock:h,loc:$(a||null),openStrip:i,inverseStrip:l,closeStrip:o})},comment:function(t,e){return g.comment({value:t,loc:$(e||null)})},mustacheComment:function(t,e){return g.mustacheComment({value:t,loc:$(e||null)})},element:function(t,e={}){let r,s,{attrs:n,blockParams:a,modifiers:i,comments:l,children:o,openTag:c,closeTag:h,loc:m}=e;typeof t=="string"?t.endsWith("/")?(r=fe(t.slice(0,-1)),s=!0):r=fe(t):"type"in t?(t.type,t.type,r=t):"path"in t?(t.path.type,t.path.type,r=t.path,s=t.selfClosing):(r=fe(t.name),s=t.selfClosing);let d=a?.map(S=>typeof S=="string"?Xs(S):S),y=null;return h?y=$(h||null):h===void 0&&(y=s||os(r.original)?null:$(null)),g.element({path:r,selfClosing:s||!1,attributes:n||[],params:d||[],modifiers:i||[],comments:l||[],children:o||[],openTag:$(c||null),closeTag:y,loc:$(m||null)})},elementModifier:function(t,e,r,s){return g.elementModifier({path:fe(t),params:e||[],hash:r||it([]),loc:$(s||null)})},attr:function(t,e,r){return g.attr({name:t,value:e,loc:$(r||null)})},text:function(t="",e){return g.text({chars:t,loc:$(e||null)})},sexpr:function(t,e=[],r=it([]),s){return g.sexpr({path:fe(t),params:e,hash:r,loc:$(s||null)})},concat:function(t,e){if(!X(t))throw new Error("b.concat requires at least one part");return g.concat({parts:t,loc:$(e||null)})},hash:it,pair:function(t,e,r){return g.pair({key:t,value:e,loc:$(r||null)})},literal:Ht,program:function(t,e,r){return e&&e.length?Qs(t,e,!1,r):Zs(t,[],r)},blockItself:Qs,template:Zs,loc:$,pos:function(t,e){return g.pos({line:t,column:e})},path:fe,fullPath:function(t,e=[],r){return g.path({head:t,tail:e,loc:$(r||null)})},head:function(t,e){return g.head({original:t,loc:$(e||null)})},at:function(t,e){return g.atName({name:t,loc:$(e||null)})},var:Xs,this:function(t){return g.this({loc:$(t||null)})},string:vr("StringLiteral"),boolean:vr("BooleanLiteral"),number:vr("NumberLiteral"),undefined:()=>Ht("UndefinedLiteral",void 0),null:()=>Ht("NullLiteral",null)};function vr(t){return function(e,r){return Ht(t,e,r)}}const Lt={close:!1,open:!1},g=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:r=!1,loc:s}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map(n=>n.name)},set blockParams(n){this.params=n.map(a=>g.var({name:a,loc:O.synthetic(a)}))},chained:r,loc:s}}template({body:t,blockParams:e,loc:r}){return{type:"Template",body:t,blockParams:e,loc:r}}mustache({path:t,params:e,hash:r,trusting:s,loc:n,strip:a=Lt}){return function({path:i,params:l,hash:o,trusting:c,strip:h,loc:m}){const d={type:"MustacheStatement",path:i,params:l,hash:o,trusting:c,strip:h,loc:m};return Object.defineProperty(d,"escaped",{enumerable:!1,get(){return!this.trusting},set(y){this.trusting=!y}}),d}({path:t,params:e,hash:r,trusting:s,strip:a,loc:n})}block({path:t,params:e,hash:r,defaultBlock:s,elseBlock:n=null,loc:a,openStrip:i=Lt,inverseStrip:l=Lt,closeStrip:o=Lt}){return{type:"BlockStatement",path:t,params:e,hash:r,program:s,inverse:n,loc:a,openStrip:i,inverseStrip:l,closeStrip:o}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:c}){let h=e;return{type:"ElementNode",path:t,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:c,get tag(){return this.path.original},set tag(m){this.path.original=m},get blockParams(){return this.params.map(m=>m.name)},set blockParams(m){this.params=m.map(d=>g.var({name:d,loc:O.synthetic(d)}))},get selfClosing(){return h},set selfClosing(m){h=m,this.closeTag=m?null:O.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:r,loc:s}){return{type:"ElementModifierStatement",path:t,params:e,hash:r,loc:s}}attr({name:t,value:e,loc:r}){return{type:"AttrNode",name:t,value:e,loc:r}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:r,loc:s}){return{type:"SubExpression",path:t,params:e,hash:r,loc:s}}path({head:t,tail:e,loc:r}){return function({head:s,tail:n,loc:a}){const i={type:"PathExpression",head:s,tail:n,get original(){return[this.head.original,...this.tail].join(".")},set original(l){let[o,...c]=Xe(l.split("."));this.head=gs.head(o,this.head.loc),this.tail=c},loc:a};return Object.defineProperty(i,"parts",{enumerable:!1,get(){let l=Xe(this.original.split("."));return l[0]==="this"?l.shift():l[0].startsWith("@")&&(l[0]=l[0].slice(1)),Object.freeze(l)},set(l){let o=[...l];o[0]==="this"||o[0]?.startsWith("@")||(this.head.type==="ThisHead"?o.unshift("this"):this.head.type==="AtHead"&&(o[0]=`@${o[0]}`)),this.original=o.join(".")}}),Object.defineProperty(i,"this",{enumerable:!1,get(){return this.head.type==="ThisHead"}}),Object.defineProperty(i,"data",{enumerable:!1,get(){return this.head.type==="AtHead"}}),i}({head:t,tail:e,loc:r})}head({original:t,loc:e}){return t==="this"?this.this({loc:e}):t[0]==="@"?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:t,loc:e}){let r="";const s={type:"AtHead",get name(){return r},set name(n){n[0],n.indexOf("."),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}var({name:t,loc:e}){let r="";const s={type:"VarHead",get name(){return r},set name(n){n[0],n.indexOf("."),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:r}){return{type:"HashPair",key:t,value:e,loc:r}}literal({type:t,value:e,loc:r}){return function({type:s,value:n,loc:a}){const i={type:s,value:n,loc:a};return Object.defineProperty(i,"original",{enumerable:!1,get(){return this.value},set(l){this.value=l}}),i}({type:t,value:e,loc:r})}};class Ko{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(e,r=new Zt(ln),s="precompile"){this.source=e,this.lines=e.source.split(/\r\n?|\n/u),this.tokenizer=new an(this,r,s)}offset(){let{line:e,column:r}=this.tokenizer;return this.source.offsetFor(e,r)}pos({line:e,column:r}){return this.source.offsetFor(e,r)}finish(e){return ie({},e,{loc:e.start.until(this.offset())})}get currentAttr(){return this.currentAttribute}get currentTag(){let e=this.currentNode;return e&&(e.type==="StartTag"||e.type),e}get currentStartTag(){let e=this.currentNode;return e&&e.type,e}get currentEndTag(){let e=this.currentNode;return e&&e.type,e}get currentComment(){let e=this.currentNode;return e&&e.type,e}get currentData(){let e=this.currentNode;return e&&e.type,e}acceptNode(e){return this[e.type](e)}currentElement(){return Ct(Xe(this.elementStack))}sourceForNode(e,r){let s,n,a,i=e.loc.start.line-1,l=i-1,o=e.loc.start.column,c=[];for(r?(n=r.loc.end.line-1,a=r.loc.end.column):(n=e.loc.end.line-1,a=e.loc.end.column);l<n;)l++,s=this.lines[l],l===i?i===n?c.push(s.slice(o,a)):c.push(s.slice(o)):l===n?c.push(s.slice(0,a)):c.push(s);return c.join(`
`)}}const en="beforeAttributeName";class Jo extends Ko{pendingError=null;parse(e,r){let s=g.template({body:[],blockParams:r,loc:this.source.spanFor(e.loc)}),n=this.parseProgram(s,e);return this.pendingError?.eof(n.loc.getEnd()),n}Program(e,r){let s=g.blockItself({body:[],params:r,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(s,e)}parseProgram(e,r){if(r.body.length===0)return e;let s;try{this.elementStack.push(e);for(let n of r.body)this.acceptNode(n)}finally{s=this.elementStack.pop()}if(e!==s){if(s?.type==="ElementNode")throw k(`Unclosed element \`${s.tag}\``,s.loc);e.type}return e}BlockStatement(e){if(this.tokenizer.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));if(this.tokenizer.state!=="data"&&this.tokenizer.state!=="beforeData")throw k("A block may only be used inside an HTML element or another block.",this.source.spanFor(e.loc));const{path:r,params:s,hash:n}=Sr(this,e),a=this.source.spanFor(e.loc);let i=[];if(e.program.blockParams?.length){let h=n.loc.collapse("end");h=e.program.loc?h.withEnd(this.source.spanFor(e.program.loc).getStart()):e.program.body[0]?h.withEnd(this.source.spanFor(e.program.body[0].loc).getStart()):h.withEnd(a.getEnd());const m=h.asString();let d=m.indexOf("|")+1;const y=m.indexOf("|",d);for(const S of e.program.blockParams){let I,z;I=d>=y?-1:m.indexOf(S,d),I===-1||I+S.length>y?(d=y,z=this.source.spanFor(Re)):(d=I,z=h.sliceStartChars({skipStart:d,chars:S.length}),d+=S.length),i.push(g.var({name:S,loc:z}))}}e.program.loc||(e.program.loc=Re),e.inverse&&!e.inverse.loc&&(e.inverse.loc=Re);const l=this.Program(e.program,i),o=e.inverse?this.Program(e.inverse,[]):null,c=g.block({path:r,params:s,hash:n,defaultBlock:l,elseBlock:o,loc:this.source.spanFor(e.loc),openStrip:e.openStrip,inverseStrip:e.inverseStrip,closeStrip:e.closeStrip});je(this.currentElement(),c)}MustacheStatement(e){this.pendingError?.mustache(this.source.spanFor(e.loc));const{tokenizer:r}=this;if(r.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));let s;const{escaped:n,loc:a,strip:i}=e;if("original"in e.path&&e.path.original==="...attributes")throw k("Illegal use of ...attributes",this.source.spanFor(e.loc));if(La(e.path))s=g.mustache({path:this.acceptNode(e.path),params:[],hash:g.hash({pairs:[],loc:this.source.spanFor(e.path.loc).collapse("end")}),trusting:!n,loc:this.source.spanFor(a),strip:i});else{const{path:l,params:o,hash:c}=Sr(this,e);s=g.mustache({path:l,params:o,hash:c,trusting:!n,loc:this.source.spanFor(a),strip:i})}switch(r.state){case"tagOpen":case"tagName":throw k("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":Er(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),Er(this.currentStartTag,s),r.transitionTo(en);break;case"afterAttributeValueQuoted":Er(this.currentStartTag,s),r.transitionTo(en);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),r.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:je(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(e){this.finalizeTextPart();const r=this.currentAttr;r.isDynamic=!0,r.parts.push(e)}finalizeTextPart(){const e=this.currentAttr.currentPart;e!==null&&(this.currentAttr.parts.push(e),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(e){(function(r,s){let n=s.loc.start.line,a=s.loc.start.column;const i=function(l,o){if(o==="")return{lines:l.split(`
`).length-1,columns:0};const[c]=l.split(o),h=c.split(/\n/u),m=h.length-1;return{lines:m,columns:h[m].length}}(s.original,s.value);n+=i.lines,i.lines?a=i.columns:a+=i.columns,r.line=n,r.column=a})(this.tokenizer,e),this.tokenizer.tokenizePart(e.value),this.tokenizer.flushData()}CommentStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return this.appendToCommentData(this.sourceForNode(e)),null;const{value:s,loc:n}=e,a=g.mustacheComment({value:s,loc:this.source.spanFor(n)});switch(r.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(a);break;case"beforeData":case"data":je(this.currentElement(),a);break;default:throw k(`Using a Handlebars comment when in the \`${r.state}\` state is not supported`,this.source.spanFor(e.loc))}return a}PartialStatement(e){throw k("Handlebars partials are not supported",this.source.spanFor(e.loc))}PartialBlockStatement(e){throw k("Handlebars partial blocks are not supported",this.source.spanFor(e.loc))}Decorator(e){throw k("Handlebars decorators are not supported",this.source.spanFor(e.loc))}DecoratorBlock(e){throw k("Handlebars decorator blocks are not supported",this.source.spanFor(e.loc))}SubExpression(e){const{path:r,params:s,hash:n}=Sr(this,e);return g.sexpr({path:r,params:s,hash:n,loc:this.source.spanFor(e.loc)})}PathExpression(e){const{original:r}=e;let s;if(r.indexOf("/")!==-1){if(r.slice(0,2)==="./")throw k('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(e.loc));if(r.slice(0,3)==="../")throw k('Changing context using "../" is not supported in Glimmer',this.source.spanFor(e.loc));if(r.indexOf(".")!==-1)throw k("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(e.loc));s=[e.parts.join("/")]}else{if(r===".")throw k("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(e.loc));s=e.parts}let n,a=!1;if(/^this(?:\..+)?$/u.test(r)&&(a=!0),a)n=g.this({loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+4}})});else if(e.data){const i=s.shift();if(i===void 0)throw k("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(e.loc));n=g.atName({name:`@${i}`,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length+1}})})}else{const i=s.shift();if(i===void 0)throw k("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(e.loc));n=g.var({name:i,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length}})})}return g.path({head:n,tail:s,loc:this.source.spanFor(e.loc)})}Hash(e){const r=e.pairs.map(s=>g.pair({key:s.key,value:this.acceptNode(s.value),loc:this.source.spanFor(s.loc)}));return g.hash({pairs:r,loc:this.source.spanFor(e.loc)})}StringLiteral(e){return g.literal({type:"StringLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}BooleanLiteral(e){return g.literal({type:"BooleanLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}NumberLiteral(e){return g.literal({type:"NumberLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}UndefinedLiteral(e){return g.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(e.loc)})}NullLiteral(e){return g.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(e.loc)})}}function Sr(t,e){let r;switch(e.path.type){case"PathExpression":r=t.PathExpression(e.path);break;case"SubExpression":r=t.SubExpression(e.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let a;throw a=e.path.type==="BooleanLiteral"?e.path.original.toString():e.path.type==="StringLiteral"?`"${e.path.original}"`:e.path.type==="NullLiteral"?"null":e.path.type==="NumberLiteral"?e.path.value.toString():"undefined",k(`${e.path.type} "${e.path.type==="StringLiteral"?e.path.original:a}" cannot be called as a sub-expression, replace (${a}) with ${a}`,t.source.spanFor(e.path.loc))}}const s=e.params?e.params.map(a=>t.acceptNode(a)):[],n=X(s)?Ct(s).loc:r.loc;return{path:r,params:s,hash:e.hash?t.Hash(e.hash):g.hash({pairs:[],loc:t.source.spanFor(n).collapse("end")})}}function Er(t,e){const{path:r,params:s,hash:n,loc:a}=e;if(La(r)){const l=`{{${function(o){return o.type==="UndefinedLiteral"?"undefined":JSON.stringify(o.value)}(r)}}}`;throw k(`In <${t.name} ... ${l} ..., ${l} is not a valid modifier`,e.loc)}const i=g.elementModifier({path:r,params:s,hash:n,loc:a});t.modifiers.push(i)}function Fe(t){return/[\t\n\f ]/u.test(t)}class Wo extends Jo{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(e){this.currentComment.value+=e}finishComment(){je(this.currentElement(),g.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(e){this.currentData.chars+=e}finishData(){je(this.currentElement(),g.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let e=this.finish(this.currentTag);if(e.type==="StartTag"){if(this.finishStartTag(),e.name===":")throw k("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(Xt.has(e.name)||e.selfClosing)&&this.finishEndTag(!0)}else e.type==="EndTag"&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:r,nameEnd:s}=this.currentStartTag,n=r.until(s),[a,...i]=Xe(e.split(".")),l=g.path({head:g.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:o,modifiers:c,comments:h,params:m,selfClosing:d,loc:y}=this.finish(this.currentStartTag),S=g.element({path:l,selfClosing:d,attributes:o,modifiers:c,comments:h,params:m,children:[],openTag:y,closeTag:d?null:O.broken(),loc:y});this.elementStack.push(S)}finishEndTag(e){let{start:r}=this.currentTag,s=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(s,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?n.closeTag:n.closeTag=r.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),je(a,g.element(n))}markTagAsSelfClosing(){let e=this.currentTag;if(e.type!=="StartTag")throw k("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:e.start.toJSON(),end:this.offset().toJSON()}));e.selfClosing=!0}appendToTagName(e){let r=this.currentTag;if(r.name+=e,r.type==="StartTag"){let s=this.offset();r.nameStart===null&&(r.nameEnd,r.nameStart=s.move(-1)),r.nameEnd=s}}beginAttribute(){let e=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:e,valueSpan:e.collapsed()}}appendToAttributeName(e){this.currentAttr.name+=e,this.currentAttr.name==="as"&&this.parsePossibleBlockParams()}beginAttributeValue(e){this.currentAttr.isQuoted=e,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(e){let r=this.currentAttr.parts,s=r[r.length-1],n=this.currentAttr.currentPart;if(n)n.chars+=e,n.loc=n.loc.withEnd(this.offset());else{let a=this.offset();a=e===`
`?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():a.move(-1),this.currentAttr.currentPart=g.text({chars:e,loc:a.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let e=this.currentTag,r=this.offset();if(e.type==="EndTag")throw k("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:e.start.toJSON(),end:r.toJSON()}));let{name:s,parts:n,start:a,isQuoted:i,isDynamic:l,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&n.length===0&&!i&&!l)throw k("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",a.until(a.move(s.length)));let c=this.assembleAttributeValue(n,i,l,a.until(r));c.loc=o.withEnd(r);let h=g.attr({name:s,value:c,loc:a.until(r)});this.currentStartTag.attributes.push(h)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;this.tokenizer.state;const r=this.currentStartTag,s=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:l=>{if(n.state,Fe(l))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if(l==="|")throw k('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',s.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:l=>{n.state,Fe(l)?this.tokenizer.consume():l==="|"?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:l=>{if(n.state,Fe(l))this.tokenizer.consume();else if(l==="")n={state:"Done"},this.pendingError={mustache(o){throw k("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw k('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"){if(r.params.length===0)throw k("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",s.start.until(this.offset().move(1)));n={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw k('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n={state:"BlockParamName",name:l,start:this.offset()},this.tokenizer.consume()}},BlockParamName:l=>{if(n.state,l==="")n={state:"Done"},this.pendingError={mustache(o){throw k("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw k('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"||Fe(l)){let o=n.start.until(this.offset());if(n.name==="this"||e.test(n.name))throw k(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,o);r.params.push(g.var({name:n.name,loc:o})),n=l==="|"?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw k('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n.name+=l,this.tokenizer.consume()}},AfterEndPipe:l=>{n.state,Fe(l)?this.tokenizer.consume():l===""?(n={state:"Done"},this.pendingError={mustache(o){throw k("Invalid block parameters syntax: modifiers cannot follow parameters list",o)},eof(o){throw k('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}}):l===">"||l==="/"?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:l=>{if(n.state,l===""||l==="/"||l===">"||Fe(l))throw k(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{}};let i;do i=this.tokenizer.peek(),a[n.state](i);while(n.state!=="Done"&&i!=="");n.state}reportSyntaxError(e){throw k(e,this.offset().collapsed())}assembleConcatenatedValue(e){for(const n of e)if(n.type!=="MustacheStatement"&&n.type!=="TextNode")throw k(`Unsupported node in quoted attribute value: ${n.type}`,n.loc);let r=us(e),s=Ct(e);return g.concat({parts:e,loc:this.source.spanFor(r.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(e,r,s){if(Xt.has(e.name)&&!s)throw k(`<${e.name}> elements do not need end tags. You should remove it`,e.loc);if(r.tag===void 0)throw k(`Closing tag </${e.name}> without an open tag`,e.loc);if(r.tag!==e.name)throw k(`Closing tag </${e.name}> did not match last open tag <${r.tag}> (on line ${r.loc.startPosition.line})`,e.loc)}assembleAttributeValue(e,r,s,n){if(s){if(r)return this.assembleConcatenatedValue(e);{const[a,i]=e;if(i===void 0||i.type==="TextNode"&&i.chars==="/")return a;throw k("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return X(e)?e[0]:g.text({chars:"",loc:n})}}const Yo={parse:lr,builders:gs,print:va,traverse:ir,Walker:Vr};class qo extends Zt{constructor(){super({})}parse(){}}function lr(t,e={}){let r,s,n,a=e.mode||"precompile";typeof t=="string"?(r=new ye(t,e.meta?.moduleName),s=a==="codemod"?Mt(t,e.parseOptions):Dt(t,e.parseOptions)):t instanceof ye?(r=t,s=a==="codemod"?Mt(t.source,e.parseOptions):Dt(t.source,e.parseOptions)):(r=new ye("",e.meta?.moduleName),s=t),a==="codemod"&&(n=new qo);let i=O.forCharPositions(r,0,r.source.length);s.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let l=new Wo(r,n,a).parse(s,e.locals??[]);if(e?.plugins?.ast)for(const o of e.plugins.ast)ir(l,o(ie({},e,{syntax:Yo},{plugins:void 0})).visitor);return l}function tn(t,e,r,s){const n=function(a,i,l){if(a.type==="PathExpression"){if(a.head.type==="AtHead"||a.head.type==="ThisHead")return;const o=a.head.name;if(i.indexOf(o)===-1)return o}else if(a.type==="ElementNode"){const{tag:o}=a,c=o.charAt(0);if(c===":"||c==="@"||!l.includeHtmlElements&&o.indexOf(".")===-1&&o.toLowerCase()===o||o.substr(0,5)==="this.")return;if(o.includes(".")){let[h]=o.split(".");if(i.includes(h))return}return i.includes(o)?void 0:o}}(e,r,s);(Array.isArray(n)?n:[n]).forEach(a=>{if(a!==void 0&&a[0]!=="@"){const i=a.split(".")[0];r.includes(i)||t.add(a.split(".")[0])}})}function Xo(t,e={includeHtmlElements:!1,includeKeywords:!1}){const r=lr(t),s=new Set,n=[];ir(r,{Block:{enter({blockParams:i}){i.forEach(l=>{n.push(l)})},exit({blockParams:i}){i.forEach(()=>{n.pop()})}},ElementNode:{enter(i){i.blockParams.forEach(l=>{n.push(l)}),tn(s,i,n,e)},exit({blockParams:i}){i.forEach(()=>{n.pop()})}},PathExpression(i){tn(s,i,n,e)}});let a=[];return s.forEach(i=>a.push(i)),e?.includeKeywords||(a=a.filter(i=>!Sa(i))),a}function B(t){if(t!==void 0){const e=t;return{fields:()=>class{type;constructor(r){this.type=e,ie(this,r)}}}}return{fields:()=>class{constructor(e){ie(this,e)}}}}class me extends B().fields(){static empty(e){return new me({loc:e,positional:et.empty(e),named:Ce.empty(e)})}static named(e){return new me({loc:e.loc,positional:et.empty(e.loc.collapse("end")),named:e})}nth(e){return this.positional.nth(e)}get(e){return this.named.get(e)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class et extends B().fields(){static empty(e){return new et({loc:e,exprs:[]})}get size(){return this.exprs.length}nth(e){return this.exprs[e]||null}isEmpty(){return this.exprs.length===0}}class Ce extends B().fields(){static empty(e){return new Ce({loc:e,entries:[]})}get size(){return this.entries.length}get(e){let r=this.entries.filter(s=>s.name.chars===e)[0];return r?r.value:null}isEmpty(){return this.entries.length===0}}class bs{loc;name;value;constructor(e){this.loc=e.name.loc.extend(e.value.loc),this.name=e.name,this.value=e.value}}class Oa extends B("HtmlAttr").fields(){}class Ha extends B("SplatAttr").fields(){}class Ia extends B().fields(){toNamedArgument(){return new bs({name:this.name,value:this.value})}}class Fa extends B("ElementModifier").fields(){}class Ma extends B("GlimmerComment").fields(){}class Da extends B("HtmlText").fields(){}class _a extends B("HtmlComment").fields(){}class za extends B("AppendContent").fields(){get callee(){return this.value.type==="Call"?this.value.callee:this.value}get args(){return this.value.type==="Call"?this.value.args:me.empty(this.value.loc.collapse("end"))}}class Va extends B("InvokeBlock").fields(){}class It extends B("InvokeComponent").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return me.named(new Ce({loc:te.range(e,this.callee.loc.collapse("end")),entries:e}))}}class Ua extends B("SimpleElement").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return me.named(new Ce({loc:te.range(e,this.tag.loc.collapse("end")),entries:e}))}}class Ga extends B("Literal").fields(){toSlice(){return new U({loc:this.loc,chars:this.value})}}class Ra extends B("Path").fields(){}class ja extends B("Keyword").fields(){}class Ka extends B("Call").fields(){}class Ja extends B("Interpolate").fields(){}class Wa extends B().fields(){}class Ya extends B().fields(){}class ks extends B().fields(){get(e){return this.blocks.filter(r=>r.name.chars===e)[0]||null}}class Ke extends B().fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return me.named(new Ce({loc:te.range(e,this.name.loc.collapse("end")),entries:e}))}}class qa extends B("This").fields(){}class Xa extends B("Arg").fields(){}class Qa extends B("Local").fields(){}class Za extends B("Free").fields(){}const Ft="Helper",ei="Modifier",Ur="Component",K={resolution:()=>_e.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},Qo={...K,isAngleBracket:!0};class J{static namespaced(e,r=!1){return new J([e],r)}static append(){return new J([Ur,Ft])}static trustingAppend(){return this.namespaced(Ft)}constructor(e,r=!1){this.namespaces=e,this.isAngleBracket=r}resolution(){if(this.namespaces.length!==1)return _e.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case Ft:return _e.GetFreeAsHelperHead;case ei:return _e.GetFreeAsModifierHead;case Ur:return _e.GetFreeAsComponentHead}}serialize(){return this.namespaces.length===1?this.namespaces[0]:"ComponentOrHelper"}}const ys=Ft,ti=ei,ws=Ur;var Zo=Object.freeze({__proto__:null,AppendContent:za,ArgReference:Xa,Args:me,Block:Ya,COMPONENT_NAMESPACE:ws,CallExpression:Ka,ComponentArg:Ia,ElementModifier:Fa,FreeVarReference:Za,GlimmerComment:Ma,HELPER_NAMESPACE:ys,HTML_RESOLUTION:Qo,HtmlAttr:Oa,HtmlComment:_a,HtmlText:Da,InterpolateExpression:Ja,InvokeBlock:Va,InvokeComponent:It,KeywordExpression:ja,LiteralExpression:Ga,LocalVarReference:Qa,LooseModeResolution:J,MODIFIER_NAMESPACE:ti,NamedArgument:bs,NamedArguments:Ce,NamedBlock:Ke,NamedBlocks:ks,PathExpression:Ra,PositionalArguments:et,STRICT_RESOLUTION:K,SimpleElement:Ua,SplatAttr:Ha,Template:Wa,ThisReference:qa,isLiteral:function(t,e){return t.type==="Literal"&&(e===void 0||(e==="null"?t.value===null:typeof t.value===e))},isStrictResolution:function(t){return t===K},loadResolution:function(t){return t==="Strict"?K:t==="ComponentOrHelper"?J.append():J.namespaced(t)},node:B});class or{static top(e,r,s){return new ri(e,r,s)}child(e){let r=e.map(s=>this.allocate(s));return new si(this,e,r)}}class ri extends or{constructor(e,r,s){super(),this.templateLocals=e,this.keywords=r,this.options=s}symbols=[];upvars=[];size=1;named=kr();blocks=kr();usedTemplateLocals=[];root(){return this}hasLexical(e){return this.options.lexicalScope(e)}hasKeyword(e){return this.keywords.includes(e)}getKeyword(e){return this.allocateFree(e,K)}getUsedTemplateLocals(){return this.usedTemplateLocals}has(e){return this.templateLocals.includes(e)}get(e){let r=this.usedTemplateLocals.indexOf(e);return r!==-1||(r=this.usedTemplateLocals.length,this.usedTemplateLocals.push(e)),[r,!0]}getLocalsMap(){return kr()}getDebugInfo(){return[this.getLocalsMap(),this.named]}allocateFree(e,r){r.resolution()===_e.GetFreeAsComponentHead&&r.isAngleBracket&&(e=this.options.customizeComponentName(e));let s=this.upvars.indexOf(e);return s!==-1||(s=this.upvars.length,this.upvars.push(e)),s}allocateNamed(e){let r=this.named[e];return r||(r=this.named[e]=this.allocate(e)),r}allocateBlock(e){e==="inverse"&&(e="else");let r=this.blocks[e];return r||(r=this.blocks[e]=this.allocate(`&${e}`)),r}allocate(e){return this.symbols.push(e),this.size++}}class si extends or{constructor(e,r,s){super(),this.parent=e,this.symbols=r,this.slots=s}root(){return this.parent.root()}get locals(){return this.symbols}hasLexical(e){return this.parent.hasLexical(e)}getKeyword(e){return this.parent.getKeyword(e)}hasKeyword(e){return this.parent.hasKeyword(e)}has(e){return this.symbols.indexOf(e)!==-1||this.parent.has(e)}get(e){let r=this.#e(e);return r?[r,!1]:this.parent.get(e)}#e(e){let r=this.symbols.indexOf(e);return r===-1?null:this.slots[r]}getLocalsMap(){let e=this.parent.getLocalsMap();return this.symbols.forEach(r=>e[r]=this.get(r)[0]),e}getDebugInfo(){const e=this.getLocalsMap(),r=this.root();return[{...e,...r.named},Object.fromEntries(r.upvars.map((s,n)=>[s,n]))]}allocateFree(e,r){return this.parent.allocateFree(e,r)}allocateNamed(e){return this.parent.allocateNamed(e)}allocateBlock(e){return this.parent.allocateBlock(e)}allocate(e){return this.parent.allocate(e)}}var rn=Object.freeze({__proto__:null});class ni{template(e,r,s){return new Wa({table:e,body:r,loc:s})}block(e,r,s){return new Ya({scope:e,body:r,loc:s})}namedBlock(e,r,s){return new Ke({name:e,block:r,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(e,r,s){return new sn({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(e,r,s)}slice(e,r){return new U({loc:r,chars:e})}args(e,r,s){return new me({loc:s,positional:e,named:r})}positional(e,r){return new et({loc:r,exprs:e})}namedArgument(e,r){return new bs({name:e,value:r})}named(e,r){return new Ce({loc:r,entries:e})}attr({name:e,value:r,trusting:s},n){return new Oa({loc:n,name:e,value:r,trusting:s})}splatAttr(e,r){return new Ha({symbol:e,loc:r})}arg({name:e,value:r,trusting:s},n){return new Ia({name:e,value:r,trusting:s,loc:n})}path(e,r,s){return new Ra({loc:s,ref:e,tail:r})}keyword(e,r,s){return new ja({loc:s,name:e,symbol:r})}self(e){return new qa({loc:e})}at(e,r,s){return e[0],new Xa({loc:s,name:new U({loc:s,chars:e}),symbol:r})}freeVar({name:e,context:r,symbol:s,loc:n}){return e[0],new Za({name:e,resolution:r,symbol:s,loc:n})}localVar(e,r,s,n){return e[0],new Qa({loc:n,name:e,isTemplateLocal:s,symbol:r})}sexp(e,r){return new Ka({loc:r,callee:e.callee,args:e.args})}interpolate(e,r){return new Ja({loc:r,parts:e})}literal(e,r){return new Ga({loc:r,value:e})}append({table:e,trusting:r,value:s},n){return new za({table:e,trusting:r,value:s,loc:n})}modifier({callee:e,args:r},s){return new Fa({loc:s,callee:e,args:r})}namedBlocks(e,r){return new ks({loc:r,blocks:e})}blockStatement({program:e,inverse:r=null,...s},n){let a=e.loc,i=[this.namedBlock(U.synthetic("default"),e,e.loc)];return r&&(a=a.extend(r.loc),i.push(this.namedBlock(U.synthetic("else"),r,r.loc))),new Va({loc:n,blocks:this.namedBlocks(i,a),callee:s.callee,args:s.args})}element(e){return new sn(e)}}class sn{builder;constructor(e){this.base=e,this.builder=new ni}simple(e,r,s){return new Ua(ie({tag:e,body:r,componentArgs:[],loc:s},this.base))}named(e,r,s){return new Ke(ie({name:e,block:r,componentArgs:[],loc:s},this.base))}selfClosingComponent(e,r){return new It(ie({loc:r,callee:e,blocks:new ks({blocks:[],loc:r.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(e,r,s,n){let a=this.builder.block(s,r,n),i=this.builder.namedBlock(U.synthetic("default"),a,n);return new It(ie({loc:n,callee:e,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(e,r,s){return new It(ie({loc:s,callee:e,blocks:this.builder.namedBlocks(r,te.range(r))},this.base))}}function ec(t){return Nt(t)?J.namespaced(ys):null}function tc(t){return Nt(t)?J.namespaced(ti):null}function rc(t){return Nt(t)?J.namespaced(ws):null}function sc(t){return ai(t)?J.namespaced(ws,!0):null}function nc(t){return Nt(t)?J.namespaced(ys):null}function ac(t){let e=Nt(t),r=t.trusting;return e?r?J.trustingAppend():J.append():null}function Nt(t){return ai(t.path)}function ai(t){return t.type==="PathExpression"&&t.head.type==="VarHead"&&t.tail.length===0}function ic(t,e={lexicalScope:()=>!1}){let r=lr(t,e),s={strictMode:!1,...e,locals:r.blockParams,keywords:e.keywords??[]},n=or.top(s.locals,s.keywords,{customizeComponentName:e.customizeComponentName??(o=>o),lexicalScope:e.lexicalScope}),a=new vs(t,s,n),i=new yt(a);return[new oc(a.loc(r.loc),r.body.map(o=>i.normalize(o)),a).assertTemplate(n),n.getUsedTemplateLocals()]}class vs{builder;constructor(e,r,s){this.source=e,this.options=r,this.table=s,this.builder=new ni}get strict(){return this.options.strictMode||!1}loc(e){return this.source.spanFor(e)}resolutionFor(e,r){if(this.strict)return{result:K};if(this.isFreeVar(e)){let s=r(e);return s===null?{result:"error",path:ii(e),head:li(e)}:{result:s}}return{result:K}}isLexicalVar(e){return this.table.hasLexical(e)}isKeyword(e){return this.strict&&!this.table.hasLexical(e)&&this.table.hasKeyword(e)}isFreeVar(e){return e.type==="PathExpression"?e.head.type==="VarHead"&&!this.table.has(e.head.name):e.path.type==="PathExpression"&&this.isFreeVar(e.path)}hasBinding(e){return this.table.has(e)||this.table.hasLexical(e)}child(e){return new vs(this.source,this.options,this.table.child(e))}customizeComponentName(e){return this.options.customizeComponentName?this.options.customizeComponentName(e):e}}class Gr{constructor(e){this.block=e}normalize(e,r){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return this.path(e,r);case"SubExpression":{wt(e.path)&&vt(e.path,e.loc);let s=this.block.resolutionFor(e,ec);if(s.result==="error")throw k(`You attempted to invoke a path (\`${s.path}\`) but ${s.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,s.result),this.block.loc(e.loc))}}}path(e,r){let s=this.block.loc(e.loc);if(e.head.type==="VarHead"&&e.tail.length===0&&this.block.isKeyword(e.head.name))return this.block.builder.keyword(e.head.name,this.block.table.getKeyword(e.head.name),s);let n=[],a=this.block.loc(e.head.loc);for(let i of e.tail)a=a.sliceStartChars({chars:i.length,skipStart:1}),n.push(new U({loc:a,chars:i}));return this.block.builder.path(this.ref(e.head,r),n,s)}callParts(e,r){let{path:s,params:n,hash:a,loc:i}=e,l=this.normalize(s,r),o=n.map(S=>this.normalize(S,K)),c=te.range(o,l.loc.collapse("end")),h=this.block.loc(a.loc),m=te.range([c,h]),d=this.block.builder.positional(n.map(S=>this.normalize(S,K)),c),y=this.block.builder.named(a.pairs.map(S=>this.namedArgument(S)),this.block.loc(a.loc));switch(l.type){case"Literal":throw k(`Invalid invocation of a literal value (\`${l.value}\`)`,i);case"Interpolate":throw k("Invalid invocation of a interpolated string",i)}return{callee:l,args:this.block.builder.args(d,y,m)}}namedArgument(e){let r=this.block.loc(e.loc).sliceStartChars({chars:e.key.length});return this.block.builder.namedArgument(new U({chars:e.key,loc:r}),this.normalize(e.value,K))}ref(e,r){let{block:s}=this,{builder:n,table:a}=s,i=s.loc(e.loc);switch(e.type){case"ThisHead":return n.self(i);case"AtHead":{let l=a.allocateNamed(e.name);return n.at(e.name,l,i)}case"VarHead":if(s.hasBinding(e.name)){let[l,o]=a.get(e.name);return s.builder.localVar(e.name,l,o,i)}{let l=s.strict?K:r,o=s.table.allocateFree(e.name,l);return s.builder.freeVar({name:e.name,context:l,symbol:o,loc:i})}}}}class yt{constructor(e){this.block=e}normalize(e){switch(e.type){case"BlockStatement":return this.BlockStatement(e);case"ElementNode":return new lc(this.block).ElementNode(e);case"MustacheStatement":return this.MustacheStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":{let r=this.block.loc(e.loc);return new _a({loc:r,text:r.slice({skipStart:4,skipEnd:3}).toSlice(e.value)})}case"TextNode":return new Da({loc:this.block.loc(e.loc),chars:e.chars})}}MustacheCommentStatement(e){let r,s=this.block.loc(e.loc);return r=s.asString().slice(0,5)==="{{!--"?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new Ma({loc:s,text:r.toSlice(e.value)})}MustacheStatement(e){let r,{path:s,params:n,hash:a,trusting:i}=e,l=this.block.loc(e.loc);if(wt(s))n.length===0&&a.pairs.length===0?r=this.expr.normalize(s):vt(s,l);else{let o=this.block.resolutionFor(e,ac);if(o.result==="error")throw k(`You attempted to render a path (\`{{${o.path}}}\`), but ${o.head} was not in scope`,l);let c=this.expr.callParts({path:s,params:n,hash:a,loc:l},o.result);r=c.args.isEmpty()?c.callee:this.block.builder.sexp(c,l)}return this.block.builder.append({table:this.block.table,trusting:i,value:r},l)}BlockStatement(e){let{program:r,inverse:s}=e,n=this.block.loc(e.loc);wt(e.path)&&vt(e.path,n);let a=this.block.resolutionFor(e,rc);if(a.result==="error")throw k(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(e,a.result);return this.block.builder.blockStatement(ie({symbols:this.block.table,program:this.Block(r),inverse:s?this.Block(s):null},i),n)}Block({body:e,loc:r,blockParams:s}){let n=this.block.child(s),a=new yt(n);return new cc(this.block.loc(r),e.map(i=>a.normalize(i)),this.block).assertBlock(n.table)}get expr(){return new Gr(this.block)}}class lc{constructor(e){this.ctx=e}ElementNode(e){let{tag:r,selfClosing:s,comments:n}=e,a=this.ctx.loc(e.loc),[i,...l]=Xe(r.split(".")),o=this.classifyTag(i,l,e.loc),c=e.attributes.filter(P=>P.name[0]!=="@").map(P=>this.attr(P)),h=e.attributes.filter(P=>P.name[0]==="@").map(P=>this.arg(P)),m=e.modifiers.map(P=>this.modifier(P)),d=this.ctx.child(e.blockParams),y=new yt(d),S=e.children.map(P=>y.normalize(P)),I=this.ctx.builder.element({selfClosing:s,attrs:c,componentArgs:h,modifiers:m,comments:n.map(P=>new yt(this.ctx).MustacheCommentStatement(P))}),z=new uc(I,a,S,this.ctx),nt=this.ctx.loc(e.loc).sliceStartChars({chars:r.length,skipStart:1});if(o==="ElementHead")return r[0]===":"?z.assertNamedBlock(nt.slice({skipStart:1}).toSlice(r.slice(1)),d.table):z.assertElement(nt.toSlice(r),e.blockParams.length>0);if(e.selfClosing)return I.selfClosingComponent(o,a);{let P=z.assertComponent(r,d.table,e.blockParams.length>0);return I.componentWithNamedBlocks(o,P,a)}}modifier(e){wt(e.path)&&vt(e.path,e.loc);let r=this.ctx.resolutionFor(e,tc);if(r.result==="error")throw k(`You attempted to invoke a path (\`{{${r.path}}}\`) as a modifier, but ${r.head} was not in scope`,e.loc);let s=this.expr.callParts(e,r.result);return this.ctx.builder.modifier(s,this.ctx.loc(e.loc))}mustacheAttr(e){let{path:r,params:s,hash:n,loc:a}=e;if(wt(r)){if(s.length===0&&n.pairs.length===0)return this.expr.normalize(r);vt(r,a)}let i=this.ctx.resolutionFor(e,nc);if(i.result==="error")throw k(`You attempted to render a path (\`{{${i.path}}}\`), but ${i.head} was not in scope`,e.loc);let l=this.ctx.builder.sexp(this.expr.callParts(e,i.result),this.ctx.loc(e.loc));return l.args.isEmpty()?l.callee:l}attrPart(e){switch(e.type){case"MustacheStatement":return{expr:this.mustacheAttr(e),trusting:e.trusting};case"TextNode":return{expr:this.ctx.builder.literal(e.chars,this.ctx.loc(e.loc)),trusting:!0}}}attrValue(e){if(e.type==="ConcatStatement"){let r=e.parts.map(s=>this.attrPart(s).expr);return{expr:this.ctx.builder.interpolate(r,this.ctx.loc(e.loc)),trusting:!1}}return this.attrPart(e)}attr(e){if(e.name[0],e.name==="...attributes")return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:s,value:n.expr,trusting:n.trusting},r)}checkArgCall(e){let{value:r}=e;if(r.type!=="MustacheStatement"||r.params.length!==0||r.hash.pairs.length!==0)return;let{path:s}=r;if(s.type!=="PathExpression"||s.tail.length>0)return;let n=this.ctx.resolutionFor(s,()=>null);if(n.result==="error"&&n.path!=="has-block")throw k(`You attempted to pass a path as argument (\`${e.name}={{${n.path}}}\`) but ${n.head} was not in scope. Try:
* \`${e.name}={{this.${n.path}}}\` if this is meant to be a property lookup, or
* \`${e.name}={{(${n.path})}}\` if this is meant to invoke the resolved helper, or
* \`${e.name}={{helper "${n.path}"}}\` if this is meant to pass the resolved helper by value`,e.loc)}arg(e){e.name[0],this.checkArgCall(e);let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.arg({name:s,value:n.expr,trusting:n.trusting},r)}classifyTag(e,r,s){let n=(a=e)[0]===a[0]?.toUpperCase()&&a[0]!==a[0]?.toLowerCase();var a;let i=e[0]==="@"||e==="this"||this.ctx.hasBinding(e);if(this.ctx.strict&&!i){if(n)throw k(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${e}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${e.toLowerCase()}>\``,s);return"ElementHead"}let l=i||n,o=s.sliceStartChars({skipStart:1,chars:e.length}),c=r.reduce((d,y)=>d+1+y.length,0),h=o.getEnd().move(c),m=o.withEnd(h);if(l){let d=g.path({head:g.head({original:e,loc:o}),tail:r,loc:m}),y=this.ctx.isLexicalVar(e)?{result:K}:this.ctx.resolutionFor(d,sc);if(y.result==="error")throw k(`You attempted to invoke a path (\`<${y.path}>\`) but ${y.head} was not in scope`,s);return new Gr(this.ctx).normalize(d,y.result)}if(this.ctx.table.allocateFree(e,K),r.length>0)throw k(`You used ${e}.${r.join(".")} as a tag name, but ${e} is not in scope`,s);return"ElementHead"}get expr(){return new Gr(this.ctx)}}class Ss{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(e,r,s){this.loc=e,this.children=r,this.block=s,this.namedBlocks=r.filter(n=>n instanceof Ke),this.hasSemanticContent=!!r.filter(n=>{if(n instanceof Ke)return!1;switch(n.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(n.chars);default:return!0}}).length,this.nonBlockChildren=r.filter(n=>!(n instanceof Ke))}}class oc extends Ss{assertTemplate(e){if(X(this.namedBlocks))throw k("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(e,this.nonBlockChildren,this.block.loc(this.loc))}}class cc extends Ss{assertBlock(e){if(X(this.namedBlocks))throw k("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(e,this.nonBlockChildren,this.loc)}}class uc extends Ss{constructor(e,r,s,n){super(r,s,n),this.el=e}assertNamedBlock(e,r){if(this.el.base.selfClosing)throw k(`<:${e.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(X(this.namedBlocks))throw k(`Unexpected named block inside <:${e.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=e.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw k(`<:${e.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw k(`named block <:${e.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=te.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(e,this.block.builder.block(r,this.nonBlockChildren,n),this.loc)}assertElement(e,r){if(r)throw k(`Unexpected block params in <${e.chars}>: simple elements cannot have block params`,this.loc);if(X(this.namedBlocks)){let s=this.namedBlocks.map(n=>n.name);if(s.length===1)throw k(`Unexpected named block <:foo> inside <${e.chars}> HTML element`,this.loc);{let n=s.map(a=>`<:${a.chars}>`).join(", ");throw k(`Unexpected named blocks inside <${e.chars}> HTML element (${n})`,this.loc)}}return this.el.simple(e,this.nonBlockChildren,this.loc)}assertComponent(e,r,s){if(X(this.namedBlocks)&&this.hasSemanticContent)throw k(`Unexpected content inside <${e}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(X(this.namedBlocks)){if(s)throw k(`Unexpected block params list on <${e}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let n=new Set;for(let a of this.namedBlocks){let i=a.name.chars;if(n.has(i))throw k(`Component had two named blocks with the same name, \`<:${i}>\`. Only one block with a given name may be passed`,this.loc);if(i==="inverse"&&n.has("else")||i==="else"&&n.has("inverse"))throw k("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);n.add(i)}return this.namedBlocks}return[this.block.builder.namedBlock(U.synthetic("default"),this.block.builder.block(r,this.nonBlockChildren,this.loc),this.loc)]}}function wt(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function vt(t,e){throw k(`Unexpected literal \`${t.type==="StringLiteral"?JSON.stringify(t.value):String(t.value)}\``,e)}function ii(t){return t.type!=="PathExpression"&&t.path.type==="PathExpression"?ii(t.path):new cs({entityEncoding:"raw"}).print(t)}function li(t){return t.type==="PathExpression"?t.head.original:t.path.type==="PathExpression"?li(t.path):new cs({entityEncoding:"raw"}).print(t)}const hc=Object.freeze(Object.defineProperty({__proto__:null,AST:rn,ASTv1:rn,ASTv2:Zo,BlockSymbolTable:si,KEYWORDS_TYPES:Mr,Path:Vr,ProgramSymbolTable:ri,SourceSlice:U,SpanList:te,SymbolTable:or,Walker:Vr,WalkerPath:Pt,builders:gs,cannotRemoveNode:zr,cannotReplaceNode:Pa,generateSyntaxError:k,getTemplateLocals:Xo,getVoidTags:Mo,hasSpan:ds,isKeyword:Sa,isVoidTag:os,loc:Ze,maybeLoc:xa,node:B,normalize:ic,preprocess:lr,print:va,sortByLoc:wa,src:Uo,traverse:ir,visitorKeys:Ca},Symbol.toStringTag,{value:"Module"})),{precompileJSON:pc}=nn(Lo),{getTemplateLocals:mc}=nn(hc);function gu(t,e={}){let r=oi(t),s,n;try{s=ci(dc(t,{moduleName:e.moduleName||r,...e}),ui(void 0,"hbs:component"))}catch(a){n=a}return{name:r,component:s,error:n}}function dc(t,{moduleName:e,scope:r={}}){let s={array:gi,concat:fi,fn:di,get:mi,hash:pi,on:hi,...r},n=mc(t),a={strictMode:!0,moduleName:e,locals:n,isProduction:!1,meta:{moduleName:e}},[i,l]=pc(t,a),o=l.map(d=>{let y=s[d];if(!y)throw new Error(`Attempt to use ${d} in compiled hbs, but it was not available in scope. Available scope includes: ${Object.keys(s)}`);return y}),c=JSON.stringify(i);return bi({id:e,block:c,moduleName:e??"(dynamically compiled component)",scope:()=>o,isStrictMode:!0})}export{gu as compileHBS};
