import{n as vs,s as As,t as Ss,e as fr,o as Es,h as Cs,g as xs,f as Ps,c as Ns,b as Bs,a as Ts}from"./main-xHbi8FDi.js";import{p as Rt,a as jt,E as gr,b as Ls,n as Os,_ as Hs}from"./index-Dq8qgdK9.js";function k(t,e){if(!t)throw new Error(e||"assertion failure")}function V(t){Us.warn(`DEPRECATION: ${t}`)}function rt(t){if(t==null)throw new Error("Expected value to be present");return t}function Ne(t,e){if(t==null)throw new Error(e);return t}function Le(t){throw new Error(`Exhausted ${String(t)}`)}function T(t){return t.length>0}function we(t,e="unexpected empty list"){if(!T(t))throw new Error(e)}function ve(t,e="unexpected empty list"){return we(t,e),t}function Ce(t){return t.length===0?void 0:t[t.length-1]}function Et(t){return t.length===0?void 0:t[0]}function br(t,e){if(t===null)return null;let r=[];for(let s of t)r.push(e(s));return r}function K(){return Object.create(null)}const Is="http://www.w3.org/1999/xlink",$s="http://www.w3.org/XML/1998/namespace",Wt="http://www.w3.org/2000/xmlns/";let Ct=function(t){return t[t.MAX_SMI=1073741823]="MAX_SMI",t[t.MIN_SMI=-1073741824]="MIN_SMI",t[t.SIGN_BIT=-536870913]="SIGN_BIT",t[t.MAX_INT=536870911]="MAX_INT",t[t.MIN_INT=-536870912]="MIN_INT",t[t.FALSE_HANDLE=0]="FALSE_HANDLE",t[t.TRUE_HANDLE=1]="TRUE_HANDLE",t[t.NULL_HANDLE=2]="NULL_HANDLE",t[t.UNDEFINED_HANDLE=3]="UNDEFINED_HANDLE",t[t.ENCODED_FALSE_HANDLE=0]="ENCODED_FALSE_HANDLE",t[t.ENCODED_TRUE_HANDLE=1]="ENCODED_TRUE_HANDLE",t[t.ENCODED_NULL_HANDLE=2]="ENCODED_NULL_HANDLE",t[t.ENCODED_UNDEFINED_HANDLE=3]="ENCODED_UNDEFINED_HANDLE",t}({});function Ds(t){return t&Ct.SIGN_BIT}function Ms(t){return t|~Ct.SIGN_BIT}function Fs(t){return~t}function _s(t){return~t}function Gs(t){return(t|=0)<0?Ds(t):Fs(t)}function Vs(t){return(t|=0)>Ct.SIGN_BIT?_s(t):Ms(t)}[1,-1].forEach(t=>Vs(Gs(t)));let W=Object.assign;function zs(t){return Object.values(t)}const Us=console,Kt=console;function q(t,e="unexpected unreachable branch"){throw Kt.log("unreachable",t),Kt.log(`${e} :: ${JSON.stringify(t)} (${t})`),new Error("code reached unreachable")}const c={Append:1,TrustingAppend:2,Comment:3,Modifier:4,Block:6,Component:8,OpenElement:10,OpenElementWithSplat:11,FlushElement:12,CloseElement:13,StaticAttr:14,DynamicAttr:15,ComponentAttr:16,AttrSplat:17,Yield:18,DynamicArg:20,StaticArg:21,TrustingDynamicAttr:22,TrustingComponentAttr:23,StaticComponentAttr:24,Debugger:26,Undefined:27,Call:28,Concat:29,GetSymbol:30,GetLexicalSymbol:32,GetStrictKeyword:31,GetFreeAsComponentOrHelperHead:35,GetFreeAsHelperHead:37,GetFreeAsModifierHead:38,GetFreeAsComponentHead:39,InElement:40,If:41,Each:42,Let:44,WithDynamicVars:45,InvokeComponent:46,HasBlock:48,HasBlockParams:49,Curry:50,Not:51,IfInline:52,GetDynamicVar:53,Log:54},U={Strict:0,ResolveAsComponentOrHelperHead:1,ResolveAsHelperHead:5,ResolveAsModifierHead:6,ResolveAsComponentHead:7},oe={class:0,id:1,value:2,name:3,type:4,style:5,href:6},Ve={div:0,span:1,p:2,a:3};var ee=function(t){return t[t.NBSP=160]="NBSP",t[t.QUOT=34]="QUOT",t[t.LT=60]="LT",t[t.GT=62]="GT",t[t.AMP=38]="AMP",t}(ee||{});const kr=/["&\xA0]/u,Rs=new RegExp(kr.source,"gu"),yr=/[&<>\xA0]/u,js=new RegExp(yr.source,"gu");function Ws(t){switch(t.charCodeAt(0)){case ee.NBSP:return"&nbsp;";case ee.QUOT:return"&quot;";case ee.AMP:return"&amp;";default:return t}}function Ks(t){switch(t.charCodeAt(0)){case ee.NBSP:return"&nbsp;";case ee.AMP:return"&amp;";case ee.LT:return"&lt;";case ee.GT:return"&gt;";default:return t}}function Ys(t,e){return t.loc.isInvisible||e.loc.isInvisible?0:t.loc.startPosition.line<e.loc.startPosition.line||t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column<e.loc.startPosition.column?-1:t.loc.startPosition.line===e.loc.startPosition.line&&t.loc.startPosition.column===e.loc.startPosition.column?0:1}const gt=new Set(["area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"]),Js=/^\S/u;function wr(t){return gt.has(t.toLowerCase())&&t[0]?.toLowerCase()===t[0]}class xt{buffer="";options;constructor(e){this.options=e}handledByOverride(e,r=!1){if(this.options.override!==void 0){let s=this.options.override(e,this.options);if(typeof s=="string")return r&&Js.test(s)&&(s=` ${s}`),this.buffer+=s,!0}return!1}Node(e){switch(e.type){case"MustacheStatement":case"BlockStatement":case"MustacheCommentStatement":case"CommentStatement":case"TextNode":case"ElementNode":case"AttrNode":case"Block":case"Template":return this.TopLevelStatement(e);case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":case"PathExpression":case"SubExpression":return this.Expression(e);case"ConcatStatement":return this.ConcatStatement(e);case"Hash":return this.Hash(e);case"HashPair":return this.HashPair(e);case"ElementModifierStatement":return this.ElementModifierStatement(e)}}Expression(e){switch(e.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return this.Literal(e);case"PathExpression":return this.PathExpression(e);case"SubExpression":return this.SubExpression(e)}}Literal(e){switch(e.type){case"StringLiteral":return this.StringLiteral(e);case"BooleanLiteral":return this.BooleanLiteral(e);case"NumberLiteral":return this.NumberLiteral(e);case"UndefinedLiteral":return this.UndefinedLiteral(e);case"NullLiteral":return this.NullLiteral(e)}}TopLevelStatement(e){switch(e.type){case"MustacheStatement":return this.MustacheStatement(e);case"BlockStatement":return this.BlockStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":return this.CommentStatement(e);case"TextNode":return this.TextNode(e);case"ElementNode":return this.ElementNode(e);case"Block":return this.Block(e);case"Template":return this.Template(e);case"AttrNode":return this.AttrNode(e)}}Template(e){this.TopLevelStatements(e.body)}Block(e){e.chained&&(e.body[0].chained=!0),this.handledByOverride(e)||this.TopLevelStatements(e.body)}TopLevelStatements(e){e.forEach(r=>this.TopLevelStatement(r))}ElementNode(e){this.handledByOverride(e)||(this.OpenElementNode(e),this.TopLevelStatements(e.children),this.CloseElementNode(e))}OpenElementNode(e){this.buffer+=`<${e.tag}`;const r=[...e.attributes,...e.modifiers,...e.comments].sort(Ys);for(const s of r)switch(this.buffer+=" ",s.type){case"AttrNode":this.AttrNode(s);break;case"ElementModifierStatement":this.ElementModifierStatement(s);break;case"MustacheCommentStatement":this.MustacheCommentStatement(s)}e.blockParams.length&&this.BlockParams(e.blockParams),e.selfClosing&&(this.buffer+=" /"),this.buffer+=">"}CloseElementNode(e){e.selfClosing||wr(e.tag)||(this.buffer+=`</${e.tag}>`)}AttrNode(e){if(this.handledByOverride(e))return;let{name:r,value:s}=e;this.buffer+=r,(s.type!=="TextNode"||s.chars.length>0)&&(this.buffer+="=",this.AttrNodeValue(s))}AttrNodeValue(e){e.type==="TextNode"?(this.buffer+='"',this.TextNode(e,!0),this.buffer+='"'):this.Node(e)}TextNode(e,r){var s;this.handledByOverride(e)||(this.options.entityEncoding==="raw"?this.buffer+=e.chars:this.buffer+=r?(s=e.chars,kr.test(s)?s.replace(Rs,Ws):s):function(n){return yr.test(n)?n.replace(js,Ks):n}(e.chars))}MustacheStatement(e){this.handledByOverride(e)||(this.buffer+=e.trusting?"{{{":"{{",e.strip.open&&(this.buffer+="~"),this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.strip.close&&(this.buffer+="~"),this.buffer+=e.trusting?"}}}":"}}")}BlockStatement(e){this.handledByOverride(e)||(e.chained?(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else "):this.buffer+=e.openStrip.open?"{{~#":"{{#",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),e.program.blockParams.length&&this.BlockParams(e.program.blockParams),e.chained?this.buffer+=e.inverseStrip.close?"~}}":"}}":this.buffer+=e.openStrip.close?"~}}":"}}",this.Block(e.program),e.inverse&&(e.inverse.chained||(this.buffer+=e.inverseStrip.open?"{{~":"{{",this.buffer+="else",this.buffer+=e.inverseStrip.close?"~}}":"}}"),this.Block(e.inverse)),e.chained||(this.buffer+=e.closeStrip.open?"{{~/":"{{/",this.Expression(e.path),this.buffer+=e.closeStrip.close?"~}}":"}}"))}BlockParams(e){this.buffer+=` as |${e.join(" ")}|`}ConcatStatement(e){this.handledByOverride(e)||(this.buffer+='"',e.parts.forEach(r=>{r.type==="TextNode"?this.TextNode(r,!0):this.Node(r)}),this.buffer+='"')}MustacheCommentStatement(e){this.handledByOverride(e)||(this.buffer+=`{{!--${e.value}--}}`)}ElementModifierStatement(e){this.handledByOverride(e)||(this.buffer+="{{",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+="}}")}CommentStatement(e){this.handledByOverride(e)||(this.buffer+=`<!--${e.value}-->`)}PathExpression(e){this.handledByOverride(e)||(this.buffer+=e.original)}SubExpression(e){this.handledByOverride(e)||(this.buffer+="(",this.Expression(e.path),this.Params(e.params),this.Hash(e.hash),this.buffer+=")")}Params(e){e.length&&e.forEach(r=>{this.buffer+=" ",this.Expression(r)})}Hash(e){this.handledByOverride(e,!0)||e.pairs.forEach(r=>{this.buffer+=" ",this.HashPair(r)})}HashPair(e){this.handledByOverride(e)||(this.buffer+=e.key,this.buffer+="=",this.Node(e.value))}StringLiteral(e){this.handledByOverride(e)||(this.buffer+=JSON.stringify(e.value))}BooleanLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}NumberLiteral(e){this.handledByOverride(e)||(this.buffer+=e.value)}UndefinedLiteral(e){this.handledByOverride(e)||(this.buffer+="undefined")}NullLiteral(e){this.handledByOverride(e)||(this.buffer+="null")}print(e){let{options:r}=this;if(r.override){let s=r.override(e,r);if(s!==void 0)return s}return this.buffer="",this.Node(e),this.buffer}}function qs(t,e={entityEncoding:"transformed"}){return t?new xt(e).print(t):""}function Xs(t,e){return t in je&&(e===void 0||je[t].includes(e))}const je={action:["Call","Modifier"],component:["Call","Append","Block"],debugger:["Append"],"each-in":["Block"],each:["Block"],"has-block-params":["Call","Append"],"has-block":["Call","Append"],helper:["Call","Append"],if:["Call","Append","Block"],"in-element":["Block"],let:["Block"],log:["Call","Append"],modifier:["Call","Modifier"],mount:["Append"],mut:["Call","Append"],outlet:["Append"],readonly:["Call","Append"],unbound:["Call","Append"],unless:["Call","Append","Block"],yield:["Append"]},X=Object.freeze({line:1,column:0}),vr=Object.freeze({source:"(synthetic)",start:X,end:X}),be=Object.freeze({source:"(nonexistent)",start:X,end:X}),te=Object.freeze({source:"(broken)",start:X,end:X});let w=function(t){return t.CharPosition="CharPosition",t.HbsPosition="HbsPosition",t.InternalsSynthetic="InternalsSynthetic",t.NonExistent="NonExistent",t.Broken="Broken",t}({});const Oe="MATCH_ANY",bt="IS_INVISIBLE";class Qs{_whens;constructor(e){this._whens=e}first(e){for(const r of this._whens){const s=r.match(e);if(T(s))return s[0]}return null}}class Yt{_map=new Map;get(e,r){let s=this._map.get(e);return s||(s=r(),this._map.set(e,s),s)}add(e,r){this._map.set(e,r)}match(e){const r=function(i){switch(i){case w.Broken:case w.InternalsSynthetic:case w.NonExistent:return bt;default:return i}}(e),s=[],n=this._map.get(r),a=this._map.get(Oe);return n&&s.push(n),a&&s.push(a),s}}function Ar(t){return t(new Zs).check()}class Zs{_whens=new Yt;check(){return(e,r)=>this.matchFor(e.kind,r.kind)(e,r)}matchFor(e,r){const s=this._whens.match(e);k(T(s),`no match defined for (${e}, ${r}) and no AnyMatch defined either`);const n=new Qs(s).first(r);return k(n!==null,`no match defined for (${e}, ${r}) and no AnyMatch defined either`),n}when(e,r,s){return this._whens.get(e,()=>new Yt).add(r,s),this}}class ${static synthetic(e){let r=N.synthetic(e);return new $({loc:r,chars:e})}static load(e,r){return new $({loc:N.load(e,r[1]),chars:r[0]})}chars;loc;constructor(e){this.loc=e.loc,this.chars=e.chars}getString(){return this.chars}serialize(){return[this.chars,this.loc.serialize()]}}class N{static get NON_EXISTENT(){return new ue(w.NonExistent,be).wrap()}static load(e,r){return typeof r=="number"?N.forCharPositions(e,r,r):typeof r=="string"?N.synthetic(r):Array.isArray(r)?N.forCharPositions(e,r[0],r[1]):r===w.NonExistent?N.NON_EXISTENT:r===w.Broken?N.broken(te):void q(r)}static forHbsLoc(e,r){const s=new Ae(e,r.start),n=new Ae(e,r.end);return new Nt(e,{start:s,end:n},r).wrap()}static forCharPositions(e,r,s){const n=new He(e,r),a=new He(e,s);return new Pt(e,{start:n,end:a}).wrap()}static synthetic(e){return new ue(w.InternalsSynthetic,be,e).wrap()}static broken(e=te){return new ue(w.Broken,e).wrap()}isInvisible;constructor(e){this.data=e,this.isInvisible=e.kind!==w.CharPosition&&e.kind!==w.HbsPosition}getStart(){return this.data.getStart().wrap()}getEnd(){return this.data.getEnd().wrap()}get loc(){const e=this.data.toHbsSpan();return e===null?te:e.toHbsLoc()}get module(){return this.data.getModule()}get startPosition(){return this.loc.start}get endPosition(){return this.loc.end}toJSON(){return this.loc}withStart(e){return R(e.data,this.data.getEnd())}withEnd(e){return R(this.data.getStart(),e.data)}asString(){return this.data.asString()}toSlice(e){const r=this.data.asString();return new $({loc:this,chars:e||r})}get start(){return this.loc.start}set start(e){this.data.locDidUpdate({start:e})}get end(){return this.loc.end}set end(e){this.data.locDidUpdate({end:e})}get source(){return this.module}collapse(e){switch(e){case"start":return this.getStart().collapsed();case"end":return this.getEnd().collapsed()}}extend(e){return R(this.data.getStart(),e.data.getEnd())}serialize(){return this.data.serialize()}slice({skipStart:e=0,skipEnd:r=0}){return R(this.getStart().move(e).data,this.getEnd().move(-r).data)}sliceStartChars({skipStart:e=0,chars:r}){return R(this.getStart().move(e).data,this.getStart().move(e+r).data)}sliceEndChars({skipEnd:e=0,chars:r}){return R(this.getEnd().move(e-r).data,this.getStart().move(-e).data)}}class Pt{kind=w.CharPosition;_locPosSpan=null;constructor(e,r){this.source=e,this.charPositions=r}wrap(){return new N(this)}asString(){return this.source.slice(this.charPositions.start.charPos,this.charPositions.end.charPos)}getModule(){return this.source.module}getStart(){return this.charPositions.start}getEnd(){return this.charPositions.end}locDidUpdate(){}toHbsSpan(){let e=this._locPosSpan;if(e===null){const r=this.charPositions.start.toHbsPos(),s=this.charPositions.end.toHbsPos();e=this._locPosSpan=r===null||s===null?se:new Nt(this.source,{start:r,end:s})}return e===se?null:e}serialize(){const{start:{charPos:e},end:{charPos:r}}=this.charPositions;return e===r?e:[e,r]}toCharPosSpan(){return this}}class Nt{kind=w.HbsPosition;_charPosSpan=null;_providedHbsLoc;constructor(e,r,s=null){this.source=e,this.hbsPositions=r,this._providedHbsLoc=s}serialize(){const e=this.toCharPosSpan();return e===null?w.Broken:e.wrap().serialize()}wrap(){return new N(this)}updateProvided(e,r){this._providedHbsLoc&&(this._providedHbsLoc[r]=e),this._charPosSpan=null,this._providedHbsLoc={start:e,end:e}}locDidUpdate({start:e,end:r}){e!==void 0&&(this.updateProvided(e,"start"),this.hbsPositions.start=new Ae(this.source,e,null)),r!==void 0&&(this.updateProvided(r,"end"),this.hbsPositions.end=new Ae(this.source,r,null))}asString(){const e=this.toCharPosSpan();return e===null?"":e.asString()}getModule(){return this.source.module}getStart(){return this.hbsPositions.start}getEnd(){return this.hbsPositions.end}toHbsLoc(){return{start:this.hbsPositions.start.hbsPos,end:this.hbsPositions.end.hbsPos}}toHbsSpan(){return this}toCharPosSpan(){let e=this._charPosSpan;if(e===null){const r=this.hbsPositions.start.toCharPos(),s=this.hbsPositions.end.toCharPos();if(!r||!s)return e=this._charPosSpan=se,null;e=this._charPosSpan=new Pt(this.source,{start:r,end:s})}return e===se?null:e}}class ue{constructor(e,r,s=null){this.kind=e,this.loc=r,this.string=s}serialize(){switch(this.kind){case w.Broken:case w.NonExistent:return this.kind;case w.InternalsSynthetic:return this.string||""}}wrap(){return new N(this)}asString(){return this.string||""}locDidUpdate({start:e,end:r}){e!==void 0&&(this.loc.start=e),r!==void 0&&(this.loc.end=r)}getModule(){return"an unknown module"}getStart(){return new kt(this.kind,this.loc.start)}getEnd(){return new kt(this.kind,this.loc.end)}toCharPosSpan(){return this}toHbsSpan(){return null}toHbsLoc(){return te}}const R=Ar(t=>t.when(w.HbsPosition,w.HbsPosition,(e,r)=>new Nt(e.source,{start:e,end:r}).wrap()).when(w.CharPosition,w.CharPosition,(e,r)=>new Pt(e.source,{start:e,end:r}).wrap()).when(w.CharPosition,w.HbsPosition,(e,r)=>{const s=r.toCharPos();return s===null?new ue(w.Broken,te).wrap():R(e,s)}).when(w.HbsPosition,w.CharPosition,(e,r)=>{const s=e.toCharPos();return s===null?new ue(w.Broken,te).wrap():R(s,r)}).when(bt,Oe,e=>new ue(e.kind,te).wrap()).when(Oe,bt,(e,r)=>new ue(r.kind,te).wrap())),se="BROKEN";class ne{static forHbsPos(e,r){return new Ae(e,r,null).wrap()}static broken(e=X){return new kt(w.Broken,e).wrap()}constructor(e){this.data=e}get offset(){const e=this.data.toCharPos();return e===null?null:e.offset}eql(e){return en(this.data,e.data)}until(e){return R(this.data,e.data)}move(e){const r=this.data.toCharPos();if(r===null)return ne.broken();{const s=r.offset+e;return r.source.check(s)?new He(r.source,s).wrap():ne.broken()}}collapsed(){return R(this.data,this.data)}toJSON(){return this.data.toJSON()}}class He{kind=w.CharPosition;_locPos=null;constructor(e,r){this.source=e,this.charPos=r}toCharPos(){return this}toJSON(){const e=this.toHbsPos();return e===null?X:e.toJSON()}wrap(){return new ne(this)}get offset(){return this.charPos}toHbsPos(){let e=this._locPos;if(e===null){const r=this.source.hbsPosFor(this.charPos);this._locPos=e=r===null?se:new Ae(this.source,r,this.charPos)}return e===se?null:e}}class Ae{kind=w.HbsPosition;_charPos;constructor(e,r,s=null){this.source=e,this.hbsPos=r,this._charPos=s===null?null:new He(e,s)}toCharPos(){let e=this._charPos;if(e===null){const r=this.source.charPosFor(this.hbsPos);this._charPos=e=r===null?se:new He(this.source,r)}return e===se?null:e}toJSON(){return this.hbsPos}wrap(){return new ne(this)}toHbsPos(){return this}}class kt{constructor(e,r){this.kind=e,this.pos=r}toCharPos(){return null}toJSON(){return this.pos}wrap(){return new ne(this)}get offset(){return null}}const en=Ar(t=>t.when(w.HbsPosition,w.HbsPosition,({hbsPos:e},{hbsPos:r})=>e.column===r.column&&e.line===r.line).when(w.CharPosition,w.CharPosition,({charPos:e},{charPos:r})=>e===r).when(w.CharPosition,w.HbsPosition,({offset:e},r)=>e===r.toCharPos()?.offset).when(w.HbsPosition,w.CharPosition,(e,{offset:r})=>e.toCharPos()?.offset===r).when(Oe,Oe,()=>!1));class re{static from(e,r={}){return new re(e,r.meta?.moduleName)}constructor(e,r="an unknown module"){this.source=e,this.module=r}check(e){return e>=0&&e<=this.source.length}slice(e,r){return this.source.slice(e,r)}offsetFor(e,r){return ne.forHbsPos(this,{line:e,column:r})}spanFor({start:e,end:r}){return N.forHbsLoc(this,{start:{line:e.line,column:e.column},end:{line:r.line,column:r.column}})}hbsPosFor(e){let r=0,s=0;if(e>this.source.length)return null;for(;;){let n=this.source.indexOf(`
`,s);if(e<=n||n===-1)return{line:r+1,column:e-s};r+=1,s=n+1}}charPosFor(e){let{line:r,column:s}=e,n=this.source.length,a=0,i=0;for(;i<n;){let l=this.source.indexOf(`
`,i);if(l===-1&&(l=this.source.length),a===r-1)return i+s>l?l:i+s;if(l===-1)return 0;a+=1,i=l+1}return n}}class Y{static range(e,r=N.NON_EXISTENT){return new Y(e.map(Se)).getRangeOffset(r)}_span;constructor(e=[]){this._span=e}add(e){this._span.push(e)}getRangeOffset(e){if(T(this._span)){let r=Et(this._span),s=Ce(this._span);return r.extend(s)}return e}}function Se(t){if(Array.isArray(t)){let e=Et(t),r=Ce(t);return Se(e).extend(Se(r))}return t instanceof N?t:t.loc}function Sr(t){return!Array.isArray(t)||t.length!==0}function yt(t,e){return Sr(t)?Se(t):e}var We=Object.freeze({__proto__:null,NON_EXISTENT_LOCATION:be,SYNTHETIC_LOCATION:vr,Source:re,SourceOffset:ne,SourceSlice:$,SourceSpan:N,SpanList:Y,UNKNOWN_POSITION:X,hasSpan:Sr,loc:Se,maybeLoc:yt});function u(t,e){let{module:r,loc:s}=e,{line:n,column:a}=s.start,i=e.asString(),l=i?`

|
|  ${i.split(`
`).join(`
|  `)}
|

`:"",o=new Error(`${t}: ${l}(error occurred in '${r}' @ line ${n} : column ${a})`);return o.name="SyntaxError",o.location=e,o.code=i,o}const tn={Template:["body"],Block:["body"],MustacheStatement:["path","params","hash"],BlockStatement:["path","params","hash","program","inverse"],ElementModifierStatement:["path","params","hash"],CommentStatement:[],MustacheCommentStatement:[],ElementNode:["attributes","modifiers","children","comments"],AttrNode:["value"],TextNode:[],ConcatStatement:["parts"],SubExpression:["path","params","hash"],PathExpression:[],StringLiteral:[],BooleanLiteral:[],NumberLiteral:[],NullLiteral:[],UndefinedLiteral:[],Hash:["pairs"],HashPair:["value"]},Bt=function(){function t(e,r,s,n){let a=Error.call(this,e);this.key=n,this.message=e,this.node=r,this.parent=s,a.stack&&(this.stack=a.stack)}return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}();function Jt(t,e,r){return new Bt("Cannot remove a node unless it is part of an array",t,e,r)}function rn(t,e,r){return new Bt("Cannot replace a node with multiple nodes unless it is part of an array",t,e,r)}function qt(t,e){return new Bt("Replacing and removing in key handlers is not yet supported.",t,null,e)}class st{node;parent;parentKey;constructor(e,r=null,s=null){this.node=e,this.parent=r,this.parentKey=s}get parentNode(){return this.parent?this.parent.node:null}parents(){return{[Symbol.iterator]:()=>new sn(this)}}}class sn{path;constructor(e){this.path=e}next(){return this.path.parent?(this.path=this.path.parent,{done:!1,value:this.path}):{done:!0,value:null}}}function Er(t){return typeof t=="function"?t:t.enter}function Cr(t){return typeof t=="function"?void 0:t.exit}function nt(t,e){let r,s,n,{node:a,parent:i,parentKey:l}=e,o=function(h,p){if(h.Program&&(p==="Template"&&!h.Template||p==="Block"&&!h.Block))return V(`The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${p}') `),h.Program;let f=h[p];return f!==void 0?f:h.All}(t,a.type);if(o!==void 0&&(r=Er(o),s=Cr(o)),r!==void 0&&(n=r(a,e)),n!=null){if(JSON.stringify(a)!==JSON.stringify(n))return Array.isArray(n)?(xr(t,n,i,l),n):nt(t,new st(n,i,l))||n;n=void 0}if(n===void 0){let h=tn[a.type];for(let p=0;p<h.length;p++)nn(t,o,e,h[p]);s!==void 0&&(n=s(a,e))}return n}function Xt(t,e,r){t[e]=r}function nn(t,e,r,s){let n,a,{node:i}=r,l=function(o,h){return o[h]}(i,s);if(l){if(e!==void 0){let o=function(h,p){let f=typeof h!="function"?h.keys:void 0;if(f===void 0)return;let g=f[p];return g!==void 0?g:f.All}(e,s);o!==void 0&&(n=Er(o),a=Cr(o))}if(n!==void 0&&n(i,s)!==void 0)throw qt(i,s);if(Array.isArray(l))xr(t,l,r,s);else{let o=nt(t,new st(l,r,s));o!==void 0&&function(h,p,f,g){if(g===null)throw Jt(f,h,p);if(Array.isArray(g)){if(g.length!==1)throw g.length===0?Jt(f,h,p):rn(f,h,p);Xt(h,p,g[0])}else Xt(h,p,g)}(i,s,l,o)}if(a!==void 0&&a(i,s)!==void 0)throw qt(i,s)}}function xr(t,e,r,s){for(let n=0;n<e.length;n++){let a=rt(e[n]),i=nt(t,new st(a,r,s));i!==void 0&&(n+=an(e,n,i)-1)}}function an(t,e,r){return r===null?(t.splice(e,1),0):Array.isArray(r)?(t.splice(e,1,...r),r.length):(t.splice(e,1,r),1)}function Pr(t,e){nt(e,new st(t))}class ln{stack=[];constructor(e){this.order=e}visit(e,r){e&&(this.stack.push(e),this.order==="post"?(this.children(e,r),r(e,this)):(r(e,this),this.children(e,r)),this.stack.pop())}children(e,r){switch(e.type){case"Block":case"Template":return void Qt(this,e.body,r);case"ElementNode":return void Qt(this,e.children,r);case"BlockStatement":return this.visit(e.program,r),void this.visit(e.inverse||null,r);default:return}}}function Qt(t,e,r){for(const s of e)t.visit(s,r)}function ke(t,e){(function(r){switch(r.type){case"Block":case"Template":return r.body;case"ElementNode":return r.children}})(t).push(e)}function Nr(t){return t.type==="StringLiteral"||t.type==="BooleanLiteral"||t.type==="NumberLiteral"||t.type==="NullLiteral"||t.type==="UndefinedLiteral"}let lt;function ot(){return lt||(lt=new re("","(synthetic)")),lt}function Zt(t,e){return m.var({name:t,loc:x(e||null)})}function Z(t,e){let r=x(e||null);if(typeof t!="string"){if("type"in t)return t;{k(t.head.indexOf(".")===-1,"builder.path({ head, tail }) should not be called with a head with dots in it");let{head:a,tail:i}=t;return m.path({head:m.head({original:a,loc:r.sliceStartChars({chars:a.length})}),tail:i,loc:x(e||null)})}}let{head:s,tail:n}=function(a,i){let[l,...o]=ve(a.split(".")),h=m.head({original:l,loc:x(i||null)});return m.path({head:h,tail:o,loc:x(i||null)})}(t,r);return m.path({head:s,tail:n,loc:r})}function Ue(t,e,r){return m.literal({type:t,value:e,loc:x(r||null)})}function xe(t=[],e){return m.hash({pairs:t,loc:x(e||null)})}function Br(t){return t.map(e=>typeof e=="string"?m.var({name:e,loc:N.synthetic(e)}):e)}function er(t=[],e=[],r=!1,s){return m.blockItself({body:t,params:Br(e),chained:r,loc:x(s||null)})}function tr(t=[],e=[],r){return m.template({body:t,blockParams:e,loc:x(r||null)})}function x(...t){if(t.length===1){let e=t[0];return e&&typeof e=="object"?N.forHbsLoc(ot(),e):N.forHbsLoc(ot(),vr)}{let[e,r,s,n,a]=t,i=a?new re("",a):ot();return N.forHbsLoc(i,{start:{line:e,column:r},end:{line:s||e,column:n||r}})}}var Tr={mustache:function(t,e=[],r=xe([]),s=!1,n,a){return m.mustache({path:Z(t),params:e,hash:r,trusting:s,strip:a,loc:x(n||null)})},block:function(t,e,r,s,n=null,a,i,l,o){let h,p=null;return s.type==="Template"?(V("b.program is deprecated. Use b.blockItself instead."),h=m.blockItself({params:Br(s.blockParams),body:s.body,loc:s.loc})):h=s,n?.type==="Template"?(V("b.program is deprecated. Use b.blockItself instead."),k(n.blockParams.length===0,"{{else}} block cannot have block params"),p=m.blockItself({params:[],body:n.body,loc:n.loc})):p=n,m.block({path:Z(t),params:e||[],hash:r||xe([]),defaultBlock:h,elseBlock:p,loc:x(a||null),openStrip:i,inverseStrip:l,closeStrip:o})},comment:function(t,e){return m.comment({value:t,loc:x(e||null)})},mustacheComment:function(t,e){return m.mustacheComment({value:t,loc:x(e||null)})},element:function(t,e={}){let r,s,{attrs:n,blockParams:a,modifiers:i,comments:l,children:o,openTag:h,closeTag:p,loc:f}=e;typeof t=="string"?t.endsWith("/")?(r=Z(t.slice(0,-1)),s=!0):r=Z(t):"type"in t?(k(t.type==="PathExpression",`Invalid tag type ${t.type}`),r=t):"path"in t?(k(t.path.type==="PathExpression",`Invalid tag type ${t.path.type}`),r=t.path,s=t.selfClosing):(r=Z(t.name),s=t.selfClosing),s&&k(p==null,"Cannot build a self-closing tag with a closeTag source location");let g=a?.map(P=>typeof P=="string"?Zt(P):P),S=null;return p?S=x(p||null):p===void 0&&(S=s||wr(r.original)?null:x(null)),m.element({path:r,selfClosing:s||!1,attributes:n||[],params:g||[],modifiers:i||[],comments:l||[],children:o||[],openTag:x(h||null),closeTag:S,loc:x(f||null)})},elementModifier:function(t,e,r,s){return m.elementModifier({path:Z(t),params:e||[],hash:r||xe([]),loc:x(s||null)})},attr:function(t,e,r){return m.attr({name:t,value:e,loc:x(r||null)})},text:function(t="",e){return m.text({chars:t,loc:x(e||null)})},sexpr:function(t,e=[],r=xe([]),s){return m.sexpr({path:Z(t),params:e,hash:r,loc:x(s||null)})},concat:function(t,e){if(!T(t))throw new Error("b.concat requires at least one part");return m.concat({parts:t,loc:x(e||null)})},hash:xe,pair:function(t,e,r){return m.pair({key:t,value:e,loc:x(r||null)})},literal:Ue,program:function(t,e,r){return V("b.program is deprecated. Use b.template or b.blockItself instead."),e&&e.length?er(t,e,!1,r):tr(t,[],r)},blockItself:er,template:tr,loc:x,pos:function(t,e){return m.pos({line:t,column:e})},path:Z,fullPath:function(t,e=[],r){return m.path({head:t,tail:e,loc:x(r||null)})},head:function(t,e){return m.head({original:t,loc:x(e||null)})},at:function(t,e){return m.atName({name:t,loc:x(e||null)})},var:Zt,this:function(t){return m.this({loc:x(t||null)})},string:ct("StringLiteral"),boolean:ct("BooleanLiteral"),number:ct("NumberLiteral"),undefined:()=>Ue("UndefinedLiteral",void 0),null:()=>Ue("NullLiteral",null)};function ct(t){return function(e,r){return Ue(t,e,r)}}const ze={close:!1,open:!1},m=new class{pos({line:t,column:e}){return{line:t,column:e}}blockItself({body:t,params:e,chained:r=!1,loc:s}){return{type:"Block",body:t,params:e,get blockParams(){return this.params.map(n=>n.name)},set blockParams(n){this.params=n.map(a=>m.var({name:a,loc:N.synthetic(a)}))},chained:r,loc:s}}template({body:t,blockParams:e,loc:r}){return{type:"Template",body:t,blockParams:e,loc:r}}mustache({path:t,params:e,hash:r,trusting:s,loc:n,strip:a=ze}){return function({path:i,params:l,hash:o,trusting:h,strip:p,loc:f}){const g={type:"MustacheStatement",path:i,params:l,hash:o,trusting:h,strip:p,loc:f};return Object.defineProperty(g,"escaped",{enumerable:!1,get(){return V("The escaped property on mustache nodes is deprecated, use trusting instead"),!this.trusting},set(S){V("The escaped property on mustache nodes is deprecated, use trusting instead"),this.trusting=!S}}),g}({path:t,params:e,hash:r,trusting:s,strip:a,loc:n})}block({path:t,params:e,hash:r,defaultBlock:s,elseBlock:n=null,loc:a,openStrip:i=ze,inverseStrip:l=ze,closeStrip:o=ze}){return{type:"BlockStatement",path:t,params:e,hash:r,program:s,inverse:n,loc:a,openStrip:i,inverseStrip:l,closeStrip:o}}comment({value:t,loc:e}){return{type:"CommentStatement",value:t,loc:e}}mustacheComment({value:t,loc:e}){return{type:"MustacheCommentStatement",value:t,loc:e}}concat({parts:t,loc:e}){return{type:"ConcatStatement",parts:t,loc:e}}element({path:t,selfClosing:e,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:h}){let p=e;return{type:"ElementNode",path:t,attributes:r,modifiers:s,params:n,comments:a,children:i,openTag:l,closeTag:o,loc:h,get tag(){return this.path.original},set tag(f){this.path.original=f},get blockParams(){return this.params.map(f=>f.name)},set blockParams(f){this.params=f.map(g=>m.var({name:g,loc:N.synthetic(g)}))},get selfClosing(){return p},set selfClosing(f){p=f,this.closeTag=f?null:N.synthetic(`</${this.tag}>`)}}}elementModifier({path:t,params:e,hash:r,loc:s}){return{type:"ElementModifierStatement",path:t,params:e,hash:r,loc:s}}attr({name:t,value:e,loc:r}){return{type:"AttrNode",name:t,value:e,loc:r}}text({chars:t,loc:e}){return{type:"TextNode",chars:t,loc:e}}sexpr({path:t,params:e,hash:r,loc:s}){return{type:"SubExpression",path:t,params:e,hash:r,loc:s}}path({head:t,tail:e,loc:r}){return function({head:s,tail:n,loc:a}){const i={type:"PathExpression",head:s,tail:n,get original(){return[this.head.original,...this.tail].join(".")},set original(l){let[o,...h]=ve(l.split("."));this.head=Tr.head(o,this.head.loc),this.tail=h},loc:a};return Object.defineProperty(i,"parts",{enumerable:!1,get(){V("The parts property on path nodes is deprecated, use head and tail instead");let l=ve(this.original.split("."));return l[0]==="this"?l.shift():l[0].startsWith("@")&&(l[0]=l[0].slice(1)),Object.freeze(l)},set(l){V("The parts property on mustache nodes is deprecated, use head and tail instead");let o=[...l];o[0]==="this"||o[0]?.startsWith("@")||(this.head.type==="ThisHead"?o.unshift("this"):this.head.type==="AtHead"&&(o[0]=`@${o[0]}`)),this.original=o.join(".")}}),Object.defineProperty(i,"this",{enumerable:!1,get(){return V("The this property on path nodes is deprecated, use head.type instead"),this.head.type==="ThisHead"}}),Object.defineProperty(i,"data",{enumerable:!1,get(){return V("The data property on path nodes is deprecated, use head.type instead"),this.head.type==="AtHead"}}),i}({head:t,tail:e,loc:r})}head({original:t,loc:e}){return t==="this"?this.this({loc:e}):t[0]==="@"?this.atName({name:t,loc:e}):this.var({name:t,loc:e})}this({loc:t}){return{type:"ThisHead",get original(){return"this"},loc:t}}atName({name:t,loc:e}){let r="";const s={type:"AtHead",get name(){return r},set name(n){k(n[0]==="@","call builders.at() with a string that starts with '@'"),k(n.indexOf(".")===-1,"builder.at() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}var({name:t,loc:e}){let r="";const s={type:"VarHead",get name(){return r},set name(n){k(n!=="this","You called builders.var() with 'this'. Call builders.this instead"),k(n[0]!=="@",`You called builders.var() with '${t}'. Call builders.at('${t}') instead`),k(n.indexOf(".")===-1,"builder.var() should not be called with a name with dots in it"),r=n},get original(){return this.name},set original(n){this.name=n},loc:e};return s.name=t,s}hash({pairs:t,loc:e}){return{type:"Hash",pairs:t,loc:e}}pair({key:t,value:e,loc:r}){return{type:"HashPair",key:t,value:e,loc:r}}literal({type:t,value:e,loc:r}){return function({type:s,value:n,loc:a}){const i={type:s,value:n,loc:a};return Object.defineProperty(i,"original",{enumerable:!1,get(){return V("The original property on literal nodes is deprecated, use value instead"),this.value},set(l){V("The original property on literal nodes is deprecated, use value instead"),this.value=l}}),i}({type:t,value:e,loc:r})}};class on{elementStack=[];lines;source;currentAttribute=null;currentNode=null;tokenizer;constructor(e,r=new gr(Os),s="precompile"){this.source=e,this.lines=e.source.split(/\r\n?|\n/u),this.tokenizer=new Ls(this,r,s)}offset(){let{line:e,column:r}=this.tokenizer;return this.source.offsetFor(e,r)}pos({line:e,column:r}){return this.source.offsetFor(e,r)}finish(e){return W({},e,{loc:e.start.until(this.offset())})}get currentAttr(){return Ne(this.currentAttribute,"expected attribute")}get currentTag(){let e=this.currentNode;return k(e&&(e.type==="StartTag"||e.type==="EndTag"),"expected tag"),e}get currentStartTag(){let e=this.currentNode;return k(e&&e.type==="StartTag","expected start tag"),e}get currentEndTag(){let e=this.currentNode;return k(e&&e.type==="EndTag","expected end tag"),e}get currentComment(){let e=this.currentNode;return k(e&&e.type==="CommentStatement","expected a comment"),e}get currentData(){let e=this.currentNode;return k(e&&e.type==="TextNode","expected a text node"),e}acceptNode(e){return this[e.type](e)}currentElement(){return Ce(ve(this.elementStack))}sourceForNode(e,r){let s,n,a,i=e.loc.start.line-1,l=i-1,o=e.loc.start.column,h=[];for(r?(n=r.loc.end.line-1,a=r.loc.end.column):(n=e.loc.end.line-1,a=e.loc.end.column);l<n;)l++,s=rt(this.lines[l]),l===i?i===n?h.push(s.slice(o,a)):h.push(s.slice(o)):l===n?h.push(s.slice(0,a)):h.push(s);return h.join(`
`)}}const rr="beforeAttributeName";class cn extends on{pendingError=null;parse(e,r){let s=m.template({body:[],blockParams:r,loc:this.source.spanFor(e.loc)}),n=this.parseProgram(s,e);return this.pendingError?.eof(n.loc.getEnd()),n}Program(e,r){k(Array.isArray(r),"[BUG] Program in parser unexpectedly called without block params");let s=m.blockItself({body:[],params:r,chained:e.chained,loc:this.source.spanFor(e.loc)});return this.parseProgram(s,e)}parseProgram(e,r){if(r.body.length===0)return e;let s;try{this.elementStack.push(e);for(let n of r.body)this.acceptNode(n)}finally{s=this.elementStack.pop()}if(e!==s){if(s?.type==="ElementNode")throw u(`Unclosed element \`${s.tag}\``,s.loc);k(s!==void 0,"[BUG] empty parser elementStack"),k(!1,`[BUG] mismatched parser elementStack node: ${e.type}`)}return e}BlockStatement(e){if(this.tokenizer.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));if(this.tokenizer.state!=="data"&&this.tokenizer.state!=="beforeData")throw u("A block may only be used inside an HTML element or another block.",this.source.spanFor(e.loc));const{path:r,params:s,hash:n}=ut(this,e),a=this.source.spanFor(e.loc);let i=[];if(e.program.blockParams?.length){let p=n.loc.collapse("end");p=e.program.loc?p.withEnd(this.source.spanFor(e.program.loc).getStart()):e.program.body[0]?p.withEnd(this.source.spanFor(e.program.body[0].loc).getStart()):p.withEnd(a.getEnd());const f=p.asString();let g=f.indexOf("|")+1;const S=f.indexOf("|",g);for(const P of e.program.blockParams){let G,le;G=g>=S?-1:f.indexOf(P,g),G===-1||G+P.length>S?(g=S,le=this.source.spanFor(be)):(g=G,le=p.sliceStartChars({skipStart:g,chars:P.length}),g+=P.length),i.push(m.var({name:P,loc:le}))}}e.program.loc||(e.program.loc=be),e.inverse&&!e.inverse.loc&&(e.inverse.loc=be);const l=this.Program(e.program,i),o=e.inverse?this.Program(e.inverse,[]):null,h=m.block({path:r,params:s,hash:n,defaultBlock:l,elseBlock:o,loc:this.source.spanFor(e.loc),openStrip:e.openStrip,inverseStrip:e.inverseStrip,closeStrip:e.closeStrip});ke(this.currentElement(),h)}MustacheStatement(e){this.pendingError?.mustache(this.source.spanFor(e.loc));const{tokenizer:r}=this;if(r.state==="comment")return void this.appendToCommentData(this.sourceForNode(e));let s;const{escaped:n,loc:a,strip:i}=e;if("original"in e.path&&e.path.original==="...attributes")throw u("Illegal use of ...attributes",this.source.spanFor(e.loc));if(Nr(e.path))s=m.mustache({path:this.acceptNode(e.path),params:[],hash:m.hash({pairs:[],loc:this.source.spanFor(e.path.loc).collapse("end")}),trusting:!n,loc:this.source.spanFor(a),strip:i});else{const{path:l,params:o,hash:h}=ut(this,e);s=m.mustache({path:l,params:o,hash:h,trusting:!n,loc:this.source.spanFor(a),strip:i})}switch(r.state){case"tagOpen":case"tagName":throw u("Cannot use mustaches in an elements tagname",s.loc);case"beforeAttributeName":ht(this.currentStartTag,s);break;case"attributeName":case"afterAttributeName":this.beginAttributeValue(!1),this.finishAttributeValue(),ht(this.currentStartTag,s),r.transitionTo(rr);break;case"afterAttributeValueQuoted":ht(this.currentStartTag,s),r.transitionTo(rr);break;case"beforeAttributeValue":this.beginAttributeValue(!1),this.appendDynamicAttributeValuePart(s),r.transitionTo("attributeValueUnquoted");break;case"attributeValueDoubleQuoted":case"attributeValueSingleQuoted":case"attributeValueUnquoted":this.appendDynamicAttributeValuePart(s);break;default:ke(this.currentElement(),s)}return s}appendDynamicAttributeValuePart(e){this.finalizeTextPart();const r=this.currentAttr;r.isDynamic=!0,r.parts.push(e)}finalizeTextPart(){const e=this.currentAttr.currentPart;e!==null&&(this.currentAttr.parts.push(e),this.startTextPart())}startTextPart(){this.currentAttr.currentPart=null}ContentStatement(e){(function(r,s){let n=s.loc.start.line,a=s.loc.start.column;const i=function(l,o){if(o==="")return{lines:l.split(`
`).length-1,columns:0};const[h]=l.split(o),p=h.split(/\n/u),f=p.length-1;return{lines:f,columns:rt(p[f]).length}}(s.original,s.value);n+=i.lines,i.lines?a=i.columns:a+=i.columns,r.line=n,r.column=a})(this.tokenizer,e),this.tokenizer.tokenizePart(e.value),this.tokenizer.flushData()}CommentStatement(e){const{tokenizer:r}=this;if(r.state==="comment")return this.appendToCommentData(this.sourceForNode(e)),null;const{value:s,loc:n}=e,a=m.mustacheComment({value:s,loc:this.source.spanFor(n)});switch(r.state){case"beforeAttributeName":case"afterAttributeName":this.currentStartTag.comments.push(a);break;case"beforeData":case"data":ke(this.currentElement(),a);break;default:throw u(`Using a Handlebars comment when in the \`${r.state}\` state is not supported`,this.source.spanFor(e.loc))}return a}PartialStatement(e){throw u("Handlebars partials are not supported",this.source.spanFor(e.loc))}PartialBlockStatement(e){throw u("Handlebars partial blocks are not supported",this.source.spanFor(e.loc))}Decorator(e){throw u("Handlebars decorators are not supported",this.source.spanFor(e.loc))}DecoratorBlock(e){throw u("Handlebars decorator blocks are not supported",this.source.spanFor(e.loc))}SubExpression(e){const{path:r,params:s,hash:n}=ut(this,e);return m.sexpr({path:r,params:s,hash:n,loc:this.source.spanFor(e.loc)})}PathExpression(e){const{original:r}=e;let s;if(r.indexOf("/")!==-1){if(r.slice(0,2)==="./")throw u('Using "./" is not supported in Glimmer and unnecessary',this.source.spanFor(e.loc));if(r.slice(0,3)==="../")throw u('Changing context using "../" is not supported in Glimmer',this.source.spanFor(e.loc));if(r.indexOf(".")!==-1)throw u("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths",this.source.spanFor(e.loc));s=[e.parts.join("/")]}else{if(r===".")throw u("'.' is not a supported path in Glimmer; check for a path with a trailing '.'",this.source.spanFor(e.loc));s=e.parts}let n,a=!1;if(/^this(?:\..+)?$/u.test(r)&&(a=!0),a)n=m.this({loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+4}})});else if(e.data){const i=s.shift();if(i===void 0)throw u("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.",this.source.spanFor(e.loc));n=m.atName({name:`@${i}`,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length+1}})})}else{const i=s.shift();if(i===void 0)throw u("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.",this.source.spanFor(e.loc));n=m.var({name:i,loc:this.source.spanFor({start:e.loc.start,end:{line:e.loc.start.line,column:e.loc.start.column+i.length}})})}return m.path({head:n,tail:s,loc:this.source.spanFor(e.loc)})}Hash(e){const r=e.pairs.map(s=>m.pair({key:s.key,value:this.acceptNode(s.value),loc:this.source.spanFor(s.loc)}));return m.hash({pairs:r,loc:this.source.spanFor(e.loc)})}StringLiteral(e){return m.literal({type:"StringLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}BooleanLiteral(e){return m.literal({type:"BooleanLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}NumberLiteral(e){return m.literal({type:"NumberLiteral",value:e.value,loc:this.source.spanFor(e.loc)})}UndefinedLiteral(e){return m.literal({type:"UndefinedLiteral",value:void 0,loc:this.source.spanFor(e.loc)})}NullLiteral(e){return m.literal({type:"NullLiteral",value:null,loc:this.source.spanFor(e.loc)})}}function ut(t,e){let r;switch(e.path.type){case"PathExpression":r=t.PathExpression(e.path);break;case"SubExpression":r=t.SubExpression(e.path);break;case"StringLiteral":case"UndefinedLiteral":case"NullLiteral":case"NumberLiteral":case"BooleanLiteral":{let a;throw a=e.path.type==="BooleanLiteral"?e.path.original.toString():e.path.type==="StringLiteral"?`"${e.path.original}"`:e.path.type==="NullLiteral"?"null":e.path.type==="NumberLiteral"?e.path.value.toString():"undefined",u(`${e.path.type} "${e.path.type==="StringLiteral"?e.path.original:a}" cannot be called as a sub-expression, replace (${a}) with ${a}`,t.source.spanFor(e.path.loc))}}const s=e.params?e.params.map(a=>t.acceptNode(a)):[],n=T(s)?Ce(s).loc:r.loc;return{path:r,params:s,hash:e.hash?t.Hash(e.hash):m.hash({pairs:[],loc:t.source.spanFor(n).collapse("end")})}}function ht(t,e){const{path:r,params:s,hash:n,loc:a}=e;if(Nr(r)){const l=`{{${function(o){return o.type==="UndefinedLiteral"?"undefined":JSON.stringify(o.value)}(r)}}}`;throw u(`In <${t.name} ... ${l} ..., ${l} is not a valid modifier`,e.loc)}const i=m.elementModifier({path:r,params:s,hash:n,loc:a});t.modifiers.push(i)}function me(t){return/[\t\n\f ]/u.test(t)}class un extends cn{tagOpenLine=0;tagOpenColumn=0;reset(){this.currentNode=null}beginComment(){this.currentNode={type:"CommentStatement",value:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}appendToCommentData(e){this.currentComment.value+=e}finishComment(){ke(this.currentElement(),m.comment(this.finish(this.currentComment)))}beginData(){this.currentNode={type:"TextNode",chars:"",start:this.offset()}}appendToData(e){this.currentData.chars+=e}finishData(){ke(this.currentElement(),m.text(this.finish(this.currentData)))}tagOpen(){this.tagOpenLine=this.tokenizer.line,this.tagOpenColumn=this.tokenizer.column}beginStartTag(){this.currentNode={type:"StartTag",name:"",nameStart:null,nameEnd:null,attributes:[],modifiers:[],comments:[],params:[],selfClosing:!1,start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}beginEndTag(){this.currentNode={type:"EndTag",name:"",start:this.source.offsetFor(this.tagOpenLine,this.tagOpenColumn)}}finishTag(){let e=this.finish(this.currentTag);if(e.type==="StartTag"){if(this.finishStartTag(),e.name===":")throw u("Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter",this.source.spanFor({start:this.currentTag.start.toJSON(),end:this.offset().toJSON()}));(gt.has(e.name)||e.selfClosing)&&this.finishEndTag(!0)}else e.type==="EndTag"&&this.finishEndTag(!1)}finishStartTag(){let{name:e,nameStart:r,nameEnd:s}=this.currentStartTag;k(e!=="","tag name cannot be empty"),k(r!==null,"nameStart unexpectedly null"),k(s!==null,"nameEnd unexpectedly null");let n=r.until(s),[a,...i]=ve(e.split(".")),l=m.path({head:m.head({original:a,loc:n.sliceStartChars({chars:a.length})}),tail:i,loc:n}),{attributes:o,modifiers:h,comments:p,params:f,selfClosing:g,loc:S}=this.finish(this.currentStartTag),P=m.element({path:l,selfClosing:g,attributes:o,modifiers:h,comments:p,params:f,children:[],openTag:S,closeTag:g?null:N.broken(),loc:S});this.elementStack.push(P)}finishEndTag(e){let{start:r}=this.currentTag,s=this.finish(this.currentTag),n=this.elementStack.pop();this.validateEndTag(s,n,e);let a=this.currentElement();e?n.closeTag=null:n.selfClosing?k(n.closeTag===null,"element.closeTag unexpectedly present"):n.closeTag=r.until(this.offset()),n.loc=n.loc.withEnd(this.offset()),ke(a,m.element(n))}markTagAsSelfClosing(){let e=this.currentTag;if(e.type!=="StartTag")throw u("Invalid end tag: closing tag must not be self-closing",this.source.spanFor({start:e.start.toJSON(),end:this.offset().toJSON()}));e.selfClosing=!0}appendToTagName(e){let r=this.currentTag;if(r.name+=e,r.type==="StartTag"){let s=this.offset();r.nameStart===null&&(k(r.nameEnd===null,"nameStart and nameEnd must both be null"),r.nameStart=s.move(-1)),r.nameEnd=s}}beginAttribute(){let e=this.offset();this.currentAttribute={name:"",parts:[],currentPart:null,isQuoted:!1,isDynamic:!1,start:e,valueSpan:e.collapsed()}}appendToAttributeName(e){this.currentAttr.name+=e,this.currentAttr.name==="as"&&this.parsePossibleBlockParams()}beginAttributeValue(e){this.currentAttr.isQuoted=e,this.startTextPart(),this.currentAttr.valueSpan=this.offset().collapsed()}appendToAttributeValue(e){let r=this.currentAttr.parts,s=r[r.length-1],n=this.currentAttr.currentPart;if(n)n.chars+=e,n.loc=n.loc.withEnd(this.offset());else{let a=this.offset();a=e===`
`?s?s.loc.getEnd():this.currentAttr.valueSpan.getStart():a.move(-1),this.currentAttr.currentPart=m.text({chars:e,loc:a.collapsed()})}}finishAttributeValue(){this.finalizeTextPart();let e=this.currentTag,r=this.offset();if(e.type==="EndTag")throw u("Invalid end tag: closing tag must not have attributes",this.source.spanFor({start:e.start.toJSON(),end:r.toJSON()}));let{name:s,parts:n,start:a,isQuoted:i,isDynamic:l,valueSpan:o}=this.currentAttr;if(s.startsWith("|")&&n.length===0&&!i&&!l)throw u("Invalid block parameters syntax: block parameters must be preceded by the `as` keyword",a.until(a.move(s.length)));let h=this.assembleAttributeValue(n,i,l,a.until(r));h.loc=o.withEnd(r);let p=m.attr({name:s,value:h,loc:a.until(r)});this.currentStartTag.attributes.push(p)}parsePossibleBlockParams(){const e=/[!"#%&'()*+./;<=>@[\\\]^`{|}~]/u;k(this.tokenizer.state==="attributeName","must be in TokenizerState.attributeName");const r=this.currentStartTag,s=this.currentAttr;let n={state:"PossibleAs"};const a={PossibleAs:l=>{if(k(n.state==="PossibleAs","bug in block params parser"),me(l))n={state:"BeforeStartPipe"},this.tokenizer.transitionTo("afterAttributeName"),this.tokenizer.consume();else{if(l==="|")throw u('Invalid block parameters syntax: expecting at least one space character between "as" and "|"',s.start.until(this.offset().move(1)));n={state:"Done"}}},BeforeStartPipe:l=>{k(n.state==="BeforeStartPipe","bug in block params parser"),me(l)?this.tokenizer.consume():l==="|"?(n={state:"BeforeBlockParamName"},this.tokenizer.transitionTo("beforeAttributeName"),this.tokenizer.consume()):n={state:"Done"}},BeforeBlockParamName:l=>{if(k(n.state==="BeforeBlockParamName","bug in block params parser"),me(l))this.tokenizer.consume();else if(l==="")n={state:"Done"},this.pendingError={mustache(o){throw u("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw u('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"){if(r.params.length===0)throw u("Invalid block parameters syntax: empty parameters list, expecting at least one identifier",s.start.until(this.offset().move(1)));n={state:"AfterEndPipe"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw u('Invalid block parameters syntax: incomplete parameters list, expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n={state:"BlockParamName",name:l,start:this.offset()},this.tokenizer.consume()}},BlockParamName:l=>{if(k(n.state==="BlockParamName","bug in block params parser"),l==="")n={state:"Done"},this.pendingError={mustache(o){throw u("Invalid block parameters syntax: mustaches cannot be used inside parameters list",o)},eof(o){throw u('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}};else if(l==="|"||me(l)){let o=n.start.until(this.offset());if(n.name==="this"||e.test(n.name))throw u(`Invalid block parameters syntax: invalid identifier name \`${n.name}\``,o);r.params.push(m.var({name:n.name,loc:o})),n=l==="|"?{state:"AfterEndPipe"}:{state:"BeforeBlockParamName"},this.tokenizer.consume()}else{if(l===">"||l==="/")throw u('Invalid block parameters syntax: expecting "|" but the tag was closed prematurely',s.start.until(this.offset().move(1)));n.name+=l,this.tokenizer.consume()}},AfterEndPipe:l=>{k(n.state==="AfterEndPipe","bug in block params parser"),me(l)?this.tokenizer.consume():l===""?(n={state:"Done"},this.pendingError={mustache(o){throw u("Invalid block parameters syntax: modifiers cannot follow parameters list",o)},eof(o){throw u('Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',s.start.until(o))}}):l===">"||l==="/"?n={state:"Done"}:(n={state:"Error",message:'Invalid block parameters syntax: expecting the tag to be closed with ">" or "/>" after parameters list',start:this.offset()},this.tokenizer.consume())},Error:l=>{if(k(n.state==="Error","bug in block params parser"),l===""||l==="/"||l===">"||me(l))throw u(n.message,n.start.until(this.offset()));this.tokenizer.consume()},Done:()=>{k(!1,"This should never be called")}};let i;do i=this.tokenizer.peek(),a[n.state](i);while(n.state!=="Done"&&i!=="");k(n.state==="Done","bug in block params parser")}reportSyntaxError(e){throw u(e,this.offset().collapsed())}assembleConcatenatedValue(e){for(const n of e)if(n.type!=="MustacheStatement"&&n.type!=="TextNode")throw u(`Unsupported node in quoted attribute value: ${n.type}`,n.loc);we(e,"the concatenation parts of an element should not be empty");let r=Et(e),s=Ce(e);return m.concat({parts:e,loc:this.source.spanFor(r.loc).extend(this.source.spanFor(s.loc))})}validateEndTag(e,r,s){if(gt.has(e.name)&&!s)throw u(`<${e.name}> elements do not need end tags. You should remove it`,e.loc);if(r.tag===void 0)throw u(`Closing tag </${e.name}> without an open tag`,e.loc);if(r.tag!==e.name)throw u(`Closing tag </${e.name}> did not match last open tag <${r.tag}> (on line ${r.loc.startPosition.line})`,e.loc)}assembleAttributeValue(e,r,s,n){if(s){if(r)return this.assembleConcatenatedValue(e);{we(e);const[a,i]=e;if(i===void 0||i.type==="TextNode"&&i.chars==="/")return a;throw u("An unquoted attribute value must be a string or a mustache, preceded by whitespace or a '=' character, and followed by whitespace, a '>' character, or '/>'",n)}}return T(e)?e[0]:m.text({chars:"",loc:n})}}const hn={parse:Lr,builders:Tr,print:qs,traverse:Pr,Walker:ln};class pn extends gr{constructor(){super({})}parse(){}}function Lr(t,e={}){let r,s,n,a=e.mode||"precompile";typeof t=="string"?(r=new re(t,e.meta?.moduleName),s=a==="codemod"?Rt(t,e.parseOptions):jt(t,e.parseOptions)):t instanceof re?(r=t,s=a==="codemod"?Rt(t.source,e.parseOptions):jt(t.source,e.parseOptions)):(r=new re("",e.meta?.moduleName),s=t),a==="codemod"&&(n=new pn);let i=N.forCharPositions(r,0,r.source.length);s.loc={source:"(program)",start:i.startPosition,end:i.endPosition};let l=new un(r,n,a).parse(s,e.locals??[]);if(e?.plugins?.ast)for(const o of e.plugins.ast)Pr(l,o(W({},e,{syntax:hn},{plugins:void 0})).visitor);return l}function d(t){if(t!==void 0){const e=t;return{fields:()=>class{type;constructor(r){this.type=e,W(this,r)}}}}return{fields:()=>class{constructor(e){W(this,e)}}}}class Q extends d().fields(){static empty(e){return new Q({loc:e,positional:Ee.empty(e),named:ie.empty(e)})}static named(e){return new Q({loc:e.loc,positional:Ee.empty(e.loc.collapse("end")),named:e})}nth(e){return this.positional.nth(e)}get(e){return this.named.get(e)}isEmpty(){return this.positional.isEmpty()&&this.named.isEmpty()}}class Ee extends d().fields(){static empty(e){return new Ee({loc:e,exprs:[]})}get size(){return this.exprs.length}nth(e){return this.exprs[e]||null}isEmpty(){return this.exprs.length===0}}class ie extends d().fields(){static empty(e){return new ie({loc:e,entries:[]})}get size(){return this.entries.length}get(e){let r=this.entries.filter(s=>s.name.chars===e)[0];return r?r.value:null}isEmpty(){return this.entries.length===0}}class Tt{loc;name;value;constructor(e){this.loc=e.name.loc.extend(e.value.loc),this.name=e.name,this.value=e.value}}class Or extends d("HtmlAttr").fields(){}class Hr extends d("SplatAttr").fields(){}class Ir extends d().fields(){toNamedArgument(){return new Tt({name:this.name,value:this.value})}}class $r extends d("ElementModifier").fields(){}class Dr extends d("GlimmerComment").fields(){}class Mr extends d("HtmlText").fields(){}class Fr extends d("HtmlComment").fields(){}class _r extends d("AppendContent").fields(){get callee(){return this.value.type==="Call"?this.value.callee:this.value}get args(){return this.value.type==="Call"?this.value.args:Q.empty(this.value.loc.collapse("end"))}}class Gr extends d("InvokeBlock").fields(){}class Re extends d("InvokeComponent").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return Q.named(new ie({loc:Y.range(e,this.callee.loc.collapse("end")),entries:e}))}}class Vr extends d("SimpleElement").fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return Q.named(new ie({loc:Y.range(e,this.tag.loc.collapse("end")),entries:e}))}}class zr extends d("Literal").fields(){toSlice(){return new $({loc:this.loc,chars:this.value})}}class Ur extends d("Path").fields(){}class Rr extends d("Keyword").fields(){}class jr extends d("Call").fields(){}class Wr extends d("Interpolate").fields(){}class Kr extends d().fields(){}class Yr extends d().fields(){}class Lt extends d().fields(){get(e){return this.blocks.filter(r=>r.name.chars===e)[0]||null}}class ye extends d().fields(){get args(){let e=this.componentArgs.map(r=>r.toNamedArgument());return Q.named(new ie({loc:Y.range(e,this.name.loc.collapse("end")),entries:e}))}}class Jr extends d("This").fields(){}class qr extends d("Arg").fields(){}class Xr extends d("Local").fields(){}class Qr extends d("Free").fields(){}const F={resolution:()=>c.GetStrictKeyword,serialize:()=>"Strict",isAngleBracket:!1},mn={...F,isAngleBracket:!0};class _{static namespaced(e,r=!1){return new _([e],r)}static append(){return new _([j.Component,j.Helper])}static trustingAppend(){return this.namespaced(j.Helper)}constructor(e,r=!1){this.namespaces=e,this.isAngleBracket=r}resolution(){if(this.namespaces.length!==1)return c.GetFreeAsComponentOrHelperHead;switch(this.namespaces[0]){case j.Helper:return c.GetFreeAsHelperHead;case j.Modifier:return c.GetFreeAsModifierHead;case j.Component:return c.GetFreeAsComponentHead}}serialize(){return this.namespaces.length===1?this.namespaces[0]:"ComponentOrHelper"}}let j=function(t){return t.Helper="Helper",t.Modifier="Modifier",t.Component="Component",t}({});const Ot=j.Helper,Zr=j.Modifier,Ht=j.Component;var ae=Object.freeze({__proto__:null,AppendContent:_r,ArgReference:qr,Args:Q,Block:Yr,COMPONENT_NAMESPACE:Ht,CallExpression:jr,ComponentArg:Ir,ElementModifier:$r,FreeVarNamespace:j,FreeVarReference:Qr,GlimmerComment:Dr,HELPER_NAMESPACE:Ot,HTML_RESOLUTION:mn,HtmlAttr:Or,HtmlComment:Fr,HtmlText:Mr,InterpolateExpression:Wr,InvokeBlock:Gr,InvokeComponent:Re,KeywordExpression:Rr,LiteralExpression:zr,LocalVarReference:Xr,LooseModeResolution:_,MODIFIER_NAMESPACE:Zr,NamedArgument:Tt,NamedArguments:ie,NamedBlock:ye,NamedBlocks:Lt,PathExpression:Ur,PositionalArguments:Ee,STRICT_RESOLUTION:F,SimpleElement:Vr,SplatAttr:Hr,Template:Kr,ThisReference:Jr,isLiteral:function(t,e){return t.type==="Literal"&&(e===void 0||(e==="null"?t.value===null:typeof t.value===e))},isStrictResolution:function(t){return t===F},loadResolution:function(t){return t==="Strict"?F:t==="ComponentOrHelper"?_.append():_.namespaced(t)},node:d});class It{static top(e,r,s){return new dn(e,r,s)}child(e){let r=e.map(s=>this.allocate(s));return new fn(this,e,r)}}class dn extends It{constructor(e,r,s){super(),this.templateLocals=e,this.keywords=r,this.options=s}symbols=[];upvars=[];size=1;named=K();blocks=K();usedTemplateLocals=[];#e=!1;hasLexical(e){return this.options.lexicalScope(e)}hasKeyword(e){return this.keywords.includes(e)}getKeyword(e){return this.allocateFree(e,F)}getUsedTemplateLocals(){return this.usedTemplateLocals}setHasDebugger(){this.#e=!0}get hasEval(){return this.#e}has(e){return this.templateLocals.includes(e)}get(e){let r=this.usedTemplateLocals.indexOf(e);return r!==-1||(r=this.usedTemplateLocals.length,this.usedTemplateLocals.push(e)),[r,!0]}getLocalsMap(){return K()}getDebugInfo(){return Object.values(this.getLocalsMap())}allocateFree(e,r){r.resolution()===c.GetFreeAsComponentHead&&r.isAngleBracket&&(e=this.options.customizeComponentName(e));let s=this.upvars.indexOf(e);return s!==-1||(s=this.upvars.length,this.upvars.push(e)),s}allocateNamed(e){let r=this.named[e];return r||(r=this.named[e]=this.allocate(e)),r}allocateBlock(e){e==="inverse"&&(e="else");let r=this.blocks[e];return r||(r=this.blocks[e]=this.allocate(`&${e}`)),r}allocate(e){return this.symbols.push(e),this.size++}}class fn extends It{constructor(e,r,s){super(),this.parent=e,this.symbols=r,this.slots=s}get locals(){return this.symbols}hasLexical(e){return this.parent.hasLexical(e)}getKeyword(e){return this.parent.getKeyword(e)}hasKeyword(e){return this.parent.hasKeyword(e)}has(e){return this.symbols.indexOf(e)!==-1||this.parent.has(e)}get(e){let r=this.#e(e);return r?[r,!1]:this.parent.get(e)}#e(e){let r=this.symbols.indexOf(e);return r===-1?null:rt(this.slots[r])}getLocalsMap(){let e=this.parent.getLocalsMap();return this.symbols.forEach(r=>e[r]=this.get(r)[0]),e}getDebugInfo(){return Object.values(this.getLocalsMap())}setHasDebugger(){this.parent.setHasDebugger()}allocateFree(e,r){return this.parent.allocateFree(e,r)}allocateNamed(e){return this.parent.allocateNamed(e)}allocateBlock(e){return this.parent.allocateBlock(e)}allocate(e){return this.parent.allocate(e)}}class es{template(e,r,s){return new Kr({table:e,body:r,loc:s})}block(e,r,s){return new Yr({scope:e,body:r,loc:s})}namedBlock(e,r,s){return new ye({name:e,block:r,attrs:[],componentArgs:[],modifiers:[],loc:s})}simpleNamedBlock(e,r,s){return new sr({selfClosing:!1,attrs:[],componentArgs:[],modifiers:[],comments:[]}).named(e,r,s)}slice(e,r){return new $({loc:r,chars:e})}args(e,r,s){return new Q({loc:s,positional:e,named:r})}positional(e,r){return new Ee({loc:r,exprs:e})}namedArgument(e,r){return new Tt({name:e,value:r})}named(e,r){return new ie({loc:r,entries:e})}attr({name:e,value:r,trusting:s},n){return new Or({loc:n,name:e,value:r,trusting:s})}splatAttr(e,r){return new Hr({symbol:e,loc:r})}arg({name:e,value:r,trusting:s},n){return new Ir({name:e,value:r,trusting:s,loc:n})}path(e,r,s){return new Ur({loc:s,ref:e,tail:r})}keyword(e,r,s){return new Rr({loc:s,name:e,symbol:r})}self(e){return new Jr({loc:e})}at(e,r,s){return k(e[0]==="@","call builders.at() with a string that starts with '@'"),new qr({loc:s,name:new $({loc:s,chars:e}),symbol:r})}freeVar({name:e,context:r,symbol:s,loc:n}){return k(e!=="this","You called builders.freeVar() with 'this'. Call builders.this instead"),k(e[0]!=="@",`You called builders.freeVar() with '${e}'. Call builders.at('${e}') instead`),new Qr({name:e,resolution:r,symbol:s,loc:n})}localVar(e,r,s,n){return k(e!=="this","You called builders.var() with 'this'. Call builders.this instead"),k(e[0]!=="@",`You called builders.var() with '${e}'. Call builders.at('${e}') instead`),new Xr({loc:n,name:e,isTemplateLocal:s,symbol:r})}sexp(e,r){return new jr({loc:r,callee:e.callee,args:e.args})}interpolate(e,r){return we(e),new Wr({loc:r,parts:e})}literal(e,r){return new zr({loc:r,value:e})}append({table:e,trusting:r,value:s},n){return new _r({table:e,trusting:r,value:s,loc:n})}modifier({callee:e,args:r},s){return new $r({loc:s,callee:e,args:r})}namedBlocks(e,r){return new Lt({loc:r,blocks:e})}blockStatement({program:e,inverse:r=null,...s},n){let a=e.loc,i=[this.namedBlock($.synthetic("default"),e,e.loc)];return r&&(a=a.extend(r.loc),i.push(this.namedBlock($.synthetic("else"),r,r.loc))),new Gr({loc:n,blocks:this.namedBlocks(i,a),callee:s.callee,args:s.args})}element(e){return new sr(e)}}class sr{builder;constructor(e){this.base=e,this.builder=new es}simple(e,r,s){return new Vr(W({tag:e,body:r,componentArgs:[],loc:s},this.base))}named(e,r,s){return new ye(W({name:e,block:r,componentArgs:[],loc:s},this.base))}selfClosingComponent(e,r){return new Re(W({loc:r,callee:e,blocks:new Lt({blocks:[],loc:r.sliceEndChars({skipEnd:1,chars:1})})},this.base))}componentWithDefaultBlock(e,r,s,n){let a=this.builder.block(s,r,n),i=this.builder.namedBlock($.synthetic("default"),a,n);return new Re(W({loc:n,callee:e,blocks:this.builder.namedBlocks([i],i.loc)},this.base))}componentWithNamedBlocks(e,r,s){return new Re(W({loc:s,callee:e,blocks:this.builder.namedBlocks(r,Y.range(r))},this.base))}}function gn(t){return Fe(t)?_.namespaced(Ot):null}function bn(t){return Fe(t)?_.namespaced(Zr):null}function kn(t){return Fe(t)?_.namespaced(Ht):null}function yn(t){return ts(t)?_.namespaced(Ht,!0):null}function wn(t){return Fe(t)?_.namespaced(Ot):null}function vn(t){let e=Fe(t),r=t.trusting;return e?r?_.trustingAppend():_.append():null}function Fe(t){return ts(t.path)}function ts(t){return t.type==="PathExpression"&&t.head.type==="VarHead"&&t.tail.length===0}function An(t,e={lexicalScope:()=>!1}){let r=Lr(t,e),s={strictMode:!1,...e,locals:r.blockParams,keywords:e.keywords??[]},n=It.top(s.locals,s.keywords,{customizeComponentName:e.customizeComponentName??(o=>o),lexicalScope:e.lexicalScope}),a=new $t(t,s,n),i=new Ie(a);return[new En(a.loc(r.loc),r.body.map(o=>i.normalize(o)),a).assertTemplate(n),n.getUsedTemplateLocals()]}class $t{builder;constructor(e,r,s){this.source=e,this.options=r,this.table=s,this.builder=new es}get strict(){return this.options.strictMode||!1}loc(e){return this.source.spanFor(e)}resolutionFor(e,r){if(this.strict)return{result:F};if(this.isFreeVar(e)){let s=r(e);return s===null?{result:"error",path:rs(e),head:ss(e)}:{result:s}}return{result:F}}isLexicalVar(e){return this.table.hasLexical(e)}isKeyword(e){return this.strict&&!this.table.hasLexical(e)&&this.table.hasKeyword(e)}isFreeVar(e){return e.type==="PathExpression"?e.head.type==="VarHead"&&!this.table.has(e.head.name):e.path.type==="PathExpression"&&this.isFreeVar(e.path)}hasBinding(e){return this.table.has(e)||this.table.hasLexical(e)}child(e){return new $t(this.source,this.options,this.table.child(e))}customizeComponentName(e){return this.options.customizeComponentName?this.options.customizeComponentName(e):e}}class wt{constructor(e){this.block=e}normalize(e,r){switch(e.type){case"NullLiteral":case"BooleanLiteral":case"NumberLiteral":case"StringLiteral":case"UndefinedLiteral":return this.block.builder.literal(e.value,this.block.loc(e.loc));case"PathExpression":return k(r,"[BUG] resolution is required"),this.path(e,r);case"SubExpression":{$e(e.path)&&De(e.path,e.loc);let s=this.block.resolutionFor(e,gn);if(s.result==="error")throw u(`You attempted to invoke a path (\`${s.path}\`) but ${s.head} was not in scope`,e.loc);return this.block.builder.sexp(this.callParts(e,s.result),this.block.loc(e.loc))}}}path(e,r){let s=this.block.loc(e.loc);if(e.head.type==="VarHead"&&e.tail.length===0&&this.block.isKeyword(e.head.name))return this.block.builder.keyword(e.head.name,this.block.table.getKeyword(e.head.name),s);let n=[],a=this.block.loc(e.head.loc);for(let i of e.tail)a=a.sliceStartChars({chars:i.length,skipStart:1}),n.push(new $({loc:a,chars:i}));return this.block.builder.path(this.ref(e.head,r),n,s)}callParts(e,r){let{path:s,params:n,hash:a,loc:i}=e,l=this.normalize(s,r),o=n.map(P=>this.normalize(P,F)),h=Y.range(o,l.loc.collapse("end")),p=this.block.loc(a.loc),f=Y.range([h,p]),g=this.block.builder.positional(n.map(P=>this.normalize(P,F)),h),S=this.block.builder.named(a.pairs.map(P=>this.namedArgument(P)),this.block.loc(a.loc));switch(l.type){case"Literal":throw u(`Invalid invocation of a literal value (\`${l.value}\`)`,i);case"Interpolate":throw u("Invalid invocation of a interpolated string",i)}return{callee:l,args:this.block.builder.args(g,S,f)}}namedArgument(e){let r=this.block.loc(e.loc).sliceStartChars({chars:e.key.length});return this.block.builder.namedArgument(new $({chars:e.key,loc:r}),this.normalize(e.value,F))}ref(e,r){let{block:s}=this,{builder:n,table:a}=s,i=s.loc(e.loc);switch(e.type){case"ThisHead":return n.self(i);case"AtHead":{let l=a.allocateNamed(e.name);return n.at(e.name,l,i)}case"VarHead":if(s.hasBinding(e.name)){let[l,o]=a.get(e.name);return s.builder.localVar(e.name,l,o,i)}{let l=s.strict?F:r,o=s.table.allocateFree(e.name,l);return s.builder.freeVar({name:e.name,context:l,symbol:o,loc:i})}}}}class Ie{constructor(e){this.block=e}normalize(e){switch(e.type){case"BlockStatement":return this.BlockStatement(e);case"ElementNode":return new Sn(this.block).ElementNode(e);case"MustacheStatement":return this.MustacheStatement(e);case"MustacheCommentStatement":return this.MustacheCommentStatement(e);case"CommentStatement":{let r=this.block.loc(e.loc);return new Fr({loc:r,text:r.slice({skipStart:4,skipEnd:3}).toSlice(e.value)})}case"TextNode":return new Mr({loc:this.block.loc(e.loc),chars:e.chars})}}MustacheCommentStatement(e){let r,s=this.block.loc(e.loc);return r=s.asString().slice(0,5)==="{{!--"?s.slice({skipStart:5,skipEnd:4}):s.slice({skipStart:3,skipEnd:2}),new Dr({loc:s,text:r.toSlice(e.value)})}MustacheStatement(e){let r,{path:s,params:n,hash:a,trusting:i}=e,l=this.block.loc(e.loc);if($e(s))n.length===0&&a.pairs.length===0?r=this.expr.normalize(s):De(s,l);else{let o=this.block.resolutionFor(e,vn);if(o.result==="error")throw u(`You attempted to render a path (\`{{${o.path}}}\`), but ${o.head} was not in scope`,l);let h=this.expr.callParts({path:s,params:n,hash:a,loc:l},o.result);r=h.args.isEmpty()?h.callee:this.block.builder.sexp(h,l)}return this.block.builder.append({table:this.block.table,trusting:i,value:r},l)}BlockStatement(e){let{program:r,inverse:s}=e,n=this.block.loc(e.loc);$e(e.path)&&De(e.path,n);let a=this.block.resolutionFor(e,kn);if(a.result==="error")throw u(`You attempted to invoke a path (\`{{#${a.path}}}\`) but ${a.head} was not in scope`,n);let i=this.expr.callParts(e,a.result);return this.block.builder.blockStatement(W({symbols:this.block.table,program:this.Block(r),inverse:s?this.Block(s):null},i),n)}Block({body:e,loc:r,blockParams:s}){let n=this.block.child(s),a=new Ie(n);return new Cn(this.block.loc(r),e.map(i=>a.normalize(i)),this.block).assertBlock(n.table)}get expr(){return new wt(this.block)}}class Sn{constructor(e){this.ctx=e}ElementNode(e){let{tag:r,selfClosing:s,comments:n}=e,a=this.ctx.loc(e.loc),[i,...l]=ve(r.split(".")),o=this.classifyTag(i,l,e.loc),h=e.attributes.filter(H=>H.name[0]!=="@").map(H=>this.attr(H)),p=e.attributes.filter(H=>H.name[0]==="@").map(H=>this.arg(H)),f=e.modifiers.map(H=>this.modifier(H)),g=this.ctx.child(e.blockParams),S=new Ie(g),P=e.children.map(H=>S.normalize(H)),G=this.ctx.builder.element({selfClosing:s,attrs:h,componentArgs:p,modifiers:f,comments:n.map(H=>new Ie(this.ctx).MustacheCommentStatement(H))}),le=new xn(G,a,P,this.ctx),Ut=this.ctx.loc(e.loc).sliceStartChars({chars:r.length,skipStart:1});if(o==="ElementHead")return r[0]===":"?le.assertNamedBlock(Ut.slice({skipStart:1}).toSlice(r.slice(1)),g.table):le.assertElement(Ut.toSlice(r),e.blockParams.length>0);if(e.selfClosing)return G.selfClosingComponent(o,a);{let H=le.assertComponent(r,g.table,e.blockParams.length>0);return G.componentWithNamedBlocks(o,H,a)}}modifier(e){$e(e.path)&&De(e.path,e.loc);let r=this.ctx.resolutionFor(e,bn);if(r.result==="error")throw u(`You attempted to invoke a path (\`{{${r.path}}}\`) as a modifier, but ${r.head} was not in scope`,e.loc);let s=this.expr.callParts(e,r.result);return this.ctx.builder.modifier(s,this.ctx.loc(e.loc))}mustacheAttr(e){let{path:r,params:s,hash:n,loc:a}=e;if($e(r)){if(s.length===0&&n.pairs.length===0)return this.expr.normalize(r);De(r,a)}let i=this.ctx.resolutionFor(e,wn);if(i.result==="error")throw u(`You attempted to render a path (\`{{${i.path}}}\`), but ${i.head} was not in scope`,e.loc);let l=this.ctx.builder.sexp(this.expr.callParts(e,i.result),this.ctx.loc(e.loc));return l.args.isEmpty()?l.callee:l}attrPart(e){switch(e.type){case"MustacheStatement":return{expr:this.mustacheAttr(e),trusting:e.trusting};case"TextNode":return{expr:this.ctx.builder.literal(e.chars,this.ctx.loc(e.loc)),trusting:!0}}}attrValue(e){if(e.type==="ConcatStatement"){let r=e.parts.map(s=>this.attrPart(s).expr);return{expr:this.ctx.builder.interpolate(r,this.ctx.loc(e.loc)),trusting:!1}}return this.attrPart(e)}attr(e){if(k(e.name[0]!=="@","An attr name must not start with `@`"),e.name==="...attributes")return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock("attrs"),this.ctx.loc(e.loc));let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.attr({name:s,value:n.expr,trusting:n.trusting},r)}checkArgCall(e){let{value:r}=e;if(r.type!=="MustacheStatement"||r.params.length!==0||r.hash.pairs.length!==0)return;let{path:s}=r;if(s.type!=="PathExpression"||s.tail.length>0)return;let n=this.ctx.resolutionFor(s,()=>null);if(n.result==="error"&&n.path!=="has-block")throw u(`You attempted to pass a path as argument (\`${e.name}={{${n.path}}}\`) but ${n.head} was not in scope. Try:
* \`${e.name}={{this.${n.path}}}\` if this is meant to be a property lookup, or
* \`${e.name}={{(${n.path})}}\` if this is meant to invoke the resolved helper, or
* \`${e.name}={{helper "${n.path}"}}\` if this is meant to pass the resolved helper by value`,e.loc)}arg(e){k(e.name[0]==="@","An arg name must start with `@`"),this.checkArgCall(e);let r=this.ctx.loc(e.loc),s=r.sliceStartChars({chars:e.name.length}).toSlice(e.name),n=this.attrValue(e.value);return this.ctx.builder.arg({name:s,value:n.expr,trusting:n.trusting},r)}classifyTag(e,r,s){let n=(a=e)[0]===a[0]?.toUpperCase()&&a[0]!==a[0]?.toLowerCase();var a;let i=e[0]==="@"||e==="this"||this.ctx.hasBinding(e);if(this.ctx.strict&&!i){if(n)throw u(`Attempted to invoke a component that was not in scope in a strict mode template, \`<${e}>\`. If you wanted to create an element with that name, convert it to lowercase - \`<${e.toLowerCase()}>\``,s);return"ElementHead"}let l=i||n,o=s.sliceStartChars({skipStart:1,chars:e.length}),h=r.reduce((g,S)=>g+1+S.length,0),p=o.getEnd().move(h),f=o.withEnd(p);if(l){let g=m.path({head:m.head({original:e,loc:o}),tail:r,loc:f}),S=this.ctx.isLexicalVar(e)?{result:F}:this.ctx.resolutionFor(g,yn);if(S.result==="error")throw u(`You attempted to invoke a path (\`<${S.path}>\`) but ${S.head} was not in scope`,s);return new wt(this.ctx).normalize(g,S.result)}if(this.ctx.table.allocateFree(e,F),r.length>0)throw u(`You used ${e}.${r.join(".")} as a tag name, but ${e} is not in scope`,s);return"ElementHead"}get expr(){return new wt(this.ctx)}}class Dt{namedBlocks;hasSemanticContent;nonBlockChildren;constructor(e,r,s){this.loc=e,this.children=r,this.block=s,this.namedBlocks=r.filter(n=>n instanceof ye),this.hasSemanticContent=!!r.filter(n=>{if(n instanceof ye)return!1;switch(n.type){case"GlimmerComment":case"HtmlComment":return!1;case"HtmlText":return!/^\s*$/u.test(n.chars);default:return!0}}).length,this.nonBlockChildren=r.filter(n=>!(n instanceof ye))}}class En extends Dt{assertTemplate(e){if(T(this.namedBlocks))throw u("Unexpected named block at the top-level of a template",this.loc);return this.block.builder.template(e,this.nonBlockChildren,this.block.loc(this.loc))}}class Cn extends Dt{assertBlock(e){if(T(this.namedBlocks))throw u("Unexpected named block nested in a normal block",this.loc);return this.block.builder.block(e,this.nonBlockChildren,this.loc)}}class xn extends Dt{constructor(e,r,s,n){super(r,s,n),this.el=e}assertNamedBlock(e,r){if(this.el.base.selfClosing)throw u(`<:${e.chars}/> is not a valid named block: named blocks cannot be self-closing`,this.loc);if(T(this.namedBlocks))throw u(`Unexpected named block inside <:${e.chars}> named block: named blocks cannot contain nested named blocks`,this.loc);if((s=e.chars)[0]!==s[0]?.toLowerCase()||s[0]===s[0]?.toUpperCase())throw u(`<:${e.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,this.loc);var s;if(this.el.base.attrs.length>0||this.el.base.componentArgs.length>0||this.el.base.modifiers.length>0)throw u(`named block <:${e.chars}> cannot have attributes, arguments, or modifiers`,this.loc);let n=Y.range(this.nonBlockChildren,this.loc);return this.block.builder.namedBlock(e,this.block.builder.block(r,this.nonBlockChildren,n),this.loc)}assertElement(e,r){if(r)throw u(`Unexpected block params in <${e.chars}>: simple elements cannot have block params`,this.loc);if(T(this.namedBlocks)){let s=this.namedBlocks.map(n=>n.name);if(s.length===1)throw u(`Unexpected named block <:foo> inside <${e.chars}> HTML element`,this.loc);{let n=s.map(a=>`<:${a.chars}>`).join(", ");throw u(`Unexpected named blocks inside <${e.chars}> HTML element (${n})`,this.loc)}}return this.el.simple(e,this.nonBlockChildren,this.loc)}assertComponent(e,r,s){if(T(this.namedBlocks)&&this.hasSemanticContent)throw u(`Unexpected content inside <${e}> component invocation: when using named blocks, the tag cannot contain other content`,this.loc);if(T(this.namedBlocks)){if(s)throw u(`Unexpected block params list on <${e}> component invocation: when passing named blocks, the invocation tag cannot take block params`,this.loc);let n=new Set;for(let a of this.namedBlocks){let i=a.name.chars;if(n.has(i))throw u(`Component had two named blocks with the same name, \`<:${i}>\`. Only one block with a given name may be passed`,this.loc);if(i==="inverse"&&n.has("else")||i==="else"&&n.has("inverse"))throw u("Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>",this.loc);n.add(i)}return this.namedBlocks}return[this.block.builder.namedBlock($.synthetic("default"),this.block.builder.block(r,this.nonBlockChildren,this.loc),this.loc)]}}function $e(t){switch(t.type){case"StringLiteral":case"BooleanLiteral":case"NumberLiteral":case"UndefinedLiteral":case"NullLiteral":return!0;default:return!1}}function De(t,e){throw u(`Unexpected literal \`${t.type==="StringLiteral"?JSON.stringify(t.value):String(t.value)}\``,e)}function rs(t){return t.type!=="PathExpression"&&t.path.type==="PathExpression"?rs(t.path):new xt({entityEncoding:"raw"}).print(t)}function ss(t){return t.type==="PathExpression"?t.head.original:t.path.type==="PathExpression"?ss(t.path):new xt({entityEncoding:"raw"}).print(t)}const D={Component:0,Helper:1,Modifier:2};(function(t){return t[t.pc=0]="pc",t[t.ra=1]="ra",t[t.fp=2]="fp",t[t.sp=3]="sp",t})({});(function(t){return t[t.s0=4]="s0",t[t.s1=5]="s1",t})({});(function(t){return t[t.t0=6]="t0",t[t.t1=7]="t1",t})({});let E=function(t){return t.Block="Block",t.Call="Call",t.Element="Element",t.AppendPath="AppendPath",t.AppendExpr="AppendExpr",t.Literal="Literal",t.Modifier="Modifier",t.DynamicComponent="DynamicComponent",t.Comment="Comment",t.Splat="Splat",t.Keyword="Keyword",t}({}),z=function(t){return t.Local="Local",t.Free="Free",t.Arg="Arg",t.Block="Block",t.This="This",t}({});function ns(t){if(Array.isArray(t))return function(e){if(!Array.isArray(e))return!1;const r=e[0];if(typeof r=="number")switch(r){case B.Literal:case B.Get:case B.Concat:case B.HasBlock:case B.HasBlockParams:return!0;default:return!1}return r[0]==="("}(t)?lr(t):function(e){if(Array.isArray(e)&&typeof e[0]=="string")switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(t)?function(e){const r=e[0];switch(r[0]){case"(":{let s=null,n=null;return e.length===3?(s=J(e[1]),n=ge(e[2])):e.length===2&&(Array.isArray(e[1])?s=J(e[1]):n=ge(e[1])),{kind:E.Call,head:Pe(r),params:s,hash:n,trusted:!1}}case"#":{const{head:s,params:n,hash:a,blocks:i,blockParams:l}=nr(e);return{kind:E.Block,head:s,params:n,hash:a,blocks:i,blockParams:l}}case"!":{const s=e[0].slice(1),{params:n,hash:a,blocks:i,blockParams:l}=nr(e);return{kind:E.Keyword,name:s,params:n,hash:a,blocks:i,blockParams:l}}case"<":{let s=K(),n=[];return e.length===3?(s=ir(e[1]),n=Be(e[2])):e.length===2&&(Array.isArray(e[1])?n=Be(e[1]):s=ir(e[1])),{kind:E.Element,name:Ne(Nn(r),`BUG: expected ${r} to look like a tag name`),attrs:s,block:n}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(t):function(e){switch(e[0]){case B.Literal:return{kind:E.Literal,value:e[1]};case B.Append:return lr(e[1],e[2]);case B.Modifier:return{kind:E.Modifier,params:J(e[1]),hash:ge(e[2])};case B.DynamicComponent:return{kind:E.DynamicComponent,expr:Ge(e[1]),hash:ge(e[2]),block:Be(e[3])};case B.Comment:return{kind:E.Comment,value:e[1]}}}(t);if(typeof t=="string")return vt(_e(t),!1);throw q(t)}function vt(t,e){return t.type===C.GetPath?{kind:E.AppendPath,path:t,trusted:e}:{kind:E.AppendExpr,expr:t,trusted:e}}function Pn(t){const e=/^(#|!)(.*)$/u.exec(t);if(e===null)throw new Error("Unexpected missing # in block head");return _e(e[2])}function Pe(t){const e=/^\((.*)\)$/u.exec(t);if(e===null)throw new Error("Unexpected missing () in call head");return _e(e[1])}function as(t,e=[]){const r=is(t);return T(e)?{type:C.GetPath,path:{head:r,tail:e}}:{type:C.GetVar,variable:r}}function _e(t){const{kind:e,name:r}=is(t),[s,...n]=r.split("."),a={kind:e,name:s,mode:"loose"};return T(n)?{type:C.GetPath,path:{head:a,tail:n}}:{type:C.GetVar,variable:a}}function is(t){let e,r;if(/^this(?:\.|$)/u.test(t))return{kind:z.This,name:t,mode:"loose"};switch(t[0]){case"^":e=z.Free,r=t.slice(1);break;case"@":e=z.Arg,r=t.slice(1);break;case"&":e=z.Block,r=t.slice(1);break;default:e=z.Local,r=t}return{kind:e,name:r,mode:"loose"}}function nr(t){const e=t[0];let r=K(),s=null,n=null,a=null;return t.length===2?r=pt(t[1]):t.length===3?(Array.isArray(t[1])?s=J(t[1]):{hash:n,blockParams:a}=ar(t[1]),r=pt(t[2])):t.length===4&&(s=J(t[1]),{hash:n,blockParams:a}=ar(t[2]),r=pt(t[3])),{head:Pn(e),params:s,hash:n,blockParams:a,blocks:r}}function ar(t){if(t===null)return{hash:null,blockParams:null};let e=null,r=null;return function(s,n){Object.keys(s).forEach(a=>{const i=s[a];n(a,i)})}(t,(s,n)=>{s==="as"?r=Array.isArray(n)?n:[n]:(e=e||K(),e[s]=Ge(n))}),{hash:e,blockParams:r}}function pt(t){return Array.isArray(t)?{default:Be(t)}:Mt(t,Be)}function Be(t){return t.map(e=>ns(e))}function ir(t){return Mt(t,e=>{return(r=e,r==="splat"?{expr:E.Splat,trusted:!1}:{expr:Ge(r)}).expr;var r})}function Mt(t,e){const r=K();return Object.keys(t).forEach(s=>{r[s]=e(t[s],s)}),r}function Nn(t){return/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(t)?.[1]??null}let B=function(t){return t[t.Literal=0]="Literal",t[t.Comment=1]="Comment",t[t.Append=2]="Append",t[t.Modifier=3]="Modifier",t[t.DynamicComponent=4]="DynamicComponent",t[t.Get=5]="Get",t[t.Concat=6]="Concat",t[t.HasBlock=7]="HasBlock",t[t.HasBlockParams=8]="HasBlockParams",t}({}),C=function(t){return t.Literal="Literal",t.Call="Call",t.GetPath="GetPath",t.GetVar="GetVar",t.Concat="Concat",t.HasBlock="HasBlock",t.HasBlockParams="HasBlockParams",t}({});function lr(t,e=!1){if(t==null)return{expr:{type:C.Literal,value:t},kind:E.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case B.Literal:return{expr:{type:C.Literal,value:t[1]},kind:E.AppendExpr,trusted:!1};case B.Get:return vt(as(t[1],t[2]),e);case B.Concat:return{expr:{type:C.Concat,params:J(t.slice(1))},kind:E.AppendExpr,trusted:e};case B.HasBlock:return{expr:{type:C.HasBlock,name:t[1]},kind:E.AppendExpr,trusted:e};case B.HasBlockParams:return{expr:{type:C.HasBlockParams,name:t[1]},kind:E.AppendExpr,trusted:e};default:if(ls(t))return{expr:os(t),kind:E.AppendExpr,trusted:e};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw q(t);switch(typeof t){case"string":return vt(_e(t),e);case"boolean":case"number":return{expr:{type:C.Literal,value:t},kind:E.AppendExpr,trusted:!0};default:throw q(t)}}}function Ge(t){if(t==null)return{type:C.Literal,value:t};if(Array.isArray(t))switch(t[0]){case B.Literal:return{type:C.Literal,value:t[1]};case B.Get:return as(t[1],t[2]);case B.Concat:return{type:C.Concat,params:J(t.slice(1))};case B.HasBlock:return{type:C.HasBlock,name:t[1]};case B.HasBlockParams:return{type:C.HasBlockParams,name:t[1]};default:if(ls(t))return os(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if(typeof t=="object")throw q(t);switch(typeof t){case"string":return _e(t);case"boolean":case"number":return{type:C.Literal,value:t};default:throw q(t)}}}function ls(t){return typeof t[0]=="string"&&t[0][0]==="("}function J(t){return t.map(Ge)}function ge(t){return t===null?null:Mt(t,Ge)}function os(t){switch(t.length){case 1:return{type:C.Call,head:Pe(t[0]),params:null,hash:null};case 2:return Array.isArray(t[1])?{type:C.Call,head:Pe(t[0]),params:J(t[1]),hash:null}:{type:C.Call,head:Pe(t[0]),params:null,hash:ge(t[1])};case 3:return{type:C.Call,head:Pe(t[0]),params:J(t[1]),hash:ge(t[2])}}}class cs{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return mt(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return mt(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return mt(this._symbols,e)}child(e){return new Ft(this,e)}}class Ft{locals=K();constructor(e,r){this.parent=e;for(let s of r)this.locals[s]=e.top.symbol(s)}get paramSymbols(){return zs(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new Ft(this,e)}}function mt(t,e){let r=t.indexOf(e);return r===-1&&(r=t.length,t.push(e)),r}function or(t){return new Error(`unimplemented ${t}`)}function Bn(t,e){let r=[];return t.forEach(s=>r.push(...at(ns(s),e))),r}function Tn(t,e){let r=[];return t.forEach(s=>r.push(...at(s,e))),r}function at(t,e=new cs){switch(t.kind){case E.AppendPath:return[[t.trusted?c.TrustingAppend:c.Append,_t(t.path,e)]];case E.AppendExpr:return[[t.trusted?c.TrustingAppend:c.Append,pe(t.expr,t.trusted?"TrustedAppend":"Append",e)]];case E.Call:{let{head:r,params:s,hash:n,trusted:a}=t,i=s?Ke(s,e):null,l=n?St(n,e):null,o=At(r,a?U.ResolveAsHelperHead:U.ResolveAsComponentOrHelperHead,e);return[[a?c.TrustingAppend:c.Append,[c.Call,o,i,l]]]}case E.Literal:return[[c.Append,t.value]];case E.Comment:return[[c.Comment,t.value]];case E.Block:{let r=function(i,l,o){let h=[],p=[];for(const[f,g]of Object.entries(i))if(h.push(f),f==="default"){let S=o.child(l||[]);p.push(Ye(g,S,S.paramSymbols))}else p.push(Ye(g,o,[]));return[h,p]}(t.blocks,t.blockParams,e),s=St(t.hash,e),n=Ke(t.params,e),a=At(t.head,U.ResolveAsComponentHead,e);return[[c.Block,a,n,s,r]]}case E.Keyword:return[$n(t,e)];case E.Element:return function({name:r,attrs:s,block:n},a){let i=[Dn(s)?[c.OpenElementWithSplat,r]:[c.OpenElement,r]];if(s){let{params:l,args:o}=function(h,p){let f=[],g=[],S=[];for(const[P,G]of Object.entries(h))G===E.Splat?f.push([c.AttrSplat,p.block("&attrs")]):P[0]==="@"?(g.push(P),S.push(pe(G,"Strict",p))):f.push(...Fn(P,G,Mn(P),p));return{params:f,args:T(g)&&T(S)?[g,S]:null}}(s,a);i.push(...l),k(o===null,"Can't pass args to a simple element")}if(i.push([c.FlushElement]),Array.isArray(n))n.forEach(l=>i.push(...at(l,a)));else if(n!==null)throw q(n);return i.push([c.CloseElement]),i}(t,e);case E.Modifier:throw or("modifier");case E.DynamicComponent:throw or("dynamic component");default:throw q(t)}}function Ln(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[B.Literal,r]}function On(t,...e){let r=t.reduce((s,n,a)=>s+`${n}${e[a]?String(e[a]):""}`,"");return[B.Comment,r]}function Hn(t){return String.fromCharCode(parseInt(t,16))}const In=`
`;function $n(t,e){let{name:r}=t,s=Ke(t.params,e),n=e.child(t.blockParams||[]),a=Ye(t.blocks.default,n,n.paramSymbols),i=t.blocks.else?Ye(t.blocks.else,e,[]):null;switch(r){case"let":return[c.Let,Ne(s,"let requires params"),a];case"if":return[c.If,Ne(s,"if requires params")[0],a,i];case"each":{let l=t.hash?t.hash.key:null,o=l?pe(l,"Strict",e):null;return[c.Each,Ne(s,"if requires params")[0],o,a,i]}default:throw new Error("unimplemented keyword")}}function Dn(t){return t!==null&&Object.keys(t).some(e=>t[e]===E.Splat)}function Mn(t){if(t==="xmlns")return Wt;let e=/^([^:]*):([^:]*)$/u.exec(t);if(e===null)return null;switch(e[1]){case"xlink":return Is;case"xml":return $s;case"xmlns":return Wt}return null}function Fn(t,e,r,s){if(e.type===C.Literal){let n=e.value;if(n===!1)return[];if(n===!0)return[[c.StaticAttr,t,"",r??void 0]];if(typeof n=="string")return[[c.StaticAttr,t,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[c.DynamicAttr,t,pe(e,"AttrValue",s),r??void 0]]}function cr(t,e){switch(t){case"Append":return e?"AppendBare":"AppendInvoke";case"TrustedAppend":return e?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return e?"AttrValueBare":"AttrValueInvoke";default:return t}}function pe(t,e,r){switch(t.type){case C.GetPath:return _t(t,r);case C.GetVar:return Te(t.variable,cr(e,!0),r);case C.Concat:return[c.Concat,_n(t.params,r)];case C.Call:{let s=Ke(t.params,r),n=St(t.hash,r),a=At(t.head,e==="Strict"?"SubExpression":cr(e,!1),r);return[c.Call,a,s,n]}case C.HasBlock:return[c.HasBlock,Te({kind:z.Block,name:t.name},U.Strict,r)];case C.HasBlockParams:return[c.HasBlockParams,Te({kind:z.Block,name:t.name},U.Strict,r)];case C.Literal:return t.value===void 0?[c.Undefined]:t.value;default:q(t)}}function At(t,e,r){return t.type===C.GetVar?Te(t.variable,e,r):_t(t,r)}function _t(t,e){return Te(t.path.head,U.Strict,e,t.path.tail)}function Te(t,e,r,s){let n,a=c.GetSymbol;return t.kind===z.Free?(a=e==="Strict"?c.GetStrictKeyword:e==="AppendBare"||e==="AppendInvoke"?c.GetFreeAsComponentOrHelperHead:e==="TrustedAppendBare"||e==="TrustedAppendInvoke"||e==="AttrValueBare"||e==="AttrValueInvoke"||e==="SubExpression"?c.GetFreeAsHelperHead:function(i){switch(i){case U.Strict:return c.GetStrictKeyword;case U.ResolveAsComponentOrHelperHead:return c.GetFreeAsComponentOrHelperHead;case U.ResolveAsHelperHead:return c.GetFreeAsHelperHead;case U.ResolveAsModifierHead:return c.GetFreeAsModifierHead;case U.ResolveAsComponentHead:return c.GetFreeAsComponentHead;default:return Le(i)}}(e),n=r.freeVar(t.name)):(a=c.GetSymbol,n=function(i,l,o){switch(i){case z.Arg:return l.arg(o);case z.Block:return l.block(o);case z.Local:return l.local(o);case z.This:return l.this();default:return Le(i)}}(t.kind,r,t.name)),s===void 0||s.length===0?[a,n]:(k(a!==c.GetStrictKeyword,"[BUG] keyword with a path"),[a,n,s])}function Ke(t,e){return t!==null&&T(t)?t.map(r=>pe(r,"Strict",e)):null}function _n(t,e){return t.map(r=>pe(r,"AttrValue",e))}function St(t,e){if(t===null)return null;let r=[[],[]];for(const[s,n]of Object.entries(t))r[0].push(s),r[1].push(pe(n,"Strict",e));return r}function Ye(t,e,r=[]){return[Tn(t,e),r]}class Gn extends d("Template").fields(){}class Vn extends d("InElement").fields(){}class us extends d("Not").fields(){}class ur extends d("If").fields(){}class zn extends d("IfInline").fields(){}class Un extends d("Each").fields(){}class Rn extends d("Let").fields(){}class jn extends d("WithDynamicVars").fields(){}class Wn extends d("GetDynamicVar").fields(){}class Kn extends d("Log").fields(){}class hs extends d("InvokeComponent").fields(){}class Yn extends d("NamedBlocks").fields(){}class Jn extends d("NamedBlock").fields(){}class qn extends d("AppendTrustedHTML").fields(){}class Je extends d("AppendTextNode").fields(){}class Xn extends d("AppendComment").fields(){}class Qn extends d("Component").fields(){}class Zn extends d("StaticAttr").fields(){}class ea extends d("DynamicAttr").fields(){}class ta extends d("SimpleElement").fields(){}class ra extends d("ElementParameters").fields(){}class sa extends d("Yield").fields(){}class na extends d("Debugger").fields(){}class ps extends d("CallExpression").fields(){}class aa extends d("Modifier").fields(){}class ia extends d("InvokeBlock").fields(){}class la extends d("SplatAttr").fields(){}class oa extends d("PathExpression").fields(){}class ca extends d("Missing").fields(){}class ua extends d("InterpolateExpression").fields(){}class ha extends d("HasBlock").fields(){}class pa extends d("HasBlockParams").fields(){}class ma extends d("Curry").fields(){}class da extends d("Positional").fields(){}class ms extends d("NamedArguments").fields(){}class ds extends d("NamedArgument").fields(){}class fa extends d("Args").fields(){}class ga extends d("Tail").fields(){}class Gt{constructor(e){this.list=e}toArray(){return this.list}map(e){let r=br(this.list,e);return new Gt(r)}filter(e){let r=[];for(let s of this.list)e(s)&&r.push(s);return Me(r)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class qe{list=[];map(e){return new qe}filter(e){return new qe}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function Me(t){return T(t)?new Gt(t):new qe}class Vt{static all(...e){let r=[];for(let s of e){if(s.isErr)return s.cast();r.push(s.value)}return b(r)}}const O=Vt;class ba extends Vt{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return b(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class fs extends Vt{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return y(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function b(t){return new ba(t)}function y(t){return new fs(t)}class he{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter(r=>r instanceof fs)[0];return e!==void 0?e.cast():b(this.items.map(r=>r.value))}toOptionalList(){return this.toArray().mapOk(e=>Me(e))}}function Xe(t){return t.type==="Path"&&t.ref.type==="Free"&&t.ref.name in je?new ae.CallExpression({callee:t,args:ae.Args.empty(t.loc),loc:t.loc}):t}const A=new class{visit(t,e){switch(t.type){case"Literal":return b(this.Literal(t));case"Keyword":return b(this.Keyword(t));case"Interpolate":return this.Interpolate(t,e);case"Path":return this.PathExpression(t);case"Call":{let r=Ta.translate(t,e);return r!==null?r:this.CallExpression(t,e)}}}visitList(t,e){return new he(t.map(r=>A.visit(r,e))).toOptionalList()}PathExpression(t){let e=this.VariableReference(t.ref),{tail:r}=t;if(T(r)){let s=r[0].loc.extend(Ce(r).loc);return b(new oa({loc:t.loc,head:e,tail:new ga({loc:s,members:r})}))}return b(e)}VariableReference(t){return t}Literal(t){return t}Keyword(t){return t}Interpolate(t,e){let r=t.parts.map(Xe);return A.visitList(r,e).mapOk(s=>new ua({loc:t.loc,parts:s}))}CallExpression(t,e){if(t.callee.type==="Call")throw new Error("unimplemented: subexpression at the head of a subexpression");return O.all(A.visit(t.callee,e),A.Args(t.args,e)).mapOk(([r,s])=>new ps({loc:t.loc,callee:r,args:s}))}Args({positional:t,named:e,loc:r},s){return O.all(this.Positional(t,s),this.NamedArguments(e,s)).mapOk(([n,a])=>new fa({loc:r,positional:n,named:a}))}Positional(t,e){return A.visitList(t.exprs,e).mapOk(r=>new da({loc:t.loc,list:r}))}NamedArguments(t,e){let r=t.entries.map(s=>{let n=Xe(s.value);return A.visit(n,e).mapOk(a=>new ds({loc:s.loc,key:s.name,value:a}))});return new he(r).toOptionalList().mapOk(s=>new ms({loc:t.loc,entries:s}))}};class ka{types;constructor(e,r,s){this.keyword=e,this.delegate=s;let n=new Set;for(let a of ya[r])n.add(a);this.types=n}match(e){if(!this.types.has(e.type))return!1;let r=Qe(e);return r!==null&&r.type==="Path"&&r.ref.type==="Free"&&r.ref.name===this.keyword}translate(e,r){if(this.match(e)){let s=Qe(e);return s!==null&&s.type==="Path"&&s.tail.length>0?y(u(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${s.loc.asString()}\`, but it cannot be used with additional path segments. 

Error caused by`,e.loc)):this.delegate.assert(e,r).andThen(n=>this.delegate.translate({node:e,state:r},n))}return null}}const ya={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function Qe(t){switch(t.type){case"Path":return t;case"AppendContent":return Qe(t.value);case"Call":case"InvokeBlock":case"ElementModifier":return t.callee;default:return null}}class wa{_keywords=[];_type;constructor(e){this._type=e}kw(e,r){return this._keywords.push(function(s,n,a){return new ka(s,n,a)}(e,this._type,r)),this}translate(e,r){for(let n of this._keywords){let a=n.translate(e,r);if(a!==null)return a}let s=Qe(e);if(s&&s.type==="Path"&&s.ref.type==="Free"&&Xs(s.ref.name)){let{name:n}=s.ref,a=this._type,i=je[n];if(!i.includes(a))return y(u(`The \`${n}\` keyword was used incorrectly. It was used as ${va[a]}, but its valid usages are:

${function(l,o){return o.map(h=>{switch(h){case"Append":return`- As an append statement, as in: {{${l}}}`;case"Block":return`- As a block statement, as in: {{#${l}}}{{/${l}}}`;case"Call":return`- As an expression, as in: (${l})`;case"Modifier":return`- As a modifier, as in: <div {{${l}}}></div>`;default:return Le(h)}}).join(`

`)}(n,i)}

Error caused by`,e.loc))}return null}}const va={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function it(t){return new wa(t)}function de({assert:t,translate:e}){return{assert:t,translate:({node:r,state:s},n)=>e({node:r,state:s},n).mapOk(a=>new Je({text:a,loc:r.loc}))}}const Aa={[D.Component]:"component",[D.Helper]:"helper",[D.Modifier]:"modifier"};function Ze(t){return(e,r)=>{let s=Aa[t],n=t===D.Component,{args:a}=e,i=a.nth(0);if(i===null)return y(u(`(${s}) requires a ${s} definition or identifier as its first positional parameter, did not receive any parameters.`,a.loc));if(i.type==="Literal"){if(n&&r.isStrict)return y(u(`(${s}) cannot resolve string values in strict mode templates`,e.loc));if(!n)return y(u(`(${s}) cannot resolve string values, you must pass a ${s} definition directly`,e.loc))}return a=new ae.Args({positional:new ae.PositionalArguments({exprs:a.positional.exprs.slice(1),loc:a.positional.loc}),named:a.named,loc:a.loc}),b({definition:i,args:a})}}function Sa(t){return({node:e,state:r},{definition:s,args:n})=>{let a=A.visit(s,r),i=A.Args(n,r);return O.all(a,i).mapOk(([l,o])=>new ma({loc:e.loc,curriedType:t,definition:l,args:o}))}}function dt(t){return{assert:Ze(t),translate:Sa(t)}}const gs={assert:function(t){let e=t.type==="AppendContent"?t.value:t,r=e.type==="Call"?e.args.named:null,s=e.type==="Call"?e.args.positional:null;if(r&&!r.isEmpty())return y(u("(-get-dynamic-vars) does not take any named arguments",t.loc));let n=s?.nth(0);return n?s&&s.size>1?y(u("(-get-dynamic-vars) only receives one positional arg",t.loc)):b(n):y(u("(-get-dynamic-vars) requires a var name to get",t.loc))},translate:function({node:t,state:e},r){return A.visit(r,e).mapOk(s=>new Wn({name:s,loc:t.loc}))}};function Ea(t){return e=>{let r=e.type==="AppendContent"?e.value:e,s=r.type==="Call"?r.args.named:null,n=r.type==="Call"?r.args.positional:null;if(s&&!s.isEmpty())return y(u(`(${t}) does not take any named arguments`,r.loc));if(!n||n.isEmpty())return b($.synthetic("default"));if(n.exprs.length===1){let a=n.exprs[0];return ae.isLiteral(a,"string")?b(a.toSlice()):y(u(`(${t}) can only receive a string literal as its first argument`,r.loc))}return y(u(`(${t}) only takes a single positional argument`,r.loc))}}function Ca(t){return({node:e,state:{scope:r}},s)=>b(t==="has-block"?new ha({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}):new pa({loc:e.loc,target:s,symbol:r.allocateBlock(s.chars)}))}function et(t){return{assert:Ea(t),translate:Ca(t)}}function xa(t){return e=>{let r=t==="unless",s=e.type==="AppendContent"?e.value:e,n=s.type==="Call"?s.args.named:null,a=s.type==="Call"?s.args.positional:null;if(n&&!n.isEmpty())return y(u(`(${t}) cannot receive named parameters, received ${n.entries.map(h=>h.name.chars).join(", ")}`,e.loc));let i=a?.nth(0);if(!a||!i)return y(u(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,e.loc));let l=a.nth(1),o=a.nth(2);return l===null?y(u(`When used inline, (${t}) requires at least two parameters 1. the condition that determines the state of the (${t}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,e.loc)):a.size>3?y(u(`When used inline, (${t}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${t}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${a?.size??0} parameters`,e.loc)):b({condition:i,truthy:l,falsy:o})}}function Pa(t){let e=t==="unless";return({node:r,state:s},{condition:n,truthy:a,falsy:i})=>{let l=A.visit(n,s),o=A.visit(a,s),h=i?A.visit(i,s):b(null);return O.all(l,o,h).mapOk(([p,f,g])=>(e&&(p=new us({value:p,loc:r.loc})),new zn({loc:r.loc,condition:p,truthy:f,falsy:g})))}}function tt(t){return{assert:xa(t),translate:Pa(t)}}const bs={assert:function(t){let{args:{named:e,positional:r}}=t;return e&&!e.isEmpty()?y(u("(log) does not take any named arguments",t.loc)):b(r)},translate:function({node:t,state:e},r){return A.Positional(r,e).mapOk(s=>new Kn({positional:s,loc:t.loc}))}},Na=it("Append").kw("has-block",de(et("has-block"))).kw("has-block-params",de(et("has-block-params"))).kw("-get-dynamic-var",de(gs)).kw("log",de(bs)).kw("if",de(tt("if"))).kw("unless",de(tt("unless"))).kw("yield",{assert(t){let{args:e}=t;if(e.named.isEmpty())return b({target:We.SourceSpan.synthetic("default").toSlice(),positional:e.positional});{let r=e.named.get("to");return e.named.size>1||r===null?y(u("yield only takes a single named argument: 'to'",e.named.loc)):ae.isLiteral(r,"string")?b({target:r.toSlice(),positional:e.positional}):y(u("you can only yield to a literal string value",r.loc))}},translate:({node:t,state:e},{target:r,positional:s})=>A.Positional(s,e).mapOk(n=>new sa({loc:t.loc,target:r,to:e.scope.allocateBlock(r.chars),positional:n}))}).kw("debugger",{assert(t){let{args:e}=t,{positional:r}=e;return e.isEmpty()?b(void 0):r.isEmpty()?y(u("debugger does not take any named arguments",t.loc)):y(u("debugger does not take any positional arguments",t.loc))},translate:({node:t,state:{scope:e}})=>(e.setHasDebugger(),b(new na({loc:t.loc,scope:e})))}).kw("component",{assert:Ze(D.Component),translate({node:t,state:e},{definition:r,args:s}){let n=A.visit(r,e),a=A.Args(s,e);return O.all(n,a).mapOk(([i,l])=>new hs({loc:t.loc,definition:i,args:l,blocks:null}))}}).kw("helper",{assert:Ze(D.Helper),translate({node:t,state:e},{definition:r,args:s}){let n=A.visit(r,e),a=A.Args(s,e);return O.all(n,a).mapOk(([i,l])=>{let o=new ps({callee:i,args:l,loc:t.loc});return new Je({loc:t.loc,text:o})})}}),Ba=it("Block").kw("in-element",{assert(t){let{args:e}=t,r=e.get("guid");if(r)return y(u("Cannot pass `guid` to `{{#in-element}}`",r.loc));let s=e.get("insertBefore"),n=e.nth(0);return n===null?y(u("{{#in-element}} requires a target element as its first positional parameter",e.loc)):b({insertBefore:s,destination:n})},translate({node:t,state:e},{insertBefore:r,destination:s}){let n=t.blocks.get("default"),a=I.NamedBlock(n,e),i=A.visit(s,e);return O.all(a,i).andThen(([l,o])=>r?A.visit(r,e).mapOk(h=>({body:l,destination:o,insertBefore:h})):b({body:l,destination:o,insertBefore:new ca({loc:t.callee.loc.collapse("end")})})).mapOk(({body:l,destination:o,insertBefore:h})=>new Vn({loc:t.loc,block:l,insertBefore:h,guid:e.generateUniqueCursor(),destination:o}))}}).kw("if",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return y(u(`{{#if}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return y(u(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?y(u("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):b({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=A.visit(r,e),i=I.NamedBlock(s,e),l=n?I.NamedBlock(n,e):b(null);return O.all(a,i,l).mapOk(([o,h,p])=>new ur({loc:t.loc,condition:o,block:h,inverse:p}))}}).kw("unless",{assert(t){let{args:e}=t;if(!e.named.isEmpty())return y(u(`{{#unless}} cannot receive named parameters, received ${e.named.entries.map(s=>s.name.chars).join(", ")}`,t.loc));if(e.positional.size>1)return y(u(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${e.positional.size} parameters`,t.loc));let r=e.nth(0);return r===null?y(u("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",t.loc)):b({condition:r})},translate({node:t,state:e},{condition:r}){let s=t.blocks.get("default"),n=t.blocks.get("else"),a=A.visit(r,e),i=I.NamedBlock(s,e),l=n?I.NamedBlock(n,e):b(null);return O.all(a,i,l).mapOk(([o,h,p])=>new ur({loc:t.loc,condition:new us({value:o,loc:t.loc}),block:h,inverse:p}))}}).kw("each",{assert(t){let{args:e}=t;if(!e.named.entries.every(n=>n.name.chars==="key"))return y(u(`{{#each}} can only receive the 'key' named parameter, received ${e.named.entries.filter(n=>n.name.chars!=="key").map(n=>n.name.chars).join(", ")}`,e.named.loc));if(e.positional.size>1)return y(u(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${e.positional.size} parameters`,e.positional.loc));let r=e.nth(0),s=e.get("key");return r===null?y(u("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",e.loc)):b({value:r,key:s})},translate({node:t,state:e},{value:r,key:s}){let n=t.blocks.get("default"),a=t.blocks.get("else"),i=A.visit(r,e),l=s?A.visit(s,e):b(null),o=I.NamedBlock(n,e),h=a?I.NamedBlock(a,e):b(null);return O.all(i,l,o,h).mapOk(([p,f,g,S])=>new Un({loc:t.loc,value:p,key:f,block:g,inverse:S}))}}).kw("let",{assert(t){let{args:e}=t;return e.named.isEmpty()?e.positional.size===0?y(u("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",e.positional.loc)):t.blocks.get("else")?y(u("{{#let}} cannot receive an {{else}} block",e.positional.loc)):b({positional:e.positional}):y(u(`{{#let}} cannot receive named parameters, received ${e.named.entries.map(r=>r.name.chars).join(", ")}`,e.named.loc))},translate({node:t,state:e},{positional:r}){let s=t.blocks.get("default"),n=A.Positional(r,e),a=I.NamedBlock(s,e);return O.all(n,a).mapOk(([i,l])=>new Rn({loc:t.loc,positional:i,block:l}))}}).kw("-with-dynamic-vars",{assert:t=>b({named:t.args.named}),translate({node:t,state:e},{named:r}){let s=t.blocks.get("default"),n=A.NamedArguments(r,e),a=I.NamedBlock(s,e);return O.all(n,a).mapOk(([i,l])=>new jn({loc:t.loc,named:i,block:l}))}}).kw("component",{assert:Ze(D.Component),translate({node:t,state:e},{definition:r,args:s}){let n=A.visit(r,e),a=A.Args(s,e),i=I.NamedBlocks(t.blocks,e);return O.all(n,a,i).mapOk(([l,o,h])=>new hs({loc:t.loc,definition:l,args:o,blocks:h}))}}),Ta=it("Call").kw("has-block",et("has-block")).kw("has-block-params",et("has-block-params")).kw("-get-dynamic-var",gs).kw("log",bs).kw("if",tt("if")).kw("unless",tt("unless")).kw("component",dt(D.Component)).kw("helper",dt(D.Helper)).kw("modifier",dt(D.Modifier)),La=it("Modifier"),ce="http://www.w3.org/1999/xlink",ft="http://www.w3.org/XML/1998/namespace",hr="http://www.w3.org/2000/xmlns/",Oa={"xlink:actuate":ce,"xlink:arcrole":ce,"xlink:href":ce,"xlink:role":ce,"xlink:show":ce,"xlink:title":ce,"xlink:type":ce,"xml:base":ft,"xml:lang":ft,"xml:space":ft,xmlns:hr,"xmlns:xlink":hr},Ha={div:Ve.div,span:Ve.span,p:Ve.p,a:Ve.a},Ia=["div","span","p","a"];function pr(t){return typeof t=="string"?t:Ia[t]}const $a={class:oe.class,id:oe.id,value:oe.value,name:oe.name,type:oe.type,style:oe.style,href:oe.href},Da=["class","id","value","name","type","style","href"];function ks(t){return $a[t]??t}function fe(t){return typeof t=="string"?t:Da[t]}class mr{delegate;constructor(e,r,s){this.element=e,this.state=s,this.delegate=r}toStatement(){return this.prepare().andThen(e=>this.delegate.toStatement(this,e))}attr(e){let r=e.name,s=e.value,n=(a=r.chars,Oa[a]||void 0);var a;return ae.isLiteral(s,"string")?b(new Zn({loc:e.loc,name:r,value:s.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):A.visit(Xe(s),this.state).mapOk(i=>{let l=e.trusting;return new ea({loc:e.loc,name:r,value:i,namespace:n,kind:{trusting:l,component:this.delegate.dynamicFeatures}})})}modifier(e){let r=La.translate(e,this.state);if(r!==null)return r;let s=A.visit(e.callee,this.state),n=A.Args(e.args,this.state);return O.all(s,n).mapOk(([a,i])=>new aa({loc:e.loc,callee:a,args:i}))}attrs(){let e=new he,r=new he,s=null,n=this.element.attrs.filter(a=>a.type==="SplatAttr").length===0;for(let a of this.element.attrs)a.type==="SplatAttr"?e.add(b(new la({loc:a.loc,symbol:this.state.scope.allocateBlock("attrs")}))):a.name.chars==="type"&&n?s=a:e.add(this.attr(a));for(let a of this.element.componentArgs)r.add(this.delegate.arg(a,this));return s&&e.add(this.attr(s)),O.all(r.toArray(),e.toArray()).mapOk(([a,i])=>({attrs:i,args:new ms({loc:yt(a,We.SourceSpan.NON_EXISTENT),entries:Me(a)})}))}prepare(){let e=this.attrs(),r=new he(this.element.modifiers.map(s=>this.modifier(s))).toArray();return O.all(e,r).mapOk(([s,n])=>{let{attrs:a,args:i}=s,l=[...a,...n];return{args:i,params:new ra({loc:yt(l,We.SourceSpan.NON_EXISTENT),body:Me(l)})}})}}class Ma{dynamicFeatures=!0;constructor(e,r){this.tag=e,this.element=r}arg(e,{state:r}){let s=e.name;return A.visit(Xe(e.value),r).mapOk(n=>new ds({loc:e.loc,key:s,value:n}))}toStatement(e,{args:r,params:s}){let{element:n,state:a}=e;return this.blocks(a).mapOk(i=>new Qn({loc:n.loc,tag:this.tag,params:s,args:r,blocks:i}))}blocks(e){return I.NamedBlocks(this.element.blocks,e)}}class Fa{constructor(e,r,s){this.tag=e,this.element=r,this.dynamicFeatures=s}isComponent=!1;arg(e){return y(u(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:r}){let{state:s,element:n}=e;return I.visitList(this.element.body,s).mapOk(a=>new ta({loc:n.loc,tag:this.tag,params:r,body:a.toArray(),dynamicFeatures:this.dynamicFeatures}))}}const I=new class{visitList(t,e){return new he(t.map(r=>I.visit(r,e))).toOptionalList().mapOk(r=>r.filter(s=>s!==null))}visit(t,e){switch(t.type){case"GlimmerComment":return b(null);case"AppendContent":return this.AppendContent(t,e);case"HtmlText":return b(this.TextNode(t));case"HtmlComment":return b(this.HtmlComment(t));case"InvokeBlock":return this.InvokeBlock(t,e);case"InvokeComponent":return this.Component(t,e);case"SimpleElement":return this.SimpleElement(t,e)}}InvokeBlock(t,e){let r=Ba.translate(t,e);if(r!==null)return r;let s=A.visit(t.callee,e),n=A.Args(t.args,e);return O.all(s,n).andThen(([a,i])=>this.NamedBlocks(t.blocks,e).mapOk(l=>new ia({loc:t.loc,head:a,args:i,blocks:l})))}NamedBlocks(t,e){return new he(t.blocks.map(r=>this.NamedBlock(r,e))).toArray().mapOk(r=>new Yn({loc:t.loc,blocks:Me(r)}))}NamedBlock(t,e){return e.visitBlock(t.block).mapOk(r=>new Jn({loc:t.loc,name:t.name,body:r.toArray(),scope:t.block.scope}))}SimpleElement(t,e){return new mr(t,new Fa(t.tag,t,function({attrs:r,modifiers:s}){return s.length>0||!!r.filter(n=>n.type==="SplatAttr")[0]}(t)),e).toStatement()}Component(t,e){return A.visit(t.callee,e).andThen(r=>new mr(t,new Ma(r,t),e).toStatement())}AppendContent(t,e){let r=Na.translate(t,e);return r!==null?r:A.visit(t.value,e).mapOk(s=>t.trusting?new qn({loc:t.loc,html:s}):new Je({loc:t.loc,text:s}))}TextNode(t){return new Je({loc:t.loc,text:new ae.LiteralExpression({loc:t.loc,value:t.chars})})}HtmlComment(t){return new Xn({loc:t.loc,value:t.text})}};class _a{_currentScope;_cursorCount=0;constructor(e,r){this.isStrict=r,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let r=this._currentScope;this._currentScope=e.scope;try{return I.visitList(e.body,this)}finally{this._currentScope=r}}}var M=function(t){return t.Value="value",t.Component="component",t.Helper="helper",t.Modifier="modifier",t.ComponentOrHelper="component or helper",t}(M||{});class Ga{static validate(e){return new this(e).validate()}constructor(e){this.template=e}validate(){return this.Statements(this.template.body).mapOk(()=>this.template)}Statements(e){let r=b(null);for(let s of e)r=r.andThen(()=>this.Statement(s));return r}NamedBlocks({blocks:e}){let r=b(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedBlock(s));return r}NamedBlock(e){return this.Statements(e.body)}Statement(e){switch(e.type){case"InElement":return this.InElement(e);case"Debugger":case"AppendComment":return b(null);case"Yield":return this.Yield(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"AppendTextNode":return this.AppendTextNode(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e)}}Expressions(e){let r=b(null);for(let s of e)r=r.andThen(()=>this.Expression(s));return r}Expression(e,r=e,s){switch(e.type){case"Literal":case"Keyword":case"Missing":case"This":case"Arg":case"Local":case"HasBlock":case"HasBlockParams":case"GetDynamicVar":return b(null);case"PathExpression":return this.Expression(e.head,r,s);case"Free":return this.errorFor(e.name,r,s);case"InterpolateExpression":return this.InterpolateExpression(e,r,s);case"CallExpression":return this.CallExpression(e,r,s??M.Helper);case"Not":return this.Expression(e.value,r,s);case"IfInline":return this.IfInline(e);case"Curry":return this.Curry(e);case"Log":return this.Log(e)}}Args(e){return this.Positional(e.positional).andThen(()=>this.NamedArguments(e.named))}Positional(e,r){let s=b(null),n=e.list.toArray();return s=n.length===1?this.Expression(n[0],r):this.Expressions(n),s}NamedArguments({entries:e}){let r=b(null);for(let s of e.toArray())r=r.andThen(()=>this.NamedArgument(s));return r}NamedArgument(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,M.Helper):this.Expression(e.value,e)}ElementParameters({body:e}){let r=b(null);for(let s of e.toArray())r=r.andThen(()=>this.ElementParameter(s));return r}ElementParameter(e){switch(e.type){case"StaticAttr":case"SplatAttr":return b(null);case"DynamicAttr":return this.DynamicAttr(e);case"Modifier":return this.Modifier(e)}}DynamicAttr(e){return e.value.type==="CallExpression"?this.Expression(e.value,e,M.Helper):this.Expression(e.value,e)}Modifier(e){return this.Expression(e.callee,e,M.Modifier).andThen(()=>this.Args(e.args))}InElement(e){return this.Expression(e.destination).andThen(()=>this.Expression(e.insertBefore)).andThen(()=>this.NamedBlock(e.block))}Yield(e){return this.Positional(e.positional,e)}AppendTrustedHTML(e){return this.Expression(e.html,e)}AppendTextNode(e){return e.text.type==="CallExpression"?this.Expression(e.text,e,M.ComponentOrHelper):this.Expression(e.text,e)}Component(e){return this.Expression(e.tag,e,M.Component).andThen(()=>this.ElementParameters(e.params)).andThen(()=>this.NamedArguments(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}SimpleElement(e){return this.ElementParameters(e.params).andThen(()=>this.Statements(e.body))}InvokeBlock(e){return this.Expression(e.head,e.head,M.Component).andThen(()=>this.Args(e.args)).andThen(()=>this.NamedBlocks(e.blocks))}If(e){return this.Expression(e.condition,e).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):b(null))}Each(e){return this.Expression(e.value,e).andThen(()=>e.key?this.Expression(e.key,e):b(null)).andThen(()=>this.NamedBlock(e.block)).andThen(()=>e.inverse?this.NamedBlock(e.inverse):b(null))}Let(e){return this.Positional(e.positional).andThen(()=>this.NamedBlock(e.block))}WithDynamicVars(e){return this.NamedArguments(e.named).andThen(()=>this.NamedBlock(e.block))}InvokeComponent(e){return this.Expression(e.definition,e,M.Component).andThen(()=>this.Args(e.args)).andThen(()=>e.blocks?this.NamedBlocks(e.blocks):b(null))}InterpolateExpression(e,r,s){let n=e.parts.toArray();return n.length===1?this.Expression(n[0],r,s):this.Expressions(n)}CallExpression(e,r,s){return this.Expression(e.callee,r,s).andThen(()=>this.Args(e.args))}IfInline(e){return this.Expression(e.condition).andThen(()=>this.Expression(e.truthy)).andThen(()=>e.falsy?this.Expression(e.falsy):b(null))}Curry(e){let r;return r=e.curriedType===D.Component?M.Component:e.curriedType===D.Helper?M.Helper:M.Modifier,this.Expression(e.definition,e,r).andThen(()=>this.Args(e.args))}Log(e){return this.Positional(e.positional,e)}errorFor(e,r,s=M.Value){return y(u(`Attempted to resolve a ${s} in a strict mode template, but that value was not in scope: ${e}`,Se(r)))}}class Va{upvars;symbols;constructor([e,r,s,n]){this.upvars=n,this.symbols=r}format(e){let r=[];for(let s of e[0])r.push(this.formatOpcode(s));return r}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case c.Append:return["append",this.formatOpcode(e[1])];case c.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case c.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case c.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case c.OpenElement:return["open-element",pr(e[1])];case c.OpenElementWithSplat:return["open-element-with-splat",pr(e[1])];case c.CloseElement:return["close-element"];case c.FlushElement:return["flush-element"];case c.StaticAttr:return["static-attr",fe(e[1]),e[2],e[3]];case c.StaticComponentAttr:return["static-component-attr",fe(e[1]),e[2],e[3]];case c.DynamicAttr:return["dynamic-attr",fe(e[1]),this.formatOpcode(e[2]),e[3]];case c.ComponentAttr:return["component-attr",fe(e[1]),this.formatOpcode(e[2]),e[3]];case c.AttrSplat:return["attr-splat"];case c.Yield:return["yield",e[1],this.formatParams(e[2])];case c.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case c.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case c.TrustingDynamicAttr:return["trusting-dynamic-attr",fe(e[1]),this.formatOpcode(e[2]),e[3]];case c.TrustingComponentAttr:return["trusting-component-attr",fe(e[1]),this.formatOpcode(e[2]),e[3]];case c.Debugger:return["debugger",e[1]];case c.Comment:return["comment",e[1]];case c.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case c.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case c.HasBlock:return["has-block",this.formatOpcode(e[1])];case c.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case c.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case c.Undefined:return["undefined"];case c.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case c.Concat:return["concat",this.formatParams(e[1])];case c.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]]];case c.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case c.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case c.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case c.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case c.GetSymbol:return e[1]===0?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case c.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case c.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case c.IfInline:return["if-inline"];case c.Not:return["not"];case c.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case c.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case c.Log:return["log",this.formatParams(e[1])];case c.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case c.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case c.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case D.Component:return"component";case D.Helper:return"helper";case D.Modifier:return"modifier";default:throw Le(e)}}formatElementParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatParams(e){return e===null?null:e.map(r=>this.formatOpcode(r))}formatHash(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatOpcode(e[1][n]),r),K())}formatBlocks(e){return e===null?null:e[0].reduce((r,s,n)=>(r[s]=this.formatBlock(e[1][n]),r),K())}formatBlock(e){return{statements:e[0].map(r=>this.formatOpcode(r)),parameters:e[1]}}}const v=new class{expr(t){switch(t.type){case"Missing":return;case"Literal":return this.Literal(t);case"Keyword":return this.Keyword(t);case"CallExpression":return this.CallExpression(t);case"PathExpression":return this.PathExpression(t);case"Arg":return[c.GetSymbol,t.symbol];case"Local":return this.Local(t);case"This":return[c.GetSymbol,0];case"Free":return[t.resolution.resolution(),t.symbol];case"HasBlock":return this.HasBlock(t);case"HasBlockParams":return this.HasBlockParams(t);case"Curry":return this.Curry(t);case"Not":return this.Not(t);case"IfInline":return this.IfInline(t);case"InterpolateExpression":return this.InterpolateExpression(t);case"GetDynamicVar":return this.GetDynamicVar(t);case"Log":return this.Log(t)}}Literal({value:t}){return t===void 0?[c.Undefined]:t}Missing(){}HasBlock({symbol:t}){return[c.HasBlock,[c.GetSymbol,t]]}HasBlockParams({symbol:t}){return[c.HasBlockParams,[c.GetSymbol,t]]}Curry({definition:t,curriedType:e,args:r}){return[c.Curry,v.expr(t),e,v.Positional(r.positional),v.NamedArguments(r.named)]}Local({isTemplateLocal:t,symbol:e}){return[t?c.GetLexicalSymbol:c.GetSymbol,e]}Keyword({symbol:t}){return[c.GetStrictKeyword,t]}PathExpression({head:t,tail:e}){let r=v.expr(t);return k(r[0]!==c.GetStrictKeyword,"[BUG] keyword in a PathExpression"),[...r,v.Tail(e)]}InterpolateExpression({parts:t}){return[c.Concat,t.map(e=>v.expr(e)).toArray()]}CallExpression({callee:t,args:e}){return[c.Call,v.expr(t),...v.Args(e)]}Tail({members:t}){return br(t,e=>e.chars)}Args({positional:t,named:e}){return[this.Positional(t),this.NamedArguments(e)]}Positional({list:t}){return t.map(e=>v.expr(e)).toPresentArray()}NamedArgument({key:t,value:e}){return[t.chars,v.expr(e)]}NamedArguments({entries:t}){let e=t.toArray();if(T(e)){let r=[],s=[];for(let n of e){let[a,i]=v.NamedArgument(n);r.push(a),s.push(i)}return we(r),we(s),[r,s]}return null}Not({value:t}){return[c.Not,v.expr(t)]}IfInline({condition:t,truthy:e,falsy:r}){let s=[c.IfInline,v.expr(t),v.expr(e)];return r&&s.push(v.expr(r)),s}GetDynamicVar({name:t}){return[c.GetDynamicVar,v.expr(t)]}Log({positional:t}){return[c.Log,this.Positional(t)]}};class dr{constructor(e){this.statements=e}toArray(){return this.statements}}const L=new class{list(t){let e=[];for(let r of t){let s=L.content(r);s&&s instanceof dr?e.push(...s.toArray()):e.push(s)}return e}content(t){return this.visitContent(t)}visitContent(t){switch(t.type){case"Debugger":return[c.Debugger,t.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(t);case"AppendTextNode":return this.AppendTextNode(t);case"AppendTrustedHTML":return this.AppendTrustedHTML(t);case"Yield":return this.Yield(t);case"Component":return this.Component(t);case"SimpleElement":return this.SimpleElement(t);case"InElement":return this.InElement(t);case"InvokeBlock":return this.InvokeBlock(t);case"If":return this.If(t);case"Each":return this.Each(t);case"Let":return this.Let(t);case"WithDynamicVars":return this.WithDynamicVars(t);case"InvokeComponent":return this.InvokeComponent(t);default:return Le(t)}}Yield({to:t,positional:e}){return[c.Yield,t,v.Positional(e)]}InElement({guid:t,insertBefore:e,destination:r,block:s}){let n=L.NamedBlock(s)[1],a=v.expr(r),i=v.expr(e);return i===void 0?[c.InElement,n,t,a]:[c.InElement,n,t,a,i]}InvokeBlock({head:t,args:e,blocks:r}){return[c.Block,v.expr(t),...v.Args(e),L.NamedBlocks(r)]}AppendTrustedHTML({html:t}){return[c.TrustingAppend,v.expr(t)]}AppendTextNode({text:t}){return[c.Append,v.expr(t)]}AppendComment({value:t}){return[c.Comment,t.chars]}SimpleElement({tag:t,params:e,body:r,dynamicFeatures:s}){let n=s?c.OpenElementWithSplat:c.OpenElement;return new dr([[n,(a=t.chars,Ha[a]??a)],...L.ElementParameters(e).toArray(),[c.FlushElement],...L.list(r),[c.CloseElement]]);var a}Component({tag:t,params:e,args:r,blocks:s}){let n=v.expr(t),a=L.ElementParameters(e),i=v.NamedArguments(r),l=L.NamedBlocks(s);return[c.Component,n,a.toPresentArray(),i,l]}ElementParameters({body:t}){return t.map(e=>L.ElementParameter(e))}ElementParameter(t){switch(t.type){case"SplatAttr":return[c.AttrSplat,t.symbol];case"DynamicAttr":return[(e=t.kind,e.component?e.trusting?c.TrustingComponentAttr:c.ComponentAttr:e.trusting?c.TrustingDynamicAttr:c.DynamicAttr),...Ua(t)];case"StaticAttr":return[Ra(t.kind),...za(t)];case"Modifier":return[c.Modifier,v.expr(t.callee),...v.Args(t.args)]}var e}NamedBlocks({blocks:t}){let e=[],r=[];for(let s of t.toArray()){let[n,a]=L.NamedBlock(s);e.push(n),r.push(a)}return e.length>0?[e,r]:null}NamedBlock({name:t,body:e,scope:r}){let s=t.chars;return s==="inverse"&&(s="else"),[s,[L.list(e),r.slots]]}If({condition:t,block:e,inverse:r}){return[c.If,v.expr(t),L.NamedBlock(e)[1],r?L.NamedBlock(r)[1]:null]}Each({value:t,key:e,block:r,inverse:s}){return[c.Each,v.expr(t),e?v.expr(e):null,L.NamedBlock(r)[1],s?L.NamedBlock(s)[1]:null]}Let({positional:t,block:e}){return[c.Let,v.Positional(t),L.NamedBlock(e)[1]]}WithDynamicVars({named:t,block:e}){return[c.WithDynamicVars,v.NamedArguments(t),L.NamedBlock(e)[1]]}InvokeComponent({definition:t,args:e,blocks:r}){return[c.InvokeComponent,v.expr(t),v.Positional(e.positional),v.NamedArguments(e.named),r?L.NamedBlocks(r):null]}};function za({name:t,value:e,namespace:r}){let s=[ks(t.chars),e.chars];return r&&s.push(r),s}function Ua({name:t,value:e,namespace:r}){let s=[ks(t.chars),v.expr(e)];return r&&s.push(r),s}function Ra(t){return t.component?c.StaticComponentAttr:c.StaticAttr}const zt=(()=>{const t=typeof module=="object"&&typeof module.require=="function"?module.require:globalThis.require;if(t)try{const e=t("crypto"),r=s=>{const n=e.createHash("sha1");return n.update(s,"utf8"),n.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),ys={id:zt};function ws(t,e=ys){const r=new We.Source(t??"",e.meta?.moduleName),[s,n]=An(r,{lexicalScope:()=>!1,...e}),a=function(i,l,o){let h=new _a(l.table,o),p=I.visitList(l.body,h).mapOk(f=>new Gn({loc:l.loc,scope:l.table,body:f.toArray()}));return o&&(p=p.andThen(f=>Ga.validate(f))),p}(0,s,e.strictMode??!1).mapOk(i=>function(l){let o=L.list(l.body),h=l.scope;return[o,h.symbols,h.hasEval,h.upvars]}(i));if(a.isOk)return[a.value,n];throw a.reason}function ja(t,e=ys){const[r,s]=ws(t,e),n=e.meta?.moduleName,a=e.id||zt,i=JSON.stringify(r),l={id:a(JSON.stringify(e.meta)+i),block:i,moduleName:n??"(unknown template module)",scope:"796d24e6-2450-4fb0-8cdf-b65638b5ef70",isStrictMode:e.strictMode??!1};s.length===0&&delete l.scope;let o=JSON.stringify(l);if(s.length>0){const h=`()=>[${s.join(",")}]`;o=o.replace('"796d24e6-2450-4fb0-8cdf-b65638b5ef70"',h)}return o}const Wa=Object.freeze(Object.defineProperty({__proto__:null,Builder:B,NEWLINE:In,ProgramSymbols:cs,WireFormatDebugger:Va,buildStatement:at,buildStatements:Bn,c:On,defaultId:zt,precompile:ja,precompileJSON:ws,s:Ln,unicode:Hn},Symbol.toStringTag,{value:"Module"})),{precompileJSON:Ka}=fr(Wa),{getTemplateLocals:Ya}=fr(Hs);function Qa(t,e={}){let r=vs(t),s,n;try{s=As(Ja(t,{moduleName:e.moduleName||r,...e}),Ss(void 0,"hbs:component"))}catch(a){n=a}return{name:r,component:s,error:n}}function Ja(t,{moduleName:e,scope:r={}}){let s={array:Bs,concat:Ns,fn:Ps,get:xs,hash:Cs,on:Es,...r},n=Ya(t),a={strictMode:!0,moduleName:e,locals:n,isProduction:!1,meta:{moduleName:e}},[i,l]=Ka(t,a),o=l.map(g=>{let S=s[g];if(!S)throw new Error(`Attempt to use ${g} in compiled hbs, but it was not available in scope. Available scope includes: ${Object.keys(s)}`);return S}),h=JSON.stringify(i);return Ts({id:e,block:h,moduleName:e??"(dynamically compiled component)",scope:()=>o,isStrictMode:!0})}export{Qa as compileHBS};
